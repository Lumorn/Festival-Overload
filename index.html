<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Festival Overload ‚Äì spielbarer Prototyp (Simultan Camp/Bleib)</title>
  <style>
    :root{
      --bg1:#050812; --bg2:#0b1020; --bg3:#060812;
      --panel:rgba(20,27,42,.92);
      --panel2:rgba(11,15,23,.55);
      --stroke:rgba(148,163,184,.16);
      --stroke2:rgba(148,163,184,.22);
      --muted:#9aa8c1;
      --mutedStrong:#b4c0d8;
      --text:#e8edf7;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --chip:rgba(31,42,68,.92);
      --shadow:0 12px 38px rgba(0,0,0,.45);
      --blue:#60a5fa;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    html, body{height:100%}
    body{margin:0;color:var(--text);background:
      radial-gradient(900px 380px at 10% 0%, rgba(99,102,241,.20), transparent 55%),
      radial-gradient(700px 320px at 80% 8%, rgba(34,197,94,.18), transparent 55%),
      radial-gradient(800px 360px at 30% 90%, rgba(245,158,11,.14), transparent 55%),
      linear-gradient(180deg,var(--bg1), var(--bg2) 45%, var(--bg3));
      overflow:hidden;
    }

    .wrap{max-width:1400px;margin:0 auto;padding:14px;height:100%;display:flex;flex-direction:column;gap:12px}

    .devOnly{display:block}
    .playOnly{display:none}
    body.ui-play .devOnly{display:none}
    body.ui-play .playOnly{display:block}
    body.ui-dev .devOnly{display:block}
    body.ui-dev .playOnly{display:none}

    .topBar{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      border-radius:16px;
      background:rgba(11,15,23,.55);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      min-height:64px;
    }
    .topLeft{display:flex;align-items:center;gap:12px}
    .topCenter{text-align:center}
    .topRight{display:flex;justify-content:flex-end;align-items:center;gap:10px;flex-wrap:wrap}
    .gameTitle{display:flex;flex-direction:column;gap:2px}
    .gameTitle b{font-size:16px;letter-spacing:.2px}
    .gameTitle span{font-size:12px;color:var(--mutedStrong)}
    .playTitle{font-size:13px;color:var(--mutedStrong);font-weight:700;letter-spacing:.25px}
    .playTitle b{color:var(--text)}
    .roundEvent{font-size:16px;font-weight:900;letter-spacing:.2px}
    .roundEvent small{display:block;font-size:12px;color:var(--mutedStrong);font-weight:500}
    .statusHeadline{font-size:24px;font-weight:950;letter-spacing:.3px}
    .roundBadge{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:999px;background:rgba(31,42,68,.7);border:1px solid rgba(148,163,184,.18);font-size:12px;position:relative}
    .goalChip{padding:6px 10px;border-radius:999px;background:rgba(34,197,94,.16);border:1px solid rgba(34,197,94,.38);font-size:12px;font-weight:700}
    .statusIcons{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .statusChip{display:none;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.18);background:rgba(31,42,68,.6);font-size:12px}
    .statusChip.active{display:inline-flex}
    .statusChip.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .statusChip.blue{border-color:rgba(96,165,250,.4);background:rgba(96,165,250,.12)}
    .statusChip.bad{border-color:rgba(239,68,68,.4);background:rgba(239,68,68,.12)}
    .modeToggle{display:inline-flex;gap:6px}
    .modeToggle .btn.active{border-color:rgba(226,232,240,.45);background:rgba(255,255,255,.08);font-weight:800}

    h1{margin:0;font-size:20px;letter-spacing:.2px}
    .sub{color:var(--mutedStrong);font-size:14px;max-width:920px;line-height:1.45}

    .ver{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:14px;
      background:rgba(31,42,68,.55);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      cursor:pointer;
      user-select:none;
      transition:.12s transform,.12s border-color,.12s filter;
    }
    .ver:hover{transform:translateY(-1px);border-color:rgba(226,232,240,.35);filter:brightness(1.03)}
    .ver b{font-weight:900}

    .grid{display:grid;grid-template-columns:1.4fr .9fr;gap:12px;flex:1;min-height:0}
    .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;padding:12px;box-shadow:var(--shadow);min-height:0;display:flex;flex-direction:column;gap:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .pill{background:var(--chip);border:1px solid var(--stroke2);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--text);position:relative}
    .pill b{font-weight:800}
    .pill.good{border-color:rgba(34,197,94,.35)}
    .pill.warn{border-color:rgba(245,158,11,.35)}
    .pill.bad{border-color:rgba(239,68,68,.35)}
    .pill.blue{border-color:rgba(96,165,250,.35)}
    .big{font-size:14px}

    .bar{height:12px;background:rgba(148,163,184,.14);border-radius:999px;overflow:hidden;border:1px solid var(--stroke2);position:relative}
    .bar > div{height:100%;background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444);width:0%;transition:width .18s ease}
    .bar:after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}

    .tableau{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:10px}
    .stack{
      background:rgba(11,15,23,.35);
      border:1px solid rgba(148,163,184,.12);
      border-radius:16px;
      padding:10px;
      min-height:160px;
      position:relative;
      overflow:hidden;
    }
    .stackTitle{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:12px}
    .stackTitle b{color:var(--text)}
    .cardStack{position:relative;height:110px;margin-top:8px}
    .cardStack.empty{opacity:.45}
    .cardBack{
      position:absolute;inset:0;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.22);
      background:
        linear-gradient(135deg, rgba(99,102,241,.22), rgba(15,23,42,.85)),
        radial-gradient(180px 120px at 20% 20%, rgba(255,255,255,.08), transparent 60%);
      box-shadow:0 12px 28px rgba(0,0,0,.35);
    }
    .cardBack.layer2{transform:translate(6px,6px);opacity:.75}
    .cardBack.layer3{transform:translate(12px,12px);opacity:.5}
    .cardBack.discard{
      background:
        linear-gradient(135deg, rgba(239,68,68,.18), rgba(15,23,42,.85)),
        radial-gradient(180px 120px at 20% 20%, rgba(255,255,255,.06), transparent 60%);
    }

    .cardFace{
      position:relative;
      height:110px;
      border-radius:14px;
      padding:10px;
      border:1px solid rgba(148,163,184,.22);
      background:
        radial-gradient(140px 90px at 20% 20%, rgba(255,255,255,.12), transparent 60%),
        rgba(31,42,68,.78);
      box-shadow:0 14px 30px rgba(0,0,0,.4);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .cardFace:before{
      content:"";
      position:absolute;left:0;right:0;top:0;height:8px;
      background:rgba(148,163,184,.35);
    }
    .cardFace[data-type="push"]:before{background:rgba(239,68,68,.85)}
    .cardFace[data-type="stabilize"]:before{background:rgba(34,197,94,.85)}
    .cardFace[data-type="twist"]:before{background:rgba(245,158,11,.85)}
    .cardFace[data-type="encore"]:before{background:rgba(96,165,250,.85)}
    .cardFace[data-type="empty"]:before{background:rgba(148,163,184,.35)}

    .rTop{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-top:6px}
    .rName{font-weight:900;font-size:12px}
    .rType{font-size:11px;color:#d6dbea}
    .rText{font-size:11px;color:#d6dbea;line-height:1.28}

    .hint{color:var(--mutedStrong);font-size:12px;margin-top:10px;line-height:1.45}
    .mini{font-size:12px;color:var(--mutedStrong);line-height:1.45}
    .sep{height:1px;background:rgba(148,163,184,.14);margin:10px 0}

    .players{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .p{background:var(--panel2);border:1px solid rgba(148,163,184,.14);border-radius:14px;padding:10px}
    .p .name{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;gap:10px}
    .tag{font-size:11px;color:var(--muted)}
    .turn{color:#fff;background:rgba(34,197,94,.18);border:1px solid rgba(34,197,94,.35);padding:2px 8px;border-radius:999px;font-size:11px;white-space:nowrap}
    .camped{color:#fff;background:rgba(245,158,11,.18);border:1px solid rgba(245,158,11,.35);padding:2px 8px;border-radius:999px;font-size:11px;white-space:nowrap}

    .eventWrap{
      margin-top:8px;
      padding:12px;
      background:rgba(11,15,23,.35);
      border:1px solid rgba(148,163,184,.12);
      border-radius:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .eventCard{
      position:relative;
      border-radius:18px;
      padding:12px 12px 14px;
      border:1px solid rgba(148,163,184,.22);
      box-shadow:0 14px 34px rgba(0,0,0,.38);
      background:
        radial-gradient(180px 110px at 18% 16%, rgba(255,255,255,.10), transparent 60%),
        radial-gradient(220px 120px at 90% 10%, rgba(99,102,241,.18), transparent 62%),
        radial-gradient(240px 140px at 20% 110%, rgba(34,197,94,.10), transparent 62%),
        rgba(31,42,68,.75);
      min-height:118px;
      overflow:hidden;
    }
    .eventCard:before{
      content:"";
      position:absolute;inset:0;
      background:
        linear-gradient(120deg, rgba(255,255,255,.10), transparent 35%, rgba(255,255,255,.06) 55%, transparent 72%),
        radial-gradient(420px 180px at 20% 0%, rgba(255,255,255,.07), transparent 55%);
      opacity:.75;
      pointer-events:none;
    }
    .eventCard:after{
      content:"";
      position:absolute;inset:7px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      pointer-events:none;
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.18);
    }
    .stripe{position:absolute;left:0;top:0;right:0;height:8px;background:rgba(148,163,184,.35);box-shadow:0 10px 24px rgba(0,0,0,.18)}
    .eventCard[data-type="push"] .stripe{background:rgba(239,68,68,.85)}
    .eventCard[data-type="stabilize"] .stripe{background:rgba(34,197,94,.85)}
    .eventCard[data-type="twist"] .stripe{background:rgba(245,158,11,.85)}
    .eventCard[data-type="encore"] .stripe{background:rgba(96,165,250,.85)}

    .kTop{display:flex;justify-content:space-between;align-items:center;margin-top:6px;margin-bottom:10px;gap:10px;position:relative;z-index:2}
    .kName{font-weight:950;letter-spacing:.2px}
    .kType{display:inline-flex;align-items:center;gap:6px;font-size:11px;color:#d7deee;white-space:nowrap}
    .dot{width:8px;height:8px;border-radius:999px;display:inline-block}
    .kText{font-size:12px;color:#d6dbea;line-height:1.28;position:relative;z-index:2}

    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:0;justify-content:flex-end}
    .btn{background:rgba(148,163,184,.10);border:1px solid rgba(148,163,184,.22);border-radius:14px;padding:10px 12px;color:var(--text);cursor:pointer;transition:.12s transform,.12s border-color}
    .btn:hover{transform:translateY(-1px);border-color:rgba(226,232,240,.35)}
    .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
    .btn.warn{background:rgba(245,158,11,.16);border-color:rgba(245,158,11,.32)}
    .btn.bad{background:rgba(239,68,68,.14);border-color:rgba(239,68,68,.32)}
    .btn.good{background:rgba(34,197,94,.14);border-color:rgba(34,197,94,.32)}
    .btn.blue{background:rgba(96,165,250,.14);border-color:rgba(96,165,250,.32)}
    .btn.slim{padding:8px 10px;border-radius:12px;font-size:12px}

    .decision{
      margin-top:0;
      display:none;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(245,158,11,.10);
      border:1px solid rgba(245,158,11,.25);
    }
    .decision b{font-weight:950}
    .decisionRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}
    .choice{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .logWrap{display:flex;flex-direction:column;gap:8px;min-height:0}
    .logHead{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .logActions{display:flex;gap:8px;align-items:center}
    .log{flex:1;min-height:240px;overflow:auto;background:rgba(16,22,35,.65);border:1px solid rgba(148,163,184,.18);border-radius:14px;padding:12px;font-size:13px;line-height:1.5}
    .log .t{color:var(--muted)}
    .playLog .t{color:var(--muted)}
    .log .evt{padding:8px 10px;border-radius:12px;border:1px solid rgba(148,163,184,.16);background:rgba(0,0,0,.18);margin-bottom:8px;box-shadow:0 10px 22px rgba(0,0,0,.18)}
    .log .evt.good{border-color:rgba(34,197,94,.22);background:rgba(34,197,94,.06)}
    .log .evt.warn{border-color:rgba(245,158,11,.22);background:rgba(245,158,11,.06)}
    .log .evt.bad{border-color:rgba(239,68,68,.22);background:rgba(239,68,68,.06)}
    .log .evt.info{border-color:rgba(99,102,241,.18);background:rgba(99,102,241,.05)}
    .playLog .evt{padding:8px 10px;border-radius:12px;border:1px solid rgba(148,163,184,.16);background:rgba(0,0,0,.18);margin-bottom:8px;box-shadow:0 10px 22px rgba(0,0,0,.18)}
    .playLog .evt.good{border-color:rgba(34,197,94,.22);background:rgba(34,197,94,.06)}
    .playLog .evt.warn{border-color:rgba(245,158,11,.22);background:rgba(245,158,11,.06)}
    .playLog .evt.bad{border-color:rgba(239,68,68,.22);background:rgba(239,68,68,.06)}
    .playLog .evt.info{border-color:rgba(99,102,241,.18);background:rgba(99,102,241,.05)}

    .toggle{display:flex;gap:10px;align-items:flex-end;flex-wrap:wrap;justify-content:flex-end}
    .botControls{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    input[type=checkbox]{transform:scale(1.08)}
    select{background:rgba(148,163,184,.10);color:var(--text);border:1px solid rgba(148,163,184,.22);border-radius:10px;padding:6px 8px}

    .toast{position:fixed;left:18px;bottom:18px;max-width:520px;padding:10px 12px;border-radius:14px;background:rgba(31,42,68,.92);border:1px solid rgba(148,163,184,.22);color:var(--text);box-shadow:var(--shadow);display:none;z-index:80}
    .toast small{color:var(--muted)}

    .modalBack{
      position:fixed;inset:0;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:90;
      padding:18px;
    }
    .modal{
      width:min(720px, 100%);
      background:rgba(20,27,42,.97);
      border:1px solid rgba(148,163,184,.22);
      border-radius:18px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalTop{
      display:flex;justify-content:space-between;align-items:center;gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(148,163,184,.14);
      background:rgba(11,15,23,.35);
    }
    .modalTop b{font-weight:950}
    .modalBody{padding:12px 14px;max-height:62vh;overflow:auto}

    .confirmText{color:#d6dbea;line-height:1.35}
    .confirmBtns{display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;margin-top:12px}

    .pickList{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .pickBtn{width:100%;text-align:left}

    code{color:#d6dbea}

    /* --- UX: Phase + Steps + Summary --- */
    .steps{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .step{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(31,42,68,.45);border:1px solid rgba(148,163,184,.14);font-size:12px;color:var(--muted);user-select:none}
    .step .n{width:18px;height:18px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;background:rgba(148,163,184,.16);border:1px solid rgba(148,163,184,.18);color:var(--text);font-weight:900;font-size:11px}
    .step.active{color:var(--text);border-color:rgba(226,232,240,.35);background:rgba(31,42,68,.85);box-shadow:0 8px 20px rgba(0,0,0,.25)}
    .step.active .n{background:rgba(99,102,241,.32);border-color:rgba(99,102,241,.45)}

    .banner{display:none;margin-top:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(148,163,184,.14);background:rgba(31,42,68,.35);box-shadow:0 10px 28px rgba(0,0,0,.25)}
    .banner.show{display:block}
    .banner.good{border-color:rgba(34,197,94,.30);background:rgba(34,197,94,.06)}
    .banner.warn{border-color:rgba(245,158,11,.30);background:rgba(245,158,11,.06)}
    .banner.bad{border-color:rgba(239,68,68,.30);background:rgba(239,68,68,.06)}
    .banner b{font-weight:950}
    .banner small{color:var(--muted)}

    .eventSummary{margin-top:10px;padding:10px 12px;border-radius:14px;background:rgba(31,42,68,.45);border:1px solid rgba(148,163,184,.14)}
    .sumTitle{display:flex;justify-content:space-between;align-items:baseline;gap:10px}
    .sumRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .dChip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.10);border:1px solid rgba(148,163,184,.14);font-size:12px}
    .dChip.good{border-color:rgba(34,197,94,.30)}
    .dChip.warn{border-color:rgba(245,158,11,.30)}
    .dChip.bad{border-color:rgba(239,68,68,.30)}
    .dChip.blue{border-color:rgba(96,165,250,.30)}
    .dChip .sym{opacity:.95}

    .bar .tick{position:absolute;top:-22px;transform:translateX(-50%);font-size:11px;color:var(--muted);padding:2px 6px;border-radius:999px;background:rgba(0,0,0,.16);border:1px solid rgba(148,163,184,.14)}
    .bar .tick:after{content:"";position:absolute;left:50%;top:100%;width:1px;height:16px;background:rgba(148,163,184,.18)}
    .bar .t8{left:66.6667%}
    .bar .t12{left:100%}

    .decide{color:#fff;background:rgba(96,165,250,.18);border:1px solid rgba(96,165,250,.35);padding:2px 8px;border-radius:999px;font-size:11px;white-space:nowrap}

    .p.turnGlow{border-color:rgba(34,197,94,.35);box-shadow:0 0 0 1px rgba(34,197,94,.18), 0 12px 34px rgba(0,0,0,.25)}
    .p.decideGlow{border-color:rgba(245,158,11,.35);box-shadow:0 0 0 1px rgba(245,158,11,.16), 0 12px 34px rgba(0,0,0,.22)}
    .p.campedDim{opacity:.78}

    /* --- Visual Clarity Patch: Feedback, Deltas, Impact --- */
    .pill:focus{outline:none}

    .deltaBadge{
      position:absolute;right:-8px;top:-8px;
      display:none;
      align-items:center;justify-content:center;
      padding:3px 7px;
      border-radius:999px;
      font-size:11px;
      font-weight:950;
      letter-spacing:.15px;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(31,42,68,.92);
      box-shadow:0 12px 34px rgba(0,0,0,.35);
      transform:translateY(0) scale(.98);
      opacity:0;
      pointer-events:none;
      z-index:5;
    }

    @keyframes popBadge{
      0%{opacity:0;transform:translateY(4px) scale(.95)}
      18%{opacity:1;transform:translateY(0) scale(1)}
      100%{opacity:0;transform:translateY(-4px) scale(.98)}
    }

    @keyframes statPulse{
      0%{box-shadow:0 0 0 0 rgba(255,255,255,0)}
      40%{box-shadow:0 0 0 3px rgba(255,255,255,.06), 0 16px 46px rgba(0,0,0,.34)}
      100%{box-shadow:0 0 0 0 rgba(255,255,255,0)}
    }

    .flash-good{border-color:rgba(34,197,94,.45)!important;animation:statPulse .55s ease}
    .flash-warn{border-color:rgba(245,158,11,.45)!important;animation:statPulse .55s ease}
    .flash-bad{border-color:rgba(239,68,68,.50)!important;animation:statPulse .55s ease}
    .flash-blue{border-color:rgba(96,165,250,.50)!important;animation:statPulse .55s ease}

    .flash-good .deltaBadge{display:inline-flex;border-color:rgba(34,197,94,.45);background:rgba(34,197,94,.14);animation:popBadge .75s ease}
    .flash-warn .deltaBadge{display:inline-flex;border-color:rgba(245,158,11,.45);background:rgba(245,158,11,.14);animation:popBadge .75s ease}
    .flash-bad  .deltaBadge{display:inline-flex;border-color:rgba(239,68,68,.55);background:rgba(239,68,68,.12);animation:popBadge .75s ease}
    .flash-blue .deltaBadge{display:inline-flex;border-color:rgba(96,165,250,.55);background:rgba(96,165,250,.12);animation:popBadge .75s ease}

    /* Pool kleine Stapel-Optik */
    #poolChip::after{
      content:"";
      position:absolute;right:10px;bottom:8px;
      width:18px;height:14px;
      border-radius:4px;
      background:rgba(255,255,255,.05);
      box-shadow:
        -4px -3px 0 0 rgba(255,255,255,.03),
        -8px -6px 0 0 rgba(255,255,255,.02);
      border:1px solid rgba(148,163,184,.16);
      opacity:.9;
      pointer-events:none;
    }

    /* Event Impact Row */
    .impact{display:flex;gap:8px;flex-wrap:wrap;margin:-2px 0 10px;position:relative;z-index:2}
    .imp{display:inline-flex;align-items:center;gap:7px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.14);background:rgba(0,0,0,.12);font-size:12px;color:#e8edf7}
    .imp b{font-weight:950}
    .imp.good{border-color:rgba(34,197,94,.28);background:rgba(34,197,94,.06)}
    .imp.warn{border-color:rgba(245,158,11,.28);background:rgba(245,158,11,.06)}
    .imp.bad{border-color:rgba(239,68,68,.28);background:rgba(239,68,68,.06)}
    .imp.blue{border-color:rgba(96,165,250,.28);background:rgba(96,165,250,.06)}

    /* Spieler: deutlicher Live/Camp als Karten-Icons + Deltazeile */
    .pPills{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pPill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.10);border:1px solid rgba(148,163,184,.14);font-size:12px}
    .pPill b{font-weight:950}
    .ci{width:12px;height:10px;border-radius:3px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);box-shadow:0 6px 18px rgba(0,0,0,.22)}
    .ci.live{transform:rotate(-14deg)}
    .deltaLine{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
    .dTag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid rgba(148,163,184,.14);background:rgba(0,0,0,.10);font-size:11px;color:#d6dbea}
    .dTag.good{border-color:rgba(34,197,94,.28);background:rgba(34,197,94,.05)}
    .dTag.warn{border-color:rgba(245,158,11,.28);background:rgba(245,158,11,.05)}
    .dTag.bad{border-color:rgba(239,68,68,.28);background:rgba(239,68,68,.05)}
    .dTag.blue{border-color:rgba(96,165,250,.28);background:rgba(96,165,250,.05)}

    /* Bildschirm-Flash bei Knall/Sieg */
    body.flashBad::before, body.flashGood::before{
      content:"";position:fixed;inset:0;pointer-events:none;z-index:999;
      background:transparent;
      animation:screenFlash .55s ease;
    }
    body.flashBad::before{background:rgba(239,68,68,.14)}
    body.flashGood::before{background:rgba(34,197,94,.12)}
    @keyframes screenFlash{0%{opacity:0}20%{opacity:1}100%{opacity:0}}

    /* Event Card: kleine Reveal-Animation */
    @keyframes cardPop{0%{transform:translateY(8px) scale(.985);filter:brightness(.96)}40%{transform:translateY(0) scale(1);filter:brightness(1.05)}100%{transform:translateY(0) scale(1);filter:brightness(1)}}
    .eventCard.pop{animation:cardPop .32s ease}

    .mainColumns{display:grid;grid-template-columns:minmax(0,1fr) 360px;gap:12px;align-items:start;min-height:0}
    .sideCard{min-height:0}
    .sideScroll{overflow:auto;min-height:0;display:flex;flex-direction:column;gap:12px}

    .sideSection{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.16);
      background:rgba(31,42,68,.28);
    }
    .sideTitle{
      font-size:13px;
      font-weight:800;
      letter-spacing:.2px;
      margin-bottom:6px;
    }
    .ruleList{list-style:none;padding:0;margin:8px 0 0;display:flex;flex-direction:column;gap:8px}
    .ruleList li{padding:8px 10px;border-radius:12px;border:1px solid rgba(148,163,184,.12);background:rgba(0,0,0,.12);line-height:1.45}
    .ruleList li b{font-weight:800}

    .actionDock{
      display:grid;
      grid-template-columns:minmax(0,1fr) auto;
      gap:12px;
      align-items:center;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.14);
      background:rgba(31,42,68,.35);
    }
    .actionDock .decision{padding:0;border:0;background:transparent}
    .actionDock .decisionRow{justify-content:flex-start}
    .actionDock .controls{gap:12px}

    .btn.primary{
      background:linear-gradient(135deg, rgba(34,197,94,.25), rgba(34,197,94,.08));
      border-color:rgba(34,197,94,.4);
      box-shadow:0 12px 28px rgba(0,0,0,.25);
      font-weight:700;
    }

    details.fold{border:1px solid rgba(148,163,184,.14);border-radius:14px;padding:8px 10px;background:rgba(31,42,68,.28)}
    details.fold summary{cursor:pointer;list-style:none;font-size:12px;color:var(--muted);font-weight:700}
    details.fold summary::-webkit-details-marker{display:none}
    details.fold .hint{margin-top:8px}

    /* --- Scorett Layout --- */
    .mainGrid{display:grid;grid-template-columns:minmax(0,1.6fr) minmax(0,.9fr) minmax(0,1fr);gap:12px;flex:1;min-height:0}
    .playLayout{display:none;grid-template-columns:minmax(0,1.2fr) minmax(0,.8fr);gap:12px;flex:1;min-height:0}
    body.ui-play .playLayout{display:grid}
    body.ui-play .devLayout{display:none}
    body.ui-dev .playLayout{display:none}
    body.ui-dev .devLayout{display:grid}

    .playStage{
      display:flex;
      flex-direction:column;
      gap:14px;
      padding:16px;
      border-radius:18px;
      background:var(--panel);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      min-height:0;
    }
    .playOverloadTrack{padding:14px;border-radius:18px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.14)}
    .playOverloadTrack .overloadPill{font-size:12px;padding:8px 0}
    .playOverloadTrack.pulse{animation:trackPulse .55s ease}
    .playOverloadTrack.pulseStrong{animation:trackPulseStrong .6s ease}
    .playOverloadTrack.shake{animation:trackShake .5s ease}
    @keyframes trackPulse{0%{box-shadow:0 0 0 rgba(255,255,255,0)}40%{box-shadow:0 0 0 4px rgba(255,255,255,.08)}100%{box-shadow:0 0 0 rgba(255,255,255,0)}}
    @keyframes trackPulseStrong{0%{box-shadow:0 0 0 rgba(245,158,11,0)}40%{box-shadow:0 0 0 6px rgba(245,158,11,.18)}100%{box-shadow:0 0 0 rgba(245,158,11,0)}}
    @keyframes trackShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}}

    .playCard{
      min-height:420px;
      border-radius:22px;
      padding:18px;
      background:rgba(31,42,68,.82);
      border:1px solid rgba(148,163,184,.22);
      box-shadow:0 20px 46px rgba(0,0,0,.45);
    }
    .playCard .kName{font-size:22px}
    .playCard .kType{font-size:13px}
    .playCard .kText{font-size:16px;line-height:1.4;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
    .playChips{display:flex;gap:8px;flex-wrap:wrap}
    .playChip{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border-radius:999px;border:1px solid rgba(148,163,184,.18);background:rgba(0,0,0,.18);font-size:13px;font-weight:700}
    .playChip.good{border-color:rgba(34,197,94,.38);background:rgba(34,197,94,.12)}
    .playChip.warn{border-color:rgba(245,158,11,.38);background:rgba(245,158,11,.12)}
    .playChip.bad{border-color:rgba(239,68,68,.38);background:rgba(239,68,68,.12)}
    .playChip.blue{border-color:rgba(96,165,250,.38);background:rgba(96,165,250,.12)}

    .playPoolRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .playPoolChip{padding:10px 16px;border-radius:999px;background:rgba(96,165,250,.18);border:1px solid rgba(96,165,250,.4);font-size:16px;font-weight:900}
    .playCountdownBadge{padding:6px 10px;border-radius:999px;border:1px solid rgba(245,158,11,.35);background:rgba(245,158,11,.16);font-size:12px;font-weight:800;display:none}
    .playCountdownBadge.active{display:inline-flex}
    .playPrimary{padding:14px 18px;font-size:16px;font-weight:800;border-radius:16px}
    .playPrimary:disabled{opacity:.5}

    .playPlayers{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:16px;
      border-radius:18px;
      background:var(--panel);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      min-height:0;
    }
    .playPlayersHeader{display:flex;justify-content:space-between;align-items:center;font-weight:900}
    .playPlayersList{display:flex;flex-direction:column;gap:10px;overflow:auto;min-height:0}
    .playPlayer{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 12px;border-radius:14px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.16)}
    .playPlayerMain{display:flex;align-items:center;gap:8px;font-weight:800}
    .playPlayerRight{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .playStatus{font-size:11px;padding:4px 8px;border-radius:999px}
    .playStatus.active{background:rgba(34,197,94,.18);border:1px solid rgba(34,197,94,.4)}
    .playStatus.camped{background:rgba(245,158,11,.18);border:1px solid rgba(245,158,11,.4)}
    .playStatus.out{background:rgba(239,68,68,.18);border:1px solid rgba(239,68,68,.4)}
    .playStats{display:flex;gap:8px;font-size:12px;color:var(--mutedStrong)}
    .playRevealer{font-size:12px;padding:2px 6px;border-radius:999px;background:rgba(96,165,250,.2);border:1px solid rgba(96,165,250,.4)}

    .playDrawer{
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }
    .playLogDrawer{
      position:fixed;
      left:12px;
      right:12px;
      bottom:12px;
      max-height:40vh;
      background:rgba(20,27,42,.98);
      border:1px solid rgba(148,163,184,.22);
      border-radius:18px;
      box-shadow:0 20px 60px rgba(0,0,0,.6);
      padding:12px;
      display:none;
      z-index:140;
    }
    .playLogDrawer.open{display:block}
    .playLogHead{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .playLog{overflow:auto;max-height:30vh;border-radius:12px;border:1px solid rgba(148,163,184,.16);background:rgba(11,15,23,.55);padding:10px;font-size:12px;line-height:1.5}

    .playBanner{
      display:none;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(31,42,68,.45);
      border:1px solid rgba(148,163,184,.16);
      font-weight:800;
    }
    .playBanner.show{display:block}
    .playBanner.good{border-color:rgba(34,197,94,.35);background:rgba(34,197,94,.08)}
    .playBanner.warn{border-color:rgba(245,158,11,.35);background:rgba(245,158,11,.08)}
    .playBanner.bad{border-color:rgba(239,68,68,.35);background:rgba(239,68,68,.08)}

    .stageCard{display:flex;flex-direction:column;gap:12px}
    .stageTop{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .stageMeta{display:flex;gap:8px;flex-wrap:wrap}
    .stageChip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:rgba(31,42,68,.65);border:1px solid rgba(148,163,184,.18);font-size:12px;position:relative}
    .stageChip b{font-weight:900}
    .stageChip.blue{border-color:rgba(96,165,250,.4);background:rgba(96,165,250,.12)}
    .stageChip.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .stageChip.bad{border-color:rgba(239,68,68,.4);background:rgba(239,68,68,.12)}

    .overloadTrack{display:flex;flex-direction:column;gap:8px;padding:10px;border-radius:16px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.14)}
    .overloadTrackHeader{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .overloadPills{display:grid;grid-template-columns:repeat(13, minmax(0,1fr));gap:6px}
    .overloadPill{display:flex;align-items:center;justify-content:center;padding:6px 0;border-radius:999px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.6);font-size:11px;color:var(--muted)}
    .overloadPill.mark{border-color:rgba(245,158,11,.4);color:#fff}
    .overloadPill.danger{border-color:rgba(239,68,68,.45);color:#fff}
    .overloadPill.active{box-shadow:0 0 0 2px rgba(255,255,255,.12), 0 0 16px rgba(99,102,241,.25);background:rgba(99,102,241,.28);color:#fff;font-weight:900}
    .overloadHint{font-size:12px;color:var(--mutedStrong)}
    .overloadHint .chip{padding:4px 8px;border-radius:999px;background:rgba(245,158,11,.12);border:1px solid rgba(245,158,11,.3);font-size:11px}

    .stageGrid{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,280px);gap:12px;min-height:0}
    .currentCard{min-height:360px;border-radius:20px;padding:16px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.75);box-shadow:0 18px 38px rgba(0,0,0,.45);position:relative;overflow:hidden}
    .currentCard .kName{font-size:18px}
    .currentCard .kText{font-size:14px}
    .currentCard .impact{margin-top:8px}

    .poolPanel{display:flex;flex-direction:column;gap:10px;padding:12px;border-radius:16px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.14)}
    .poolChip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(96,165,250,.16);border:1px solid rgba(96,165,250,.38);font-size:14px;font-weight:900}
    .poolStack{display:flex;gap:8px;align-items:center}
    .poolCards{display:flex;gap:6px}
    .poolCard{width:36px;height:48px;border-radius:8px;border:1px solid rgba(148,163,184,.22);background:linear-gradient(135deg, rgba(99,102,241,.2), rgba(15,23,42,.85));box-shadow:0 10px 24px rgba(0,0,0,.35)}
    .poolCard:nth-child(2){transform:translateY(4px);opacity:.8}
    .poolCard:nth-child(3){transform:translateY(8px);opacity:.6}

    .actionRow{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;padding:10px 12px;border-radius:14px;background:rgba(31,42,68,.35);border:1px solid rgba(148,163,184,.14)}
    .actionRow .controls{margin:0}

    .playersCard{display:flex;flex-direction:column;gap:12px;min-height:0}
    .playersHeader{display:flex;justify-content:space-between;align-items:center}
    .playersList{display:flex;flex-direction:column;gap:10px;overflow:auto;min-height:0}
    .playerCard{padding:12px;border-radius:16px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.16);display:flex;flex-direction:column;gap:10px}
    .playerHeader{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .playerName{font-weight:900;font-size:14px;display:flex;align-items:center;gap:8px}
    .playerAvatar{width:32px;height:32px;border-radius:10px;background:rgba(99,102,241,.25);display:flex;align-items:center;justify-content:center;font-weight:900}
    .playerBadge{padding:4px 10px;border-radius:999px;font-size:11px;font-weight:800;letter-spacing:.2px}
    .badgeActive{background:rgba(34,197,94,.16);border:1px solid rgba(34,197,94,.35);color:#fff}
    .badgeCamp{background:rgba(245,158,11,.16);border:1px solid rgba(245,158,11,.35);color:#fff}
    .playerStats{display:flex;gap:8px;flex-wrap:wrap}
    .playerStat{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.18);border:1px solid rgba(148,163,184,.18);font-size:12px}
    .playerStat b{font-weight:900}
    .playerActions{display:flex;gap:6px;flex-wrap:wrap}
    .playerMark{padding:4px 8px;border-radius:999px;font-size:11px;background:rgba(96,165,250,.14);border:1px solid rgba(96,165,250,.3)}
    .playerMark.warn{background:rgba(245,158,11,.14);border-color:rgba(245,158,11,.3)}
    .playerCard.turnGlow{border-color:rgba(34,197,94,.35);box-shadow:0 0 0 1px rgba(34,197,94,.18), 0 12px 34px rgba(0,0,0,.25)}
    .playerCard.decideGlow{border-color:rgba(245,158,11,.35);box-shadow:0 0 0 1px rgba(245,158,11,.16), 0 12px 34px rgba(0,0,0,.22)}
    .playerCard.campedDim{opacity:.78}

    .rightPanel{display:flex;flex-direction:column;gap:12px;min-height:0}
    .rightPanel .sideSection{background:rgba(11,15,23,.45)}
    .rightPanel .log{min-height:200px}

    .decisionOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:120;background:rgba(3,6,12,.78);backdrop-filter:blur(6px)}
    .decisionOverlay.show{display:flex}
    .decisionModal{width:min(820px, 100%);background:rgba(20,27,42,.97);border:1px solid rgba(148,163,184,.22);border-radius:20px;box-shadow:0 22px 70px rgba(0,0,0,.6);padding:18px;display:flex;flex-direction:column;gap:14px}
    .decisionHeader{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .decisionTitle{font-size:22px;font-weight:950}
    .decisionStats{display:flex;gap:8px;flex-wrap:wrap}
    .decisionStat{padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.2);border:1px solid rgba(148,163,184,.16);font-size:13px}
    .decisionAvatars{display:flex;gap:8px;flex-wrap:wrap}
    .decisionMain{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
    .decisionBots{display:flex;flex-direction:column;gap:10px}
    .decisionBots.hidden{display:none}
    .decisionBotRow{display:flex;flex-direction:column;gap:8px;padding:10px 12px;border-radius:14px;border:1px solid rgba(148,163,184,.18);background:rgba(11,15,23,.45)}
    .decisionBotHead{display:flex;justify-content:space-between;align-items:center;gap:10px;font-weight:800}
    .decisionBotChoices{display:flex;gap:8px;flex-wrap:wrap}
    .decisionBotBtn{padding:8px 12px;border-radius:12px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.6);cursor:pointer}
    .decisionBotBtn.good{border-color:rgba(34,197,94,.4);background:rgba(34,197,94,.12)}
    .decisionBotBtn.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .decisionBotBtn.selected{box-shadow:0 0 0 2px rgba(255,255,255,.14), 0 12px 28px rgba(0,0,0,.25)}
    .decisionBtn{padding:16px;border-radius:16px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.6);display:flex;flex-direction:column;gap:6px;align-items:flex-start;cursor:pointer}
    .decisionBtn strong{font-size:20px}
    .decisionBtn small{color:var(--mutedStrong)}
    .decisionBtn.good{border-color:rgba(34,197,94,.4);background:rgba(34,197,94,.12)}
    .decisionBtn.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .decisionBtn:disabled{opacity:.5;cursor:not-allowed}
    .decisionBtn.selected{box-shadow:0 0 0 2px rgba(255,255,255,.14), 0 12px 28px rgba(0,0,0,.25);transform:translateY(-1px)}
    .decisionPreview{padding:10px 12px;border-radius:14px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.16);display:flex;flex-direction:column;gap:6px}
    .decisionPlayers{display:flex;gap:8px;flex-wrap:wrap}
    .decisionPlayer{width:28px;height:28px;border-radius:10px;background:rgba(148,163,184,.18);display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:800;color:var(--muted)}
    .decisionPlayer.done{background:rgba(34,197,94,.22);color:#fff}
    .decisionTimer{width:44px;height:44px;border-radius:999px;border:2px solid rgba(96,165,250,.4);display:flex;align-items:center;justify-content:center;font-size:11px;color:#fff}

    .logDrawer{display:block}
    body.logHidden .logDrawer{display:none}
    body.logOpen .logDrawer{display:block}
    body.logOpen .logDrawer .sideSection{max-height:60vh}

    @media (max-width:1150px){
      .mainColumns{grid-template-columns:1fr}
      .mainGrid{grid-template-columns:1fr}
      .playLayout{grid-template-columns:1fr}
      .topBar{grid-template-columns:1fr;gap:8px}
      .topCenter{text-align:left}
      .playersList{max-height:240px}
      .rightPanel{order:3}
      .playersCard{order:2}
      .stageCard{order:1}
      .stageGrid{grid-template-columns:1fr}
      .decisionMain{grid-template-columns:1fr}
      .logDrawer{display:none}
      .playDrawer{
        position:fixed;
        left:12px;
        right:12px;
        bottom:12px;
        background:rgba(11,15,23,.6);
        border:1px solid rgba(148,163,184,.18);
        border-radius:16px;
        padding:8px 10px;
        z-index:150;
        justify-content:space-between;
      }
      body.logOpen .logDrawer{
        display:block;
        position:fixed;
        inset:auto 12px 12px 12px;
        z-index:130;
        border-radius:18px;
        box-shadow:0 20px 60px rgba(0,0,0,.6);
      }
    }
    @media (max-height:900px){
      body{overflow:auto}
      .wrap{height:auto}
    }
  </style>
</head>
<body class="ui-play">
  <div class="wrap">
    <div class="topBar">
      <div class="topLeft">
        <div class="ver" id="verBtn" title="Patch Notes anzeigen">
          <span>üéõÔ∏è</span><b id="verText">v0.0</b><span class="mini">(klicken)</span>
        </div>
        <div class="gameTitle devOnly">
          <b>Festival Overload</b>
          <span>Scorett UI ¬∑ Prototyp</span>
        </div>
        <div class="playTitle playOnly">
          <b>Festival Overload</b> ¬∑ <span id="playVersion">v0.0</span>
        </div>
      </div>
      <div class="topCenter">
        <div class="roundEvent devOnly">
          Runde <span class="roundBadge" id="roundBadge"><span id="roundNo">1</span></span>
          ¬∑ Event <span class="roundBadge" id="eventBadge"><span id="eventNo">0</span></span>
        </div>
        <div class="statusHeadline playOnly" id="statusHeadline">Event aufdecken</div>
        <small class="mini devOnly">Ein Blick: Overload ¬∑ Pool ¬∑ Karte ¬∑ Aktivit√§t</small>
      </div>
      <div class="topRight">
        <div class="goalChip">Ziel: 8 Camp</div>
        <div class="modeToggle" role="group" aria-label="Modus wechseln">
          <button class="btn slim" id="btnModePlay">Spielmodus</button>
          <button class="btn slim" id="btnModeDev">Dev</button>
        </div>
        <div class="statusIcons devOnly">
          <span class="statusChip warn" id="countdownStatus">üî• Countdown aktiv</span>
          <span class="statusChip blue" id="stageRuleChip">üåÄ B√ºhnenregel</span>
          <span class="statusChip bad" id="encoreChip">üé§ Encore-Kette</span>
        </div>
      </div>
    </div>

    <div class="playLayout">
      <section class="playStage">
        <div class="playOverloadTrack" id="playOverloadTrack" aria-label="Overload-Track">
          <div class="overloadTrackHeader">
            <div><b>Overload</b> <span class="mini">0‚Äì12</span></div>
            <div class="overloadHint"><span class="chip">‚è±Ô∏è Countdown +1</span> <span class="mini" id="playCountdownHint">inaktiv</span></div>
          </div>
          <div class="overloadPills" id="overloadPillsPlay"></div>
        </div>

        <div class="eventCard playCard" id="playEventCard" data-type="twist">
          <div class="stripe"></div>
          <div class="kTop">
            <div class="kName" id="playEventName">Bereit</div>
            <div class="kType" id="playEventType"><span class="dot" style="background:rgba(148,163,184,.6)"></span> ‚è∫Ô∏è Event</div>
          </div>
          <div class="kText" id="playEventText">Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten.</div>
        </div>

        <div class="playChips" id="playEventChips">‚Äî</div>

        <div class="playPoolRow">
          <div class="playPoolChip">Pool: <span id="poolValuePlay">0</span></div>
          <div class="playCountdownBadge" id="playCountdownBadge">Countdown +1</div>
        </div>

        <button class="btn good primary playPrimary" id="btnRevealPlay">Event aufdecken</button>
        <div class="playBanner" id="playBanner"></div>
      </section>

      <section class="playPlayers">
        <div class="playPlayersHeader">
          <span>Spielerleisten</span>
          <span class="mini">Status & Werte</span>
        </div>
        <div class="playPlayersList" id="playersPlay"></div>
      </section>
    </div>

    <div class="playDrawer playOnly">
      <button class="btn slim" id="btnPlayLog">Log</button>
      <button class="btn slim" id="btnPlayRules" aria-label="Kurzregeln">?</button>
    </div>

    <div class="playLogDrawer" id="playLogDrawer" aria-hidden="true">
      <div class="playLogHead">
        <b>Log</b>
        <button class="btn slim" id="btnPlayLogClose">Schlie√üen</button>
      </div>
      <div class="playLog" id="logPlay"></div>
    </div>

    <div class="mainGrid devLayout">
      <section class="card stageCard">
        <div class="stageTop">
          <div class="stageMeta">
            <div class="stageChip" id="overloadChip"><b>Overload</b> <span id="overloadValue">0</span> / 12</div>
            <div class="stageChip blue" id="poolChip"><b>Pool</b> <span id="poolValue">0</span></div>
            <div class="stageChip" id="deckChip"><b>Deck</b> <span id="deckCount">0</span></div>
            <div class="stageChip" id="discardChip"><b>Ablage</b> <span id="discardCount">0</span></div>
          </div>
          <div class="stageMeta">
            <div class="stageChip" id="stateChip"><b>Status</b>: Normal</div>
            <div class="stageChip warn" id="countdownChip"><b>Countdown</b>: <span id="countdown">aus</span></div>
            <div class="stageChip blue"><b>Phase</b>: <span id="phase">Aufdecken</span></div>
          </div>
        </div>

        <div class="overloadTrack" aria-label="Overload-Track">
          <div class="overloadTrackHeader">
            <div><b>Overload-Track</b> <span class="mini">0‚Äì12</span></div>
            <div class="overloadHint"><span class="chip">‚è±Ô∏è Countdown +1</span> <span class="mini" id="countdownHint">inaktiv</span></div>
          </div>
          <div class="overloadPills" id="overloadPills"></div>
        </div>

        <div class="steps" id="steps" aria-label="Phasen">
          <div class="step" data-step="reveal" title="Der aktive Spieler deckt genau 1 Event auf"><span class="n">1</span>Aufdecken</div>
          <div class="step" data-step="event" title="Event-Effekt wird ausgef√ºhrt (inkl. Encore-Ketten, Twist, Overload-Check)"><span class="n">2</span>Effekt</div>
          <div class="step" data-step="countdown" title="Wenn Countdown aktiv ist: nach dem Event Overload +1 (optional +2 bei Pool ‚â•3, falls aktiviert)"><span class="n">3</span>Countdown</div>
          <div class="step" data-step="decision" title="Alle aktiven Spieler entscheiden gleichzeitig Bleib/Camp"><span class="n">4</span>Entscheidung</div>
        </div>

        <div class="stageGrid">
          <div>
            <div class="row" style="justify-content:space-between">
              <div>
                <b>Aktuelle Karte</b>
                <span class="mini">(aufgedeckt von: <b id="revealerName">‚Äî</b> ¬∑ Richtung: <b id="dir">‚Üª</b>)</span>
              </div>
              <div class="mini">B√ºhnenregel: <b id="stageRule">‚Äî</b></div>
            </div>

            <div class="eventCard currentCard" id="eventCard" data-type="twist">
              <div class="stripe"></div>
              <div class="kTop">
                <div class="kName" id="eventName">Bereit</div>
                <div class="kType" id="eventType"><span class="dot" style="background:rgba(148,163,184,.6)"></span> ‚è∫Ô∏è Event</div>
              </div>
              <div class="impact" id="eventImpact">‚Äî</div>
              <div class="kText" id="eventText">Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten.</div>
            </div>

            <div class="eventSummary" id="eventSummary">‚Äî</div>

            <div class="actionRow">
              <div class="mini">Simultane Entscheidung erscheint als Overlay nach Eventende.</div>
              <div class="controls">
                <button class="btn good primary" id="btnReveal">Aufdecken</button>
                <button class="btn blue" id="btnLog">Log</button>
              </div>
            </div>

            <details class="fold">
              <summary>Regelhilfe & Pool-Bonus</summary>
              <div class="hint">
                <b>Camp (nur mit Live):</b> Ohne mindestens <b>1 Live</b> gibt es keinen Cashout.
                <br>
                <b>Pool-Bonus:</b> Beim Campen (mit Live) nimmst du sofort <b>poolTake = min(Pool, 1 + Gefahr)</b>, wobei Gefahr bei Overload <b>8+</b> aktiv ist.
                <br>
                <b>Wichtig:</b> Ma√ügeblich ist der <b>Overload nach dem Event</b> (inkl. Countdown/Checks), direkt vor der Camp-Entscheidung.
                <br>
                <b>Verteilung (gleichzeitig campen):</b> Feste Reihenfolge: beginnend beim Aufdecker, dann in aktueller Richtung. Jeder Camper nimmt seinen Pool-Bonus sofort.
              </div>
            </details>
          </div>

          <div class="poolPanel">
            <div class="poolChip">Pool: <span id="poolValueSide">0</span></div>
            <div class="poolStack">
              <div class="poolCards">
                <div class="poolCard"></div>
                <div class="poolCard"></div>
                <div class="poolCard"></div>
              </div>
              <div class="mini" id="poolHint">Camp-Bonus: min(Pool, 1 + Gefahr)</div>
            </div>

            <div class="tableau">
              <div class="stack">
                <div class="stackTitle"><b>Deck</b><span id="deckCountMini">0 Karten</span></div>
                <div class="cardStack" id="deckStack">
                  <div class="cardBack layer3"></div>
                  <div class="cardBack layer2"></div>
                  <div class="cardBack"></div>
                </div>
              </div>
              <div class="stack">
                <div class="stackTitle"><b>Aufgedeckt</b><span id="revealMeta">‚Äî</span></div>
                <div class="cardFace" id="revealCard" data-type="empty">
                  <div class="rTop">
                    <span class="rName" id="revealName">Noch keine Karte</span>
                    <span class="rType" id="revealType">‚Äî</span>
                  </div>
                  <div class="rText" id="revealText">Klicke auf ‚ÄûAufdecken‚Äú, um den ersten Draw zu sehen.</div>
                </div>
              </div>
              <div class="stack">
                <div class="stackTitle"><b>Ablage</b><span id="discardCountMini">0 Karten</span></div>
                <div class="cardStack" id="discardStack">
                  <div class="cardBack discard layer3"></div>
                  <div class="cardBack discard layer2"></div>
                  <div class="cardBack discard"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="banner" id="banner"></div>
      </section>

      <section class="card playersCard">
        <div class="playersHeader">
          <b>Spielerleisten</b>
          <span class="mini">Reihenfolge & Status</span>
        </div>
        <div class="playersList" id="players"></div>
      </section>

      <section class="card rightPanel">
        <div class="sideSection">
          <div class="sideTitle">Regelerinnerung</div>
          <ul class="ruleList mini">
            <li><b>Nach jedem Event</b>: Bleib oder Camp.</li>
            <li><b>Camp</b>: nur mit mindestens 1 Live.</li>
            <li><b>Bei 12</b>: Katastrophen-Check.</li>
          </ul>
        </div>
        <div class="sideSection logDrawer">
          <div class="logHead">
            <b>Log</b>
            <div class="logActions">
              <button class="btn slim" id="btnCopyLog">Log kopieren</button>
            </div>
          </div>
          <div class="log" id="log"></div>
        </div>
        <div class="sideSection">
          <div class="sideTitle">Einstellungen</div>
          <div class="toggle">
            <label class="mini"><input id="optPflaster" type="checkbox" checked> Pflaster nach Knall: Aktiver Spieler rettet 1 Live als Camp</label>
            <label class="mini"><input id="optAggCountdown" type="checkbox"> Countdown aggressiv: +1 extra wenn Pool ‚â•3</label>
            <label class="mini">Steuerung:
              <select id="optControlMode">
                <option value="bots-auto" selected>Nur Bots automatisch</option>
                <option value="bots-manual">Alle Bots manuell</option>
                <option value="all-auto">Alles automatisch (inkl. Du)</option>
              </select>
            </label>
            <label class="mini">Bot-Profil:
              <select id="optBotProfile"></select>
            </label>
            <div class="botControls mini">
              <span id="botCountLabel">Bots: 3</span>
              <button class="btn slim" id="btnAddBot">Bot hinzuf√ºgen</button>
              <button class="btn slim" id="btnRemoveBot">Bot entfernen</button>
              <span class="tag">nur vor Spielstart</span>
            </div>
            <label class="mini"><input id="optDecisionTimer" type="checkbox" checked> Timer aktiv (20s, Auto-Bleib)</label>
            <label class="mini">Tempo:
              <select id="optSpeed">
                <option value="250">schnell</option>
                <option value="650" selected>normal</option>
                <option value="1100">langsam</option>
              </select>
            </label>
            <button class="btn blue" id="btnPlayPreview">Spielmodus Vorschau</button>
            <button class="btn bad" id="btnRestart">Neustart</button>
          </div>
        </div>
        <div class="sideSection">
          <div class="sideTitle">Test-Deck (60 Karten)</div>
          <div class="mini">‚ö° Push 26 ¬∑ üõ†Ô∏è Stabilisieren 14 ¬∑ üåÄ Twist 14 ¬∑ üé§ Encore 6</div>
        </div>
        <div class="sideSection mini">
          <b>Dev:</b> Browser-Konsole: <code>FestivalOverloadTests</code>
        </div>
      </section>
    </div>
  </div>

  <div class="decisionOverlay" id="decisionOverlay" aria-hidden="true">
    <div class="decisionModal" role="dialog" aria-modal="true" aria-label="Entscheidung">
      <div class="decisionHeader">
        <div>
          <div class="decisionTitle">Entscheidung!</div>
          <div class="decisionStats">
            <div class="decisionStat">Overload: <b id="decisionOverload">0</b></div>
            <div class="decisionStat">Pool: <b id="decisionPool">0</b></div>
            <div class="decisionStat">Live: <b id="decisionLive">0</b></div>
          </div>
        </div>
        <div class="decisionTimer" id="decisionTimer">20s</div>
      </div>

      <div>
        <div class="mini">Wer hat schon gew√§hlt?</div>
        <div class="decisionAvatars" id="decisionPlayers"></div>
      </div>

      <div class="decisionMain">
        <button class="decisionBtn good" id="btnStay">
          <strong>BLEIB</strong>
          <small>Live bleibt riskant</small>
        </button>
        <button class="decisionBtn warn" id="btnCamp">
          <strong>CAMP</strong>
          <small id="campHint">Du sicherst dein Live</small>
        </button>
      </div>
      <div class="decisionBots hidden" id="decisionBots"></div>

      <div class="decisionPreview" id="decisionPreview">
        <div class="mini" id="decisionHint">W√§hle Bleib oder Camp. Danach wird simultan aufgel√∂st.</div>
        <div class="mini" id="decisionGain">‚Äî</div>
        <div class="mini" id="decisionTotal">‚Äî</div>
      </div>

      <div class="controls" style="justify-content:flex-end">
        <button class="btn blue" id="btnResolve">Entscheidung ausf√ºhren</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Patch Notes Modal -->
  <div class="modalBack" id="pnBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Patch Notes">
      <div class="modalTop">
        <b>Patch Notes</b>
        <button class="btn slim" id="pnClose">Schlie√üen</button>
      </div>
      <div class="modalBody" id="pnBody"></div>
    </div>
  </div>

  <!-- Generic Ask Modal -->
  <div class="modalBack" id="askBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Aktion">
      <div class="modalTop">
        <b id="askTitle">Aktion</b>
        <button class="btn slim" id="askX">Schlie√üen</button>
      </div>
      <div class="modalBody">
        <div class="confirmText" id="askText"></div>
        <div class="pickList" id="askPick" style="display:none"></div>
        <div class="confirmBtns" id="askBtns">
          <button class="btn" id="askNo">Abbrechen</button>
          <button class="btn good" id="askYes">OK</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Kurzregeln Modal (Spielmodus) -->
  <div class="modalBack" id="rulesBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Kurzregeln">
      <div class="modalTop">
        <b>Kurzregeln</b>
        <button class="btn slim" id="rulesClose">Schlie√üen</button>
      </div>
      <div class="modalBody">
        <ul class="ruleList mini">
          <li><b>Nach jedem Event</b>: Alle aktiven Spieler entscheiden simultan Bleib oder Camp.</li>
          <li><b>Camp</b> ist nur mit mindestens 1 Live m√∂glich.</li>
          <li><b>Pool-Bonus</b>: poolTake = min(Pool, 1 + Gefahr), Gefahr aktiv bei Overload 8+.</li>
          <li><b>Overload 12</b>: Katastrophen-Check ‚Äì Push bedeutet Knall.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    var VERSION = 'v0.32';
    var OVERLOAD_RESET_AFTER_CHECK = 10;
    var STAGE_DIVE_REPLACEMENT = 'overload';
    var STABILIZE_CARDS = [
      { name:'Atem holen', value:2, count:8 },
      { name:'Security greift ein', value:3, count:6 }
    ];

    // Bot-Limits f√ºr die UI-Anpassung
    var MIN_BOTS = 1;
    var MAX_BOTS = 6;

    // Patch notes: newest first
    var PATCH_NOTES = [
      {
        ver: 'v0.32',
        date: '2026-01-15',
        items: [
          'Fix: RoundReset r√§umt Entscheidung-Flags/Queues und blockt Entscheidungs-Phase nach Knall/Rundenende.',
          'Fix: KNALL-Pflaster eindeutig umgesetzt und pro Spieler vollst√§ndig geloggt.',
          'Fix: Stage Dive setzt ‚ÄûMuss bleiben‚Äú nur einmal, loggt Zwang im Entscheidungs-Log und nutzt Ersatz-Effekt.',
          'Fix: Rundenende loggt Pool-Verfall explizit; Richtungswechsel/Setwechsel zeigen den n√§chsten Aufdecker.',
          'Fix: Logs nutzen konsistente Werte-Reihenfolge (Overload, Pool, Live, Camp) und Selftest pr√ºft RoundReset.'
        ]
      },
      {
        ver: 'v0.31',
        date: '2026-01-11',
        items: [
          'Fix: Log-Ausgaben enthalten konsistent Overload/Live/Camp/Pool-√Ñnderungen.',
          'Fix: Stabilisieren/Push/Countdown-Logs zeigen Vorzeichen, Cap/Min-0 und Basis/Modifier exakt.',
          'Fix: Katastrophen-Check/Anti-Solo/Stage-Dive-Logs folgen einheitlichem Format.'
        ]
      },
      {
        ver: 'v0.30',
        date: '2026-01-10',
        items: [
          'Fix: Pool-Bonus wird deterministisch pro Camper verteilt (Reihenfolge ab Aufdecker, aktuelle Richtung).',
          'Fix: Camp-Logs zeigen Live‚ÜíCamp und Pool‚ÜíCamp pro Spieler inkl. Camp/Pool-Delta.',
          'Fix: Stabilisieren- und Push-Logs nutzen feste Kartenwerte, zeigen Vorzeichen korrekt und beachten min 0/Cap 12.',
          'Fix: Katastrophen-Check loggt Check-Karte klar und setzt Overload bei Safe auf 10.',
          'Fix: Anti-Solo camped den letzten Spieler inkl. Pool-Bonus und Trostpunkt bei 0 Live.',
          'Fix: Stage Dive stapelt kein ‚ÄûMuss bleiben‚Äú mehr; Ersatz-Effekt greift stattdessen.'
        ]
      },
      {
        ver: 'v0.29',
        date: '2026-01-14',
        items: [
          'Fix: Zentrale UI-Labels werden nur aktualisiert, wenn die Elemente vorhanden sind.'
        ]
      },
      {
        ver: 'v0.28',
        date: '2026-01-13',
        items: [
          'Fix: Status-Chips werden nur aktualisiert, wenn die UI-Elemente existieren.'
        ]
      },
      {
        ver: 'v0.27',
        date: '2026-01-12',
        items: [
          'Fix: Event-Handler in den Einstellungen werden nur gebunden, wenn die Elemente existieren.'
        ]
      },
      {
        ver: 'v0.26',
        date: '2026-01-11',
        items: [
          'Fix: Aufdecker-Index wird auch vor der Entscheidungsreihenfolge und im Bot-Autopump normalisiert.'
        ]
      },
      {
        ver: 'v0.25',
        date: '2026-01-10',
        items: [
          'Fix: Fehlende Spieler werden in EndRound/Entscheidung sicher per Neustart abgefangen.',
          'Fix: Bot-Autopump ignoriert leere Spielerlisten.'
        ]
      },
      {
        ver: 'v0.24',
        date: '2026-01-09',
        items: [
          'Fix: Revealer-Index wird normalisiert, um inkonsistente Zust√§nde beim Spielstart abzufangen.',
          'Fix: Fehlende Spielerliste f√ºhrt zu einem sicheren Neustart statt zu Folgefehlern.'
        ]
      },
      {
        ver: 'v0.23',
        date: '2026-01-08',
        items: [
          'Fix: Selbsttests laufen nur noch bei ?selftest=1, um Logs/UI im normalen Spielstart nicht zu beeinflussen.'
        ]
      },
      {
        ver: 'v0.22',
        date: '2026-01-07',
        items: [
          'Fix: Bot-Anzahl wird auf eine ganze Zahl gerundet, um inkonsistente Zust√§nde zu vermeiden.'
        ]
      },
      {
        ver: 'v0.21',
        date: '2026-01-06',
        items: [
          'Fix: Stage-Dive-Ziel kann nicht mehr der Aufdecker selbst sein.',
          'Fix: Bot-Anzahl-Input wird robuster gegen ung√ºltige Werte gepr√ºft.'
        ]
      },
      {
        ver: 'v0.20',
        date: '2026-01-05',
        items: [
          'Fix: Overload-Delta in Log/Overlay nutzt jetzt den tats√§chlich angewendeten (gecappten) Wert.',
          'Fix: Countdown/Push/Stabilisieren/Pyro zeigen konsistente Overload-√Ñnderungen an.'
        ]
      },
      {
        ver: 'v0.19',
        date: '2026-01-04',
        items: [
          'Neu: Bot-Anzahl vor Spielstart anpassbar (Bot hinzuf√ºgen/entfernen).',
          'UI: Bot-Z√§hler in den Einstellungen erg√§nzt, inkl. Sperre nach Spielstart.'
        ]
      },
      {
        ver: 'v0.18',
        date: '2026-01-03',
        items: [
          'Neu: Steuerungsmodi f√ºr Bots (Bots automatisch, Bots manuell, alles automatisch inkl. Du).',
          'Neu: Modulares Bot-Profil-System, vorbereitet f√ºr weitere Bot-Strategien.',
          'UI: Bot-Entscheidungen im Overlay w√§hlbar, wenn Bots manuell gesteuert werden.'
        ]
      },
      {
        ver: 'v0.17',
        date: '2026-01-02',
        items: [
          'UI: Spielmodus mit minimaler B√ºhne, gro√üem Statussatz, Overload-Track und Kartenfokus erg√§nzt.',
          'UI: Dev-Modus bleibt vollst√§ndig, inkl. Schnellwechsel √ºber Modus-Toggle und Vorschau-Button.',
          'UI: Bleib/Camp-Overlay mit klaren Vorschauzeilen und optionalem 20s-Timer erweitert.',
          'UX: Log/Regeln im Spielmodus als Drawer/Modal, Overload-Pulse und Ergebnisbanner f√ºr Knall/Checks.'
        ]
      },
      {
        ver: 'v0.16',
        date: '2025-12-30',
        items: [
          'UI: Neues ‚ÄûScorett‚Äú-Layout mit Top-Bar, 3-Spalten-B√ºhne und klaren Chips f√ºr Overload/Pool/Deck/Ablage.',
          'UI: Overload-Track als 0‚Äì12 Pills plus Status-Chips f√ºr Countdown, B√ºhnenregel und Encore.',
          'UI: Spielerleisten als gro√üe Cards mit Live/Camp-Chips, Status-Badges und Wahlmarkern.',
          'UI: Simultane Entscheidung als Vollbild-Overlay mit Vorschau und Spielerstatus.',
          'UX: Log als Drawer (per Button), Einstellungen in die rechte Spalte verschoben.'
        ]
      },
      {
        ver: 'v0.15',
        date: '2025-12-29',
        items: [
          'UI: Lesbarkeit erh√∂ht (st√§rkerer Kontrast, gr√∂√üere Schrift f√ºr Hinweise/Log).',
          'UI: Aktiver Phasen-Schritt deutlicher hervorgehoben und prim√§rer Aktionsbutton st√§rker gewichtet.',
          'UI: Mini-Regel√ºbersicht in strukturierte Abschnitte mit Listen aufgeteilt.'
        ]
      },
      {
        ver: 'v0.14',
        date: '2025-12-28',
        items: [
          'UI: Aktionsleiste b√ºndelt Event- und Entscheidungs-Buttons f√ºr eine kompakte Bedienung ohne Scrollen.',
          'UI: Layout gestrafft, Log/Regeln sind innerhalb der Karten scrollbar, damit die Spielfl√§che im Viewport bleibt.',
          'UI: Regelhilfe zur Camp-Phase als einklappbarer Bereich im Event-Bereich.'
        ]
      },
      {
        ver: 'v0.13',
        date: '2025-12-27',
        items: [
          'Neu: Kartenoptik f√ºr Deck, Ablage und zuletzt aufgedeckte Karte, damit man den Spielfluss besser sieht.',
          'UI: Zus√§tzliche Kartenfl√§che mit Live-Infos zur zuletzt aufgedeckten Karte.'
        ]
      },
      {
        ver: 'v0.12',
        date: '2025-12-26',
        items: [
          'Fix: JavaScript Syntaxfehler entfernt (Sieg-Log/Flash, Toast beim Knall, Klammerung bei Stabilisieren).',
          'Neu: Zus√§tzliche Self-Tests f√ºr Stabilisieren-Ertrag und Anti-Solo-Pool-Verwurf.'
        ]
      },
      {
        ver: 'v0.11',
        date: '2025-12-26',
        items: [
          'Patch P2: Stabilisieren-Ertrag nur noch im roten Bereich (Overload vor dem Senken 8+ ‚Üí +1 Live, sonst kein Ertrag).',
          'Patch P2: Pool-Bonus eindeutig ‚Äì ma√ügeblich ist der Overload nach dem Event (inkl. Countdown/Checks) direkt vor der Entscheidung.',
          'Patch P2: Anti-Solo-Downtime ‚Äì letzter aktiver Spieler bekommt keinen Pool-Bonus, Rest-Pool wird verworfen.',
          'Optional: Checkbox f√ºr aggressiven Countdown (+1 extra wenn Pool ‚â•3).'
        ]
      },
      {
        ver: 'v0.10',
        date: '2025-12-26',
        items: [
          'Patch 0.7-PL-P1: Camp nur mit mindestens 1 Live (kein ‚ÄûCamp bei 0‚Äú).',
          'Patch 0.7-PL-P1: Pool-Verteilung in Durchl√§ufen (erst jeder 1, dann bei Overload 8+ ggf. jeder 1).',
          'Patch 0.7-PL-P1: Countdown startet erst beim ersten erfolgreichen Camp (mit Live).',
          'Patch 0.7-PL-P1: Stabilisieren buff ‚Äì Aufdecker erh√§lt immer 1 Live (Pool ‚Üí sonst Vorrat).',
          'Patch 0.7-PL-P1: Anti-Solo-Downtime ‚Äì sobald nur noch 1 Spieler aktiv ist, endet die Runde sofort.'
        ]
      },
      {
        ver: 'v0.9',
        date: '2025-12-26',
        items: [
          'Neu: Autoplay (Zuschauermodus) ‚Äì Bots spielen automatisch weiter (Aufdecken + Entscheidungen), inkl. Auto-Entscheidungen f√ºr ‚ÄûDu‚Äú.',
          'Neu: Tempo-Auswahl f√ºr Autoplay.'
        ]
      },
      {
        ver: 'v0.8',
        date: '2025-12-26',
        items: [
          'Neu: Integrierte Push-your-Luck-Version ohne Handkarten: Event aufdecken ‚Üí simultan Bleib/Camp.',
          'Neu: B√ºhnen-Pool (Mitte) + Pool-Bonus beim Campen (1 oder 2 je nach Overload).',
          'Neu: Encore als Ketten-Event (Aufdecker kann 1 Live zahlen, um zu stoppen).',
          'Neu: Overload-Check bei 12 mit Katastrophen-Check (Push = Knall, sonst R√ºcksto√ü auf 10).',
          'Neu: Countdown nach erstem Camper (+1 Overload nach jedem weiteren Event).'
        ]
      }
    ];

    var WIN_CAMP = 8;
    var MAX_OVERLOAD = 12;

    var BOT_MODULES = [
      {
        id: 'standard',
        name: 'Standard',
        decideCamp: function(ctx){
          var p = ctx.player;
          if (p.roundState !== 'active') return 'stay';
          if (p.forcedStay) return 'stay';
          if (p.live <= 0) return 'stay';
          if (p.camp + p.live >= WIN_CAMP) return 'camp';
          if (ctx.overload >= 10 && p.live >= 2) return 'camp';
          if (p.live >= 3) return 'camp';
          if (p.live >= 1 && ctx.pool >= 2 && ctx.overload >= 8) return (Math.random() < 0.65) ? 'camp' : 'stay';
          return (Math.random() < 0.20) ? 'camp' : 'stay';
        },
        stopEncore: function(ctx){
          var p = ctx.player;
          if (p.live <= 0) return false;
          if (ctx.overload >= 10) return true;
          if (p.live >= 2 && Math.random() < 0.7) return true;
          return (Math.random() < 0.25);
        },
        stageDivePay: function(ctx){
          var p = ctx.player;
          if (p.live <= 0) return false;
          if (ctx.overload >= 8) return true;
          if (p.camp + p.live >= WIN_CAMP - 1) return true;
          return (Math.random() < 0.45);
        },
        pickStageDiveTarget: function(ctx){
          var best = -1;
          var bestLive = -1;
          for (var i=0;i<ctx.players.length;i++){
            if (i === ctx.revealer) continue;
            var candidate = ctx.players[i];
            if (candidate.roundState !== 'active') continue;
            if (candidate.live > bestLive){ bestLive = candidate.live; best = i; }
          }
          if (best === -1) best = ctx.revealer;
          return best;
        }
      }
    ];

    var state = {
      round: 1,
      overload: 0,
      pool: 0,
      uiMode: 'play',
      activeEffects: [],
      uiHeadline: null,
      uiHeadlineTimer: null,
      playBannerTimer: null,
      stageRule: null, // { name, text, fx, _cardRef }
      countdownActive: false,
      direction: 1, // 1 clockwise, -1 counter
      startPlayer: 0,
      revealer: 0,
      extraRevealSame: false,

      deck: [],
      discard: [],

      players: [],
      humanIndex: 0,
      botProfileId: 'standard',
      botCount: 3,

      awaitingDecision: false,
      humanChoice: 'stay', // 'stay' | 'camp'
      botChoices: {},
      lastEvent: null,
      gameOver: false,

      turnId: 0,
      askOpen: false,
      encoreChain: 0,
      humanLockedIn: false,

      autoTimer: null,
      decisionTimer: { enabled:true, seconds:20, remaining:20, timerId:null },

      phase: 'reveal',
      banner: null,
      lastSummary: null,
      roundResetId: 0
    };

    // ---------- helpers ----------
    function esc(s){
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;');
    }

    function cardCountLabel(n){
      return n + (n === 1 ? ' Karte' : ' Karten');
    }

    function formatDelta(delta){
      return (delta >= 0 ? '+' : '') + delta;
    }

    function normalizeRevealerIndex(){
      var n = state.players.length;
      if (!n) return -1;
      var idx = Number(state.revealer);
      if (!isFinite(idx)) idx = 0;
      idx = Math.floor(idx);
      if (idx < 0 || idx >= n) idx = 0;
      return idx;
    }

    function clampBotCount(count){
      var safeCount = Number(count);
      if (!isFinite(safeCount)) safeCount = MIN_BOTS;
      // Bot-Anzahl muss ganzzahlig bleiben, sonst entstehen inkonsistente Zust√§nde.
      safeCount = Math.round(safeCount);
      if (safeCount < MIN_BOTS) return MIN_BOTS;
      if (safeCount > MAX_BOTS) return MAX_BOTS;
      return safeCount;
    }

    function botNameForIndex(idx){
      var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      if (idx < letters.length) return 'Bot ' + letters.charAt(idx);
      return 'Bot ' + (idx + 1);
    }

    function buildPlayers(botCount){
      // Spieler-Setup neu aufbauen (nur vor Spielstart anpassen).
      var list = [
        { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false }
      ];

      for (var i=0;i<botCount;i++){
        list.push({
          name: botNameForIndex(i),
          camp: 0,
          live: 0,
          roundState: 'active',
          forcedStay: false,
          botId: state.botProfileId
        });
      }
      return list;
    }

    function canAdjustBots(){
      return state.turnId === 0 && !state.awaitingDecision && !state.gameOver;
    }

    function toast(msg, sub){
      sub = sub || '';
      var el = document.getElementById('toast');
      el.innerHTML = '<div><b>' + esc(msg) + '</b></div>' + (sub ? '<small>' + esc(sub) + '</small>' : '');
      el.style.display = 'block';
      if (toast._t) clearTimeout(toast._t);
      toast._t = setTimeout(function(){ el.style.display = 'none'; }, 2200);
    }

    function log(kind, msgHtml){
      var el = document.getElementById('log');
      var play = document.getElementById('logPlay');
      var t = new Date();
      var hh = String(t.getHours()); if (hh.length < 2) hh = '0'+hh;
      var mm = String(t.getMinutes()); if (mm.length < 2) mm = '0'+mm;
      var cls = kind || 'info';
      var entry = '<div class="evt ' + cls + '"><span class="t">['+hh+':'+mm+']</span> <span class="t">(T'+state.turnId+')</span> ' + msgHtml + '</div>';
      el.innerHTML += entry;
      el.scrollTop = el.scrollHeight;
      if (play){
        play.innerHTML += entry;
        play.scrollTop = play.scrollHeight;
      }
    }

    function shuffle(a){
      var arr = a.slice();
      for (var i = arr.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
      }
      return arr;
    }

    function draw(n){
      if (typeof n === 'undefined') n = 1;
      var out = [];
      for (var i=0;i<n;i++){
        if (!state.deck.length){
          if (state.discard.length){
            state.deck = shuffle(state.discard);
            state.discard = [];
            log('warn','<b>Deck leer</b> ‚Äì Ablage wird gemischt.');
          } else {
            log('bad','<b>Deck & Ablage leer</b> ‚Äì keine Karte verf√ºgbar.');
            break;
          }
        }
        out.push(state.deck.pop());
      }
      return out;
    }

    function clampOverload(x){ return Math.max(0, Math.min(MAX_OVERLOAD, x)); }

    function controlMode(){
      var el = document.getElementById('optControlMode');
      return (el && el.value) ? el.value : 'bots-auto';
    }

    function isAutoAll(){
      return controlMode() === 'all-auto';
    }

    function areBotsAuto(){
      var mode = controlMode();
      return (mode === 'bots-auto' || mode === 'all-auto');
    }

    function areBotsManual(){
      return controlMode() === 'bots-manual';
    }

    function isAggCountdown(){
      var el = document.getElementById('optAggCountdown');
      return !!(el && el.checked);
    }

    function getAutoDelay(){
      var el = document.getElementById('optSpeed');
      var v = el ? Number(el.value) : 650;
      if (!isFinite(v) || v <= 0) v = 650;
      return Math.max(60, Math.min(3000, v));
    }

    function scheduleAuto(fn){
      if (state.autoTimer) { clearTimeout(state.autoTimer); state.autoTimer = null; }
      state.autoTimer = setTimeout(fn, getAutoDelay());
    }

    function stopAutoTimer(){
      if (state.autoTimer) { clearTimeout(state.autoTimer); state.autoTimer = null; }
    }

    function anyActive(){
      for (var i=0;i<state.players.length;i++) if (state.players[i].roundState === 'active') return true;
      return false;
    }

    function activeCount(){
      var c=0;
      for (var i=0;i<state.players.length;i++) if (state.players[i].roundState === 'active') c++;
      return c;
    }

    function getLastActiveIndex(){
      for (var i=0;i<state.players.length;i++) if (state.players[i].roundState === 'active') return i;
      return -1;
    }

    function nextActiveFrom(startIdx, step){
      var n = state.players.length;
      for (var k=1;k<=n;k++){
        var idx = (startIdx + k*step + n*1000) % n;
        if (state.players[idx].roundState === 'active') return idx;
      }
      return -1;
    }

    function orderFrom(startIdx, step){
      var n = state.players.length;
      var out = [];
      for (var k=0;k<n;k++) out.push((startIdx + k * step + n * 1000) % n);
      return out;
    }

    function poolTakeFor(overload, pool){
      var dangerBonus = (overload >= 8) ? 1 : 0;
      return Math.min(pool, 1 + dangerBonus);
    }

    function describeOverloadCap(before, add, after){
      return (before + add > MAX_OVERLOAD && after === MAX_OVERLOAD) ? ' (cap)' : '';
    }

    function describeOverloadFloor(before, sub, after){
      return (before - sub < 0 && after === 0) ? ' (min 0)' : '';
    }

    function labelType(t){
      if (t === 'push') return { txt:'Push', dot:'var(--bad)', icon:'‚ö°' };
      if (t === 'stabilize') return { txt:'Stabilisieren', dot:'var(--good)', icon:'üõ†Ô∏è' };
      if (t === 'twist') return { txt:'Twist', dot:'var(--warn)', icon:'üåÄ' };
      if (t === 'encore') return { txt:'Encore', dot:'var(--blue)', icon:'üé§' };
      return { txt:t, dot:'rgba(148,163,184,.6)', icon:'‚ùî' };
    }

    function getBotModule(botId){
      for (var i=0;i<BOT_MODULES.length;i++){
        if (BOT_MODULES[i].id === botId) return BOT_MODULES[i];
      }
      return BOT_MODULES[0];
    }

    function botCtx(idx){
      return {
        player: state.players[idx],
        players: state.players,
        overload: state.overload,
        pool: state.pool,
        revealer: state.revealer
      };
    }

    function botProfilePick(){
      var el = document.getElementById('optBotProfile');
      return (el && el.value) ? el.value : state.botProfileId;
    }

    function screenFlash(kind){
      try{
        document.body.classList.remove('flashBad','flashGood');
        void document.body.offsetWidth;
        if (kind === 'bad') document.body.classList.add('flashBad');
        else if (kind === 'good') document.body.classList.add('flashGood');
        setTimeout(function(){ document.body.classList.remove('flashBad','flashGood'); }, 650);
      } catch(e){}
    }

    function flashStat(id, kind, deltaText){
      var el = document.getElementById(id);
      if (!el) return;
      var cls = 'flash-' + (kind || 'warn');

      // delta badge
      var b = el.querySelector('.deltaBadge');
      if (!b){
        b = document.createElement('span');
        b.className = 'deltaBadge';
        el.appendChild(b);
      }
      b.textContent = deltaText || '';

      el.classList.remove('flash-good','flash-warn','flash-bad','flash-blue');
      void el.offsetWidth;
      el.classList.add(cls);

      setTimeout(function(){
        el.classList.remove('flash-good','flash-warn','flash-bad','flash-blue');
      }, 560);
    }

    function impactHTML(c){
      if (!c) return '‚Äî';
      var t = c.type;
      var parts = [];

      if (t === 'push'){
        var add = (c.delta || 1) + (hasFeedbackRule() ? 1 : 0);
        parts.push('<span class="imp bad">‚ö° <b>Overload +' + add + '</b></span>');
        parts.push('<span class="imp blue">üéüÔ∏è <b>Aufdecker +1 Live</b></span>');
        parts.push('<span class="imp warn">üéÅ <b>Pool +1</b></span>');
        if (hasFeedbackRule()) parts.push('<span class="imp warn">üåÄ‚àû <b>Feedback aktiv</b></span>');
        parts.push('<span class="imp blue">üë• <b>Danach: Entscheidung</b></span>');
      }
      else if (t === 'stabilize'){
        var d = (typeof c.delta === 'number' ? c.delta : -2);
        parts.push('<span class="imp good">üõ†Ô∏è <b>Overload ' + d + '</b></span>');
        parts.push('<span class="imp blue">üéüÔ∏è <b>+1 Live nur bei 8+ vorher</b></span>');
        parts.push('<span class="imp blue">üë• <b>Danach: Entscheidung</b></span>');
      }
      else if (t === 'twist'){
        if (c.stage){
          parts.push('<span class="imp warn">üåÄ‚àû <b>B√ºhnenregel</b></span>');
          parts.push('<span class="imp blue">‚è≥ <b>Gilt bis Rundenende</b></span>');
        } else {
          parts.push('<span class="imp warn">üåÄ <b>Sofort-Twist</b></span>');
        }
        if (c.fx === 'pyro') parts.push('<span class="imp bad">üî• <b>Overload +2</b></span>');
        if (c.fx === 'flipDir') parts.push('<span class="imp warn">üîÑ <b>Richtung dreht</b></span>');
        if (c.fx === 'setwechsel') parts.push('<span class="imp warn">üéõÔ∏è <b>Aufdecker noch einmal</b></span>');
        if (c.fx === 'stageDive') parts.push('<span class="imp bad">ü™Ç <b>Ziel: zahlen 1 Live oder muss bleiben</b></span>');
        parts.push('<span class="imp blue">üë• <b>Danach: Entscheidung</b></span>');
      }
      else if (t === 'encore'){
        parts.push('<span class="imp blue">üé§ <b>Encore-Kette</b></span>');
        parts.push('<span class="imp warn">‚úã <b>Stop: 1 Live (nur Aufdecker)</b></span>');
        parts.push('<span class="imp bad">‚õìÔ∏è <b>Kein Camp dazwischen</b></span>');
      }
      else {
        parts.push('<span class="imp">Event</span>');
      }

      return parts.join('');
    }

    function setEventCard(card, extraText){
      var c = card || { type:'twist', name:'Bereit', text:'Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten.' };
      var meta = labelType(c.type);

      var el = document.getElementById('eventCard');
      el.setAttribute('data-type', c.type);
      el.classList.remove('pop');
      void el.offsetWidth;
      el.classList.add('pop');

      document.getElementById('eventName').textContent = c.name;
      document.getElementById('eventType').innerHTML = '<span class="dot" style="background:'+meta.dot+'"></span> '+meta.icon+' '+meta.txt;

      var imp = document.getElementById('eventImpact');
      if (imp) imp.innerHTML = impactHTML(card) + (extraText ? '<span class="imp blue">‚õìÔ∏è <b>' + esc(extraText) + '</b></span>' : '');

      document.getElementById('eventText').innerHTML = esc(c.text) + (extraText ? '<br><span class="mini">'+esc(extraText)+'</span>' : '');

      var playCard = document.getElementById('playEventCard');
      if (playCard){
        playCard.setAttribute('data-type', c.type);
        playCard.classList.remove('pop');
        void playCard.offsetWidth;
        playCard.classList.add('pop');
      }
      var playName = document.getElementById('playEventName');
      if (playName) playName.textContent = c.name;
      var playType = document.getElementById('playEventType');
      if (playType) playType.innerHTML = '<span class="dot" style="background:'+meta.dot+'"></span> '+meta.icon+' '+meta.txt;
      var playText = document.getElementById('playEventText');
      if (playText) playText.textContent = c.text + (extraText ? ' ¬∑ ' + extraText : '');
      renderPlayChips(card);
    }

    function renderPlayChips(card){
      var wrap = document.getElementById('playEventChips');
      if (!wrap) return;
      if (!card){
        wrap.innerHTML = '<span class="playChip">Bereit</span>';
        return;
      }

      var chips = [];
      var t = card.type;
      var addFeedback = hasFeedbackRule() ? 1 : 0;

      if (t === 'push'){
        chips.push({ cls:'bad', text:'Overload +' + ((card.delta || 1) + addFeedback) });
        chips.push({ cls:'blue', text:(state.revealer === state.humanIndex ? '+1 Live (Du)' : 'Aufdecker +1 Live') });
        chips.push({ cls:'warn', text:'Pool +1' });
      } else if (t === 'stabilize'){
        chips.push({ cls:'good', text:'Overload ' + (card.delta || -2) });
        chips.push({ cls:'blue', text:'Live +1 nur bei 8+ vorher' });
      } else if (t === 'twist'){
        if (card.stage) chips.push({ cls:'warn', text:'B√ºhnenregel: ' + card.name });
        if (card.fx === 'pyro') chips.push({ cls:'bad', text:'Overload +2' });
        if (card.fx === 'flipDir') chips.push({ cls:'warn', text:'Richtung dreht' });
        if (card.fx === 'setwechsel') chips.push({ cls:'warn', text:'Aufdecker noch einmal' });
        if (card.fx === 'stageDive') chips.push({ cls:'bad', text:'Stage Dive' });
      } else if (t === 'encore'){
        chips.push({ cls:'blue', text:'Encore-Kette' });
        chips.push({ cls:'warn', text:'Kein Camp dazwischen' });
      }

      if (state.countdownActive) chips.push({ cls:'warn', text:'Countdown +1' });

      if (!chips.length) chips.push({ cls:'blue', text:'Event' });

      var html = '';
      for (var i=0;i<chips.length;i++){
        var c = chips[i];
        html += '<span class="playChip' + (c.cls ? ' ' + c.cls : '') + '">' + esc(c.text) + '</span>';
      }
      wrap.innerHTML = html;
    }

    function showPlayCheckCard(card){
      var playCard = document.getElementById('playEventCard');
      var playName = document.getElementById('playEventName');
      var playType = document.getElementById('playEventType');
      var playText = document.getElementById('playEventText');
      if (!playCard || !playName || !playType || !playText) return;

      var prev = {
        name: playName.textContent,
        type: playType.innerHTML,
        text: playText.textContent,
        dataType: playCard.getAttribute('data-type')
      };

      var meta = labelType(card.type);
      playCard.setAttribute('data-type', card.type);
      playName.textContent = 'Check: ' + card.name;
      playType.innerHTML = '<span class="dot" style="background:'+meta.dot+'"></span> '+meta.icon+' '+meta.txt;
      playText.textContent = card.text;
      renderPlayChips(card);

      setTimeout(function(){
        playCard.setAttribute('data-type', prev.dataType || 'twist');
        playName.textContent = prev.name;
        playType.innerHTML = prev.type;
        playText.textContent = prev.text;
        renderPlayChips(state.lastEvent);
      }, 700);
    }

    function updateRevealCard(){
      var card = state.lastEvent;
      var reveal = document.getElementById('revealCard');
      if (!reveal) return;

      if (!card){
        reveal.setAttribute('data-type', 'empty');
        document.getElementById('revealName').textContent = 'Noch keine Karte';
        document.getElementById('revealType').textContent = '‚Äî';
        document.getElementById('revealText').textContent = 'Klicke auf ‚ÄûEvent aufdecken‚Äú, um den ersten Draw zu sehen.';
        document.getElementById('revealMeta').textContent = '‚Äî';
        return;
      }

      var meta = labelType(card.type);
      reveal.setAttribute('data-type', card.type);
      document.getElementById('revealName').textContent = card.name;
      document.getElementById('revealType').textContent = meta.icon + ' ' + meta.txt;
      document.getElementById('revealText').textContent = card.text;
      document.getElementById('revealMeta').textContent = 'Aufgedeckt in T' + state.turnId;
    }

    // ---------- UX helpers (Phase / Banner / Summary) ----------
    function phaseLabel(){
      if (state.gameOver) return 'Spielende';
      if (state.askOpen) return 'Auswahl';
      if (state.awaitingDecision) return 'Entscheidung';
      if (state.phase === 'event') return 'Effekt';
      if (state.phase === 'countdown') return 'Countdown';
      return 'Aufdecken';
    }

    function updatePhasePill(){
      var el = document.getElementById('phase');
      if (!el) return;
      el.textContent = phaseLabel();
    }

    function renderSteps(){
      var wrap = document.getElementById('steps');
      if (!wrap) return;
      var phase = (state.gameOver ? 'decision' : (state.awaitingDecision ? 'decision' : (state.phase || 'reveal')));
      var steps = wrap.querySelectorAll('.step');
      for (var i=0;i<steps.length;i++){
        var s = steps[i];
        var st = s.getAttribute('data-step');
        var active = false;
        if (phase === 'reveal') active = (st === 'reveal');
        else if (phase === 'event') active = (st === 'event');
        else if (phase === 'countdown') active = (st === 'countdown');
        else if (phase === 'decision') active = (st === 'decision');
        s.classList.toggle('active', active);
      }
    }

    function showBanner(kind, title, sub){
      var el = document.getElementById('banner');
      if (!el) return;
      var k = kind || 'info';
      el.innerHTML = '<b>' + esc(title || '') + '</b>' + (sub ? '<br><small>' + esc(sub) + '</small>' : '');
      el.className = 'banner show ' + ((k === 'good' || k === 'warn' || k === 'bad') ? k : '');
    }

    function clearBanner(){
      var el = document.getElementById('banner');
      if (!el) return;
      el.innerHTML = '';
      el.className = 'banner';
    }

    function setSummary(title, chips, foot){
      state.lastSummary = { title:title || 'Wirkung', chips: chips || [], foot: foot || '' };
      renderSummary();
    }

    function renderSummary(){
      var el = document.getElementById('eventSummary');
      if (!el) return;
      if (!state.lastSummary){
        el.innerHTML = '‚Äî';
        return;
      }
      var s = state.lastSummary;
      var h = '<div class="sumTitle"><b>' + esc(s.title) + '</b>' + (s.foot ? '<span class="mini">' + esc(s.foot) + '</span>' : '') + '</div><div class="sumRow">';
      for (var i=0;i<s.chips.length;i++){
        var c = s.chips[i];
        var cls = c.cls ? (' ' + c.cls) : '';
        h += '<span class="dChip' + cls + '"><span class="sym">' + esc(c.sym || '‚Ä¢') + '</span><span>' + esc(c.text || '') + '</span></span>';
      }
      h += '</div>';
      el.innerHTML = h;
    }

    function setPhase(p){
      state.phase = p || 'reveal';
      updatePhasePill();
      renderSteps();
    }

    function setUiMode(mode){
      state.uiMode = (mode === 'dev') ? 'dev' : 'play';
      document.body.classList.toggle('ui-play', state.uiMode === 'play');
      document.body.classList.toggle('ui-dev', state.uiMode === 'dev');
      var btnPlay = document.getElementById('btnModePlay');
      var btnDev = document.getElementById('btnModeDev');
      if (btnPlay) btnPlay.classList.toggle('active', state.uiMode === 'play');
      if (btnDev) btnDev.classList.toggle('active', state.uiMode === 'dev');
      updateUI();
    }

    function statusHeadlineText(){
      if (state.uiHeadline) return state.uiHeadline;
      if (state.gameOver) return 'Runde endet';
      if (state.awaitingDecision) return 'Alle entscheiden: Bleib oder Camp';
      if (state.phase === 'countdown') return (state.overload >= 12 ? 'Katastrophen-Check!' : 'Countdown l√§uft');
      if (state.phase === 'event') return 'Event wirkt';
      return 'Event aufdecken';
    }

    function setHeadline(text, ms){
      state.uiHeadline = text || null;
      updateUI();
      if (ms){
        if (state.uiHeadlineTimer) clearTimeout(state.uiHeadlineTimer);
        state.uiHeadlineTimer = setTimeout(function(){
          state.uiHeadline = null;
          updateUI();
        }, ms);
      }
    }

    function showPlayBanner(kind, text, ms){
      var el = document.getElementById('playBanner');
      if (!el) return;
      el.textContent = text || '';
      el.className = 'playBanner show ' + (kind || '');
      if (ms){
        if (state.playBannerTimer) clearTimeout(state.playBannerTimer);
        state.playBannerTimer = setTimeout(function(){
          el.className = 'playBanner';
          el.textContent = '';
        }, ms);
      }
    }

    function stopDecisionTimer(){
      var t = state.decisionTimer;
      if (t && t.timerId){
        clearInterval(t.timerId);
        t.timerId = null;
      }
    }

    function startDecisionTimer(){
      var t = state.decisionTimer;
      if (!t || !t.enabled) return;
      stopDecisionTimer();
      t.remaining = t.seconds;
      updateDecisionTimer();
      t.timerId = setInterval(function(){
        t.remaining -= 1;
        updateDecisionTimer();
        if (t.remaining <= 0){
          stopDecisionTimer();
          if (state.awaitingDecision){
            state.humanChoice = 'stay';
            state.humanLockedIn = true;
            updateUI();
            resolveDecisions();
          }
        }
      }, 1000);
    }

    function updateDecisionTimer(){
      var el = document.getElementById('decisionTimer');
      var t = state.decisionTimer;
      if (!el || !t) return;
      if (!t.enabled || !state.awaitingDecision){
        el.textContent = '‚Äî';
        return;
      }
      el.textContent = t.remaining + 's';
    }

    // ---------- modal helpers ----------
    function askYesNo(title, htmlText, yesLabel, noLabel, cb){
      var back = document.getElementById('askBack');
      var t = document.getElementById('askTitle');
      var body = document.getElementById('askText');
      var pick = document.getElementById('askPick');
      var yes = document.getElementById('askYes');
      var no = document.getElementById('askNo');
      var x = document.getElementById('askX');
      var btns = document.getElementById('askBtns');

      function close(val){
        if (!state.askOpen) return;
        state.askOpen = false;
        back.style.display = 'none';
        back.setAttribute('aria-hidden','true');
        yes.onclick = null; no.onclick = null; x.onclick = null; back.onclick = null;
        cb(!!val);
      }

      state.askOpen = true;
      t.textContent = title || 'Aktion';
      body.innerHTML = htmlText || '';
      pick.style.display = 'none';
      pick.innerHTML = '';
      btns.style.display = 'flex';
      yes.textContent = yesLabel || 'OK';
      no.textContent = noLabel || 'Abbrechen';

      yes.onclick = function(){ close(true); };
      no.onclick = function(){ close(false); };
      x.onclick = function(){ close(false); };
      back.onclick = function(e){ if (e.target && e.target.id === 'askBack') close(false); };

      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    function askPickOne(title, htmlText, options, cb){
      // options: [{ label, value }]
      var back = document.getElementById('askBack');
      var t = document.getElementById('askTitle');
      var body = document.getElementById('askText');
      var pick = document.getElementById('askPick');
      var no = document.getElementById('askNo');
      var x = document.getElementById('askX');
      var btns = document.getElementById('askBtns');

      function close(val){
        if (!state.askOpen) return;
        state.askOpen = false;
        back.style.display = 'none';
        back.setAttribute('aria-hidden','true');
        no.onclick = null; x.onclick = null; back.onclick = null;
        cb(val);
      }

      state.askOpen = true;
      t.textContent = title || 'Auswahl';
      body.innerHTML = htmlText || '';
      pick.style.display = 'flex';
      pick.innerHTML = '';
      btns.style.display = 'none';

      for (var i=0;i<options.length;i++){
        (function(opt){
          var b = document.createElement('button');
          b.className = 'btn blue pickBtn';
          b.textContent = opt.label;
          b.onclick = function(){ close(opt.value); };
          pick.appendChild(b);
        })(options[i]);
      }

      no.onclick = function(){ close(null); };
      x.onclick = function(){ close(null); };
      back.onclick = function(e){ if (e.target && e.target.id === 'askBack') close(null); };

      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    // ---------- UI ----------
    function updateUI(){
      // prev snapshot
      var prev = state._uiPrev || null;

      if (state.players.length){
        state.botCount = clampBotCount(Math.max(0, state.players.length - 1));
      }

      var verText = document.getElementById('verText');
      if (verText) verText.textContent = VERSION;
      var playVer = document.getElementById('playVersion');
      if (playVer) playVer.textContent = VERSION;
      var roundNo = document.getElementById('roundNo');
      if (roundNo) roundNo.textContent = String(state.round);
      var eventNo = document.getElementById('eventNo');
      if (eventNo) eventNo.textContent = String(state.turnId);
      var overloadValue = document.getElementById('overloadValue');
      if (overloadValue) overloadValue.textContent = String(state.overload);
      var poolValue = document.getElementById('poolValue');
      if (poolValue) poolValue.textContent = String(state.pool);
      var poolValueSide = document.getElementById('poolValueSide');
      if (poolValueSide) poolValueSide.textContent = String(state.pool);
      var poolPlay = document.getElementById('poolValuePlay');
      if (poolPlay) poolPlay.textContent = String(state.pool);
      var deckCount = document.getElementById('deckCount');
      if (deckCount) deckCount.textContent = String(state.deck.length);
      var discardCount = document.getElementById('discardCount');
      if (discardCount) discardCount.textContent = String(state.discard.length);
      var deckCountMini = document.getElementById('deckCountMini');
      if (deckCountMini) deckCountMini.textContent = cardCountLabel(state.deck.length);
      var discardCountMini = document.getElementById('discardCountMini');
      if (discardCountMini) discardCountMini.textContent = cardCountLabel(state.discard.length);

      var deckStack = document.getElementById('deckStack');
      var discardStack = document.getElementById('discardStack');
      if (deckStack) deckStack.classList.toggle('empty', state.deck.length === 0);
      if (discardStack) discardStack.classList.toggle('empty', state.discard.length === 0);

      var countdown = document.getElementById('countdown');
      if (countdown) countdown.textContent = state.countdownActive ? 'an' : 'aus';
      var countdownHint = document.getElementById('countdownHint');
      if (countdownHint) countdownHint.textContent = state.countdownActive ? 'aktiv' : 'inaktiv';
      var playCountdownHint = document.getElementById('playCountdownHint');
      if (playCountdownHint) playCountdownHint.textContent = state.countdownActive ? 'aktiv' : 'inaktiv';
      var playCountdownBadge = document.getElementById('playCountdownBadge');
      if (playCountdownBadge) playCountdownBadge.classList.toggle('active', state.countdownActive);
      var timerOpt = document.getElementById('optDecisionTimer');
      if (timerOpt){
        state.decisionTimer.enabled = !!timerOpt.checked;
        state.decisionTimer.seconds = 20;
      }
      var stageRule = document.getElementById('stageRule');
      if (stageRule) stageRule.textContent = state.stageRule ? state.stageRule.name : '‚Äî';
      var poolHint = document.getElementById('poolHint');
      if (poolHint){
        var dangerBonus = (state.overload >= 8) ? 1 : 0;
        var poolTake = poolTakeFor(state.overload, state.pool);
        poolHint.textContent = 'Camp-Bonus: +' + poolTake + ' (Pool ' + state.pool + ', Gefahr +' + dangerBonus + ')';
      }

      var pill = document.getElementById('stateChip');
      if (pill){
        var label = 'Normal';
        var cls = 'stageChip';
        if (state.overload >= 10) { label = 'Gef√§hrlich'; cls += ' bad'; }
        else if (state.overload <= 4) { label = 'Sicher'; cls += ' good'; }
        pill.className = cls;
        pill.innerHTML = '<b>Status</b>: ' + label;
      }

      var countdownChip = document.getElementById('countdownChip');
      if (countdownChip){
        countdownChip.className = 'stageChip warn';
        countdownChip.innerHTML = '<b>Countdown</b>: ' + (state.countdownActive ? 'an' : 'aus');
      }

      var countdownStatus = document.getElementById('countdownStatus');
      if (countdownStatus){
        countdownStatus.classList.toggle('active', state.countdownActive);
      }

      var stageRuleChip = document.getElementById('stageRuleChip');
      if (stageRuleChip){
        if (state.stageRule){
          stageRuleChip.textContent = 'üåÄ ' + state.stageRule.name;
          stageRuleChip.classList.add('active');
        } else {
          stageRuleChip.textContent = 'üåÄ B√ºhnenregel';
          stageRuleChip.classList.remove('active');
        }
      }

      var encoreChip = document.getElementById('encoreChip');
      if (encoreChip){
        if (state.encoreChain > 0){
          encoreChip.textContent = 'üé§ Encore-Kette ' + state.encoreChain;
          encoreChip.classList.add('active');
        } else {
          encoreChip.textContent = 'üé§ Encore-Kette';
          encoreChip.classList.remove('active');
        }
      }

      document.getElementById('revealerName').textContent = state.players[state.revealer] ? state.players[state.revealer].name : '‚Äî';
      document.getElementById('dir').textContent = (state.direction === 1) ? '‚Üª' : '‚Ü∫';
      var statusHeadline = document.getElementById('statusHeadline');
      if (statusHeadline) statusHeadline.textContent = statusHeadlineText();
      updateRevealCard();
      renderOverloadTrack();
      renderPlayChips(state.lastEvent);

      var botLabel = document.getElementById('botCountLabel');
      if (botLabel){
        botLabel.textContent = 'Bots: ' + state.botCount;
      }
      var addBtn = document.getElementById('btnAddBot');
      var removeBtn = document.getElementById('btnRemoveBot');
      var adjustBots = canAdjustBots();
      if (addBtn) addBtn.disabled = !adjustBots || state.botCount >= MAX_BOTS;
      if (removeBtn) removeBtn.disabled = !adjustBots || state.botCount <= MIN_BOTS;

      // Stat flashes (optisch "was ist passiert")
      if (prev){
        if (prev.round !== state.round){
          flashStat('roundBadge','good','Runde ' + state.round);
        }
        if (prev.overload !== state.overload){
          var dO = state.overload - prev.overload;
          var kindO = (dO > 0) ? (state.overload >= 10 ? 'bad' : 'warn') : 'good';
          flashStat('overloadChip', kindO, (dO>0?'+':'') + dO);
          var playTrack = document.getElementById('playOverloadTrack');
          if (playTrack){
            playTrack.classList.remove('pulse','pulseStrong','shake');
            void playTrack.offsetWidth;
            if (state.overload >= 12){
              playTrack.classList.add('shake');
              showPlayBanner('warn', '12 erreicht!', 1200);
            } else if (state.overload >= 8 && prev.overload < 8){
              playTrack.classList.add('pulseStrong');
            } else {
              playTrack.classList.add('pulse');
            }
          }
        }
        if (prev.pool !== state.pool){
          var dP = state.pool - prev.pool;
          flashStat('poolChip', (dP>0?'blue':'warn'), (dP>0?'+':'') + dP);
        }
        if (prev.deck !== state.deck.length){
          var dD = state.deck.length - prev.deck;
          flashStat('deckChip', (dD<0?'warn':'blue'), (dD>0?'+':'') + dD);
        }
        if (prev.discard !== state.discard.length){
          var dDi = state.discard.length - prev.discard;
          flashStat('discardChip', (dDi>0?'blue':'warn'), (dDi>0?'+':'') + dDi);
        }
        if (prev.countdownActive !== state.countdownActive){
          flashStat('countdownChip', state.countdownActive ? 'warn' : 'good', state.countdownActive ? 'an' : 'aus');
        }
      }

      // phase + steps + summary
      updatePhasePill();
      renderSteps();
      renderSummary();

      // context banner
      clearBanner();
      if (state.gameOver){
        showBanner('good','Spielende','Neustart starten, um erneut zu spielen.');
      } else if (state.askOpen){
        showBanner('warn','Auswahl offen','Triff eine Auswahl, um fortzufahren.');
      } else if (state.awaitingDecision){
        var hp = state.players[state.humanIndex];
        if (hp && hp.roundState === 'active'){
          var extra = (isAggCountdown() && state.countdownActive && state.pool >= 3) ? ' (Achtung: Countdown ist aggressiv, Pool ‚â•3)' : '';
          showBanner('warn','Entscheidung: Bleib oder Camp','Camp ist nur mit mindestens 1 Live m√∂glich.' + extra);
        } else {
          showBanner('good','Du bist gecampt','Du beobachtest diese Runde.');
        }
      } else if (state.overload >= 10){
        showBanner('bad','Gefahr hoch','Bei Overload 12 kommt sofort der Katastrophen-Check.');
      } else if (state.overload >= 8){
        showBanner('warn','Overload 8+','Beim Campen gibt es +1 extra aus dem Pool (falls vorhanden).');
      }

      renderPlayers();
      renderPlayPlayers();
      updateDecisionOverlay();
      updateDecisionTimer();
      if (!state.awaitingDecision || !state.decisionTimer.enabled) stopDecisionTimer();

      // store snapshot
      state._uiPrev = {
        round: state.round,
        overload: state.overload,
        pool: state.pool,
        deck: state.deck.length,
        discard: state.discard.length,
        countdownActive: state.countdownActive
      };

      var human = state.players[state.humanIndex];
      var isHumanActive = human.roundState === 'active';
      var forced = !!human.forcedStay;
      var campBlockedByZero = (human.live <= 0);

      var auto = isAutoAll();
      document.getElementById('btnStay').disabled = !state.awaitingDecision || !isHumanActive || state.gameOver || auto;
      document.getElementById('btnCamp').disabled = !state.awaitingDecision || !isHumanActive || state.gameOver || forced || campBlockedByZero || auto;
      document.getElementById('btnResolve').disabled = !state.awaitingDecision || state.gameOver || auto;

      // reveal
      var canReveal = !state.gameOver && !state.awaitingDecision &&
        ((state.revealer === state.humanIndex && isHumanActive) ||
        (areBotsManual() && state.players[state.revealer] && state.players[state.revealer].roundState === 'active'));
      document.getElementById('btnReveal').disabled = !canReveal || auto;
      var playReveal = document.getElementById('btnRevealPlay');
      if (playReveal){
        playReveal.disabled = !canReveal || auto;
        playReveal.textContent = canReveal ? 'Event aufdecken' : 'Warten‚Ä¶';
      }

      // hint
      var h = document.getElementById('decisionHint');
      if (!state.awaitingDecision) {
        h.textContent = '‚Äî';
      } else if (!isHumanActive) {
        h.textContent = 'Du bist in dieser Runde gecampt.';
      } else if (forced) {
        h.innerHTML = 'Du bist durch <b>Stage Dive</b> gezwungen, diese Phase <b>drin zu bleiben</b>.';
      } else if (campBlockedByZero) {
        h.innerHTML = 'Du hast <b>0 Live</b> ‚Üí du darfst nicht campen.';
      } else {
        if (auto) h.textContent = 'Autoplay ist aktiv ‚Äì Entscheidungen werden automatisch aufgel√∂st.';
        else if (areBotsManual()) h.textContent = 'W√§hle Bleib oder Camp. Danach entscheide auch die Bots.';
        else h.textContent = 'W√§hle Bleib oder Camp (Camp nur mit Live). Dann wird simultan aufgel√∂st.';
      }

      // highlight choice
      var stay = document.getElementById('btnStay');
      var camp = document.getElementById('btnCamp');
      stay.classList.toggle('selected', state.humanChoice === 'stay');
      camp.classList.toggle('selected', state.humanChoice === 'camp');
    }

    function applyBotProfileToBots(botId){
      state.botProfileId = botId;
      for (var i=0;i<state.players.length;i++){
        if (i === state.humanIndex) continue;
        state.players[i].botId = botId;
      }
    }

    function addBot(){
      if (!canAdjustBots()){
        toast('Bots gesperrt', 'Bots lassen sich nur vor dem ersten Event anpassen.');
        return;
      }
      if (state.botCount >= MAX_BOTS){
        toast('Limit erreicht', 'Maximal ' + MAX_BOTS + ' Bots m√∂glich.');
        return;
      }
      state.botCount = clampBotCount(state.botCount + 1);
      state.players = buildPlayers(state.botCount);
      state.botChoices = {};
      applyBotProfileToBots(state.botProfileId);
      updateUI();
    }

    function removeBot(){
      if (!canAdjustBots()){
        toast('Bots gesperrt', 'Bots lassen sich nur vor dem ersten Event anpassen.');
        return;
      }
      if (state.botCount <= MIN_BOTS){
        toast('Minimum erreicht', 'Mindestens ' + MIN_BOTS + ' Bot bleibt im Spiel.');
        return;
      }
      state.botCount = clampBotCount(state.botCount - 1);
      state.players = buildPlayers(state.botCount);
      state.botChoices = {};
      applyBotProfileToBots(state.botProfileId);
      updateUI();
    }

    function renderOverloadTrack(){
      var wraps = [document.getElementById('overloadPills'), document.getElementById('overloadPillsPlay')];
      for (var w=0;w<wraps.length;w++){
        var wrap = wraps[w];
        if (!wrap) continue;
        if (!wrap.dataset.ready){
          wrap.innerHTML = '';
          for (var i=0;i<=MAX_OVERLOAD;i++){
            var pill = document.createElement('span');
            pill.className = 'overloadPill';
            pill.textContent = String(i);
            pill.dataset.val = String(i);
            wrap.appendChild(pill);
          }
          wrap.dataset.ready = 'true';
        }

        var pills = wrap.querySelectorAll('.overloadPill');
        for (var j=0;j<pills.length;j++){
          var v = Number(pills[j].dataset.val || j);
          pills[j].classList.toggle('active', v === state.overload);
          pills[j].classList.toggle('mark', v === 8);
          pills[j].classList.toggle('danger', v === 12);
        }
      }
    }

    function updateDecisionOverlay(){
      var overlay = document.getElementById('decisionOverlay');
      if (!overlay) return;
      overlay.classList.toggle('show', state.awaitingDecision);
      overlay.setAttribute('aria-hidden', state.awaitingDecision ? 'false' : 'true');

      var human = state.players[state.humanIndex] || { live:0, camp:0, roundState:'camped', forcedStay:false };
      document.getElementById('decisionOverload').textContent = String(state.overload) + '/12';
      document.getElementById('decisionPool').textContent = String(state.pool);
      document.getElementById('decisionLive').textContent = String(human.live);

      var campHint = document.getElementById('campHint');
      if (human.live <= 0) campHint.textContent = 'Camp erst ab 1 Live';
      else if (human.forcedStay) campHint.textContent = 'Zwang: Bleib';
      else campHint.textContent = 'Du sicherst dein Live';

      var preview = document.getElementById('decisionPreview');
      var gainLine = document.getElementById('decisionGain');
      var totalLine = document.getElementById('decisionTotal');
      if (!state.awaitingDecision){
        preview.style.opacity = '0.6';
        gainLine.textContent = '‚Äî';
        totalLine.textContent = '‚Äî';
      } else {
        preview.style.opacity = '1';
        var poolBonus = poolTakeFor(state.overload, state.pool);
        if (human.roundState !== 'active'){
          gainLine.textContent = 'Du beobachtest diese Runde.';
          totalLine.textContent = 'Camp bleibt bei ' + human.camp + '.';
        } else if (human.live <= 0){
          gainLine.textContent = 'Camp nicht m√∂glich (0 Live).';
          totalLine.textContent = 'Camp bleibt bei ' + human.camp + '.';
        } else if (human.forcedStay){
          gainLine.textContent = 'Zwang: Bleib (Stage Dive).';
          totalLine.textContent = 'Camp bleibt bei ' + human.camp + '.';
        } else {
          gainLine.textContent = 'Du sicherst: +' + human.live + ' Camp';
          totalLine.textContent = 'Pool-Bonus: +' + poolBonus + ' ¬∑ Gesamt danach: ' + (human.camp + human.live + poolBonus);
        }
      }

      var playersWrap = document.getElementById('decisionPlayers');
      if (playersWrap){
        playersWrap.innerHTML = '';
        for (var i=0;i<state.players.length;i++){
          var p = state.players[i];
          var done = (p.roundState !== 'active') || (i === state.humanIndex && state.humanLockedIn);
          if (areBotsManual() && i !== state.humanIndex){
            done = done || !!state.botChoices[String(i)];
          }
          var chip = document.createElement('div');
          chip.className = 'decisionPlayer' + (done ? ' done' : '');
          chip.textContent = p.name.substring(0,2).toUpperCase();
          playersWrap.appendChild(chip);
        }
      }

      renderBotDecisionControls();
    }

    function renderBotDecisionControls(){
      var wrap = document.getElementById('decisionBots');
      if (!wrap) return;

      var show = state.awaitingDecision && areBotsManual();
      wrap.classList.toggle('hidden', !show);
      if (!show){
        wrap.innerHTML = '';
        return;
      }

      wrap.innerHTML = '';
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (i === state.humanIndex) continue;
        if (p.roundState !== 'active') continue;

        var row = document.createElement('div');
        row.className = 'decisionBotRow';

        var head = document.createElement('div');
        head.className = 'decisionBotHead';
        head.innerHTML = '<span>' + esc(p.name) + '</span><span class="mini">Live ' + p.live + ' ¬∑ Camp ' + p.camp + '</span>';

        var choices = document.createElement('div');
        choices.className = 'decisionBotChoices';

        var stay = document.createElement('button');
        stay.className = 'decisionBotBtn good';
        stay.textContent = 'Bleib';
        stay.onclick = (function(idx){
          return function(){
            state.botChoices[String(idx)] = 'stay';
            updateUI();
          };
        })(i);

        var camp = document.createElement('button');
        camp.className = 'decisionBotBtn warn';
        camp.textContent = 'Camp';
        camp.disabled = p.live <= 0 || p.forcedStay;
        camp.onclick = (function(idx){
          return function(){
            state.botChoices[String(idx)] = 'camp';
            updateUI();
          };
        })(i);

        var current = state.botChoices[String(i)] || 'stay';
        stay.classList.toggle('selected', current === 'stay');
        camp.classList.toggle('selected', current === 'camp');

        choices.appendChild(stay);
        choices.appendChild(camp);

        row.appendChild(head);
        row.appendChild(choices);
        wrap.appendChild(row);
      }
    }

    function renderPlayers(){
      var el = document.getElementById('players');
      el.innerHTML = '';

      var prev = state._uiPrevPlayers || null;
      var nextPrev = {};

      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];

        var statusLabel = (p.roundState === 'camped') ? 'GECAMPT' : 'AKTIV';
        var statusClass = (p.roundState === 'camped') ? 'badgeCamp' : 'badgeActive';

        var marks = [];
        if (!state.awaitingDecision && i === state.revealer && p.roundState === 'active') marks.push('<span class="playerMark">‚¨ÖÔ∏è Aufdecker</span>');
        if (p.forcedStay && p.roundState === 'active') marks.push('<span class="playerMark warn">MUSS BLEIBEN</span>');
        if (state.awaitingDecision && i === state.humanIndex && state.humanLockedIn) marks.push('<span class="playerMark">‚úÖ gew√§hlt</span>');

        var cls = 'playerCard';
        if (p.roundState === 'camped') cls += ' campedDim';
        if (!state.awaitingDecision && i === state.revealer && p.roundState === 'active') cls += ' turnGlow';
        if (state.awaitingDecision && p.roundState === 'active') cls += ' decideGlow';

        // delta detection
        var dLive = 0, dCamp = 0;
        if (prev && prev[String(i)]){
          dLive = p.live - prev[String(i)].live;
          dCamp = p.camp - prev[String(i)].camp;
        }

        var deltaHtml = '';
        if ((dLive !== 0 || dCamp !== 0) && prev){
          var chunks = [];
          if (dCamp !== 0) chunks.push('<span class="dTag good">üèïÔ∏è Camp ' + (dCamp>0?'+':'') + dCamp + '</span>');
          if (dLive !== 0) chunks.push('<span class="dTag blue">üéüÔ∏è Live ' + (dLive>0?'+':'') + dLive + '</span>');
          deltaHtml = '<div class="deltaLine">' + chunks.join('') + '</div>';
        }

        nextPrev[String(i)] = { live:p.live, camp:p.camp, roundState:p.roundState };

        var div = document.createElement('div');
        div.className = cls;
        div.id = 'p' + i;

        div.innerHTML =
          '<div class="playerHeader">' +
            '<div class="playerName"><span class="playerAvatar">' + esc(p.name.substring(0,1)) + '</span>' + esc(p.name) + ' <span class="tag">' + (p.name === 'Du' ? 'Du' : 'Bot') + '</span></div>' +
            '<span class="playerBadge ' + statusClass + '">' + statusLabel + '</span>' +
          '</div>' +
          '<div class="playerStats">' +
            '<div class="playerStat"><span>üéüÔ∏è</span><b>Live</b> ' + p.live + '</div>' +
            '<div class="playerStat"><span>‚õ∫</span><b>Camp</b> ' + p.camp + '</div>' +
          '</div>' +
          (marks.length ? '<div class="playerActions">' + marks.join('') + '</div>' : '') +
          deltaHtml;

        el.appendChild(div);
      }

      state._uiPrevPlayers = nextPrev;
    }

    function renderPlayPlayers(){
      var el = document.getElementById('playersPlay');
      if (!el) return;
      el.innerHTML = '';

      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        var statusText = 'AKTIV';
        var statusCls = 'active';
        if (state.gameOver && p.camp < WIN_CAMP){
          statusText = 'RAUS';
          statusCls = 'out';
        } else if (p.roundState === 'camped'){
          statusText = 'GECAMPT';
          statusCls = 'camped';
        }

        var row = document.createElement('div');
        row.className = 'playPlayer';

        var main = document.createElement('div');
        main.className = 'playPlayerMain';
        main.innerHTML = '<span class="playerAvatar">' + esc(p.name.substring(0,1)) + '</span><span>' + esc(p.name) + '</span>';

        var right = document.createElement('div');
        right.className = 'playPlayerRight';

        var status = document.createElement('span');
        status.className = 'playStatus ' + statusCls;
        status.textContent = statusText;

        var stats = document.createElement('div');
        stats.className = 'playStats';
        stats.innerHTML = '<span>üéüÔ∏è ' + p.live + '</span><span>‚õ∫ ' + p.camp + '</span>';

        right.appendChild(status);
        right.appendChild(stats);

        if (i === state.revealer && p.roundState === 'active'){
          var rev = document.createElement('span');
          rev.className = 'playRevealer';
          rev.textContent = '‚¨ÖÔ∏è Aufdecker';
          right.appendChild(rev);
        }

        row.appendChild(main);
        row.appendChild(right);

        el.appendChild(row);
      }
    }

    // ---------- deck -----------------
    function mkDeck(){
      var deck = [];
      var i;

      // Push (26)
      for (i=0;i<10;i++) deck.push({ type:'push', name:'Soundcheck', delta:1, text:'Overload +1. Aufdecker +1 Live. +1 in Pool.' });
      for (i=0;i<10;i++) deck.push({ type:'push', name:'Crowd Surf', delta:2, text:'Overload +2. Aufdecker +1 Live. +1 in Pool.' });
      for (i=0;i<6;i++) deck.push({ type:'push', name:'Bassdrop', delta:3, text:'Overload +3. Aufdecker +1 Live. +1 in Pool.' });

      // Stabilisieren (14) ‚Äì Patch P2: Ertrag nur bei Overload 8+ (vor dem Senken)
      for (i=0;i<STABILIZE_CARDS.length;i++){
        var sc = STABILIZE_CARDS[i];
        for (var j=0;j<sc.count;j++){
          deck.push({
            type:'stabilize',
            name: sc.name,
            delta: -sc.value,
            text:'Overload ‚àí' + sc.value + '. Wenn Overload vor dem Senken 8+ war: Aufdecker +1 Live (Vorrat).'
          });
        }
      }

      // Twist (14)
      for (i=0;i<2;i++) deck.push({ type:'twist', name:'Richtungswechsel', fx:'flipDir', text:'Drehe die Aufdeck-Reihenfolge um.' });
      for (i=0;i<4;i++) deck.push({ type:'twist', name:'Feedback', fx:'feedback', stage:true, text:'B√ºhnenregel üåÄ‚àû: Bis Rundenende gibt jede ‚ö° zus√§tzlich +1 Overload.' });
      for (i=0;i<3;i++) deck.push({ type:'twist', name:'Pyro', fx:'pyro', text:'Overload +2.' });
      for (i=0;i<3;i++) deck.push({ type:'twist', name:'Stage Dive', fx:'stageDive', text:'W√§hle einen aktiven Spieler: Er zahlt 1 Live oder bleibt beim n√§chsten Camp-Entscheid automatisch drin. Ist er bereits betroffen: Overload +1 (cap 12).' });
      for (i=0;i<2;i++) deck.push({ type:'twist', name:'Setwechsel', fx:'setwechsel', text:'Der n√§chste Event wird vom gleichen Spieler aufgedeckt (noch einmal).' });

      // Encore (6)
      for (i=0;i<6;i++) deck.push({ type:'encore', name:'Encore!', fx:'encore', text:'Ketten-Event: Aufdecker kann 1 Live zahlen, um zu stoppen. Sonst sofort n√§chstes Event.' });

      return shuffle(deck);
    }

    // ---------- rules ----------
    function checkWin(){
      for (var i=0;i<state.players.length;i++){
        if (state.players[i].camp >= WIN_CAMP){
          if (!state.gameOver){
            state.gameOver = true;
            log('good','<b>' + esc(state.players[i].name) + ' gewinnt!</b> (' + state.players[i].camp + ' Camp)');
            screenFlash('good');
            toast('Spiel beendet', state.players[i].name + ' gewinnt mit ' + state.players[i].camp + ' Camp.');
          }
          return true;
        }
      }
      return false;
    }

    function endRound(reason){
      if (state.gameOver) return;
      if (!state.players.length){
        log('bad','Keine Spieler gefunden ‚Üí Neustart.');
        restart();
        return;
      }
      stopDecisionTimer();
      state.roundResetId += 1;

      // stage rule to discard
      if (state.stageRule && state.stageRule._cardRef){
        state.discard.push(state.stageRule._cardRef);
      }

      if (state.pool > 0){
        log('warn','Rundenende: Pool ' + state.pool + ' verf√§llt. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + '‚Üí0 ¬∑ Live/Camp unver√§ndert.');
      }
      state.pool = 0;
      state.stageRule = null;
      state.countdownActive = false;
      state.direction = 1;
      state.extraRevealSame = false;
      state.overload = 0;
      state.encoreChain = 0;

      for (var i=0;i<state.players.length;i++){
        state.players[i].live = 0;
        state.players[i].roundState = 'active';
        state.players[i].forcedStay = false;
      }

      state.round += 1;
      state.startPlayer = (state.startPlayer + 1) % state.players.length;
      state.revealer = state.startPlayer;
      state.awaitingDecision = false;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.botChoices = {};
      state.lastEvent = null;
      state.askOpen = false;
      var askBack = document.getElementById('askBack');
      if (askBack){
        askBack.style.display = 'none';
        askBack.setAttribute('aria-hidden','true');
      }

      log('good','<b>Neue Runde ' + state.round + '</b> ‚Äì Overload=0, Pool leer, B√ºhnenregel entfernt. ' + (reason ? '('+esc(reason)+')' : ''));
      setEventCard(null);
      updateUI();
      setPhase('reveal');
      pumpBots();
    }

    function doKnall(reason){
      // all active players lose live, camped safe
      var pfl = !!document.getElementById('optPflaster').checked;
      log('bad','<b>KNALL</b>: ' + esc(reason) + '. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp folgt pro Spieler.');

      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (p.roundState !== 'active') continue;
        var liveBefore = p.live;
        var campBefore = p.camp;
        var campAfter = campBefore;
        if (pfl && liveBefore > 0){
          campAfter = campBefore + 1;
        }
        p.camp = campAfter;
        p.live = 0;

        if (pfl){
          log('bad','KNALL: <b>' + esc(p.name) + '</b> Live ' + liveBefore + '‚Üí0, Pflaster: +1 Camp (wenn m√∂glich) => Camp ' + campBefore + '‚Üí' + campAfter + '. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + liveBefore + '‚Üí0 ¬∑ Camp ' + campBefore + '‚Üí' + campAfter + '.');
        } else {
          log('bad','KNALL: <b>' + esc(p.name) + '</b> Live ' + liveBefore + '‚Üí0, Pflaster: aus => Camp ' + campBefore + '‚Üí' + campAfter + '. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + liveBefore + '‚Üí0 ¬∑ Camp ' + campBefore + '‚Üí' + campAfter + '.');
        }
      }

      screenFlash('bad');
      toast('KNALL!', 'Runde endet sofort.');
      setHeadline('KNALL! Runde endet', 1600);
      showPlayBanner('bad', 'KNALL! Runde endet', 1600);

      if (checkWin()) { updateUI(); return; }
      endRound('Knall');
    }

    function applyOverloadDelta(delta){
      var before = state.overload;
      var after = clampOverload(state.overload + delta);
      state.overload = after;
      var reached = (before < 12 && after === 12);
      return { before: before, after: after, delta: (after - before), reached12: reached };
    }

    function catastropheCheck(){
      setHeadline('Katastrophen-Check!', 1200);
      var card = draw(1)[0] || null;
      if (!card){
        log('warn','Check-Karte: keine verf√ºgbar ‚Üí Safe, Overload 12‚Üí' + OVERLOAD_RESET_AFTER_CHECK + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');
        state.overload = OVERLOAD_RESET_AFTER_CHECK;
        showPlayBanner('good', 'Gerade noch so!', 1200);
        updateUI();
        return;
      }

      var isPush = (card.type === 'push');
      state.discard.push(card);
      showPlayCheckCard(card);

      if (isPush){
        log('bad','Check-Karte: <b>Push</b> ‚Üí <b>Knall</b>. Overload 12 bleibt bis zum Knall. Pool ' + state.pool + '.');
        showPlayBanner('bad', 'KNALL!', 1200);
        doKnall('Katastrophen-Check hat Push aufgedeckt');
        return;
      }

      log('good','Check-Karte: <b>' + esc(labelType(card.type).txt) + '</b> ‚Üí Safe, Overload 12‚Üí<b>' + OVERLOAD_RESET_AFTER_CHECK + '</b> ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');
      state.overload = OVERLOAD_RESET_AFTER_CHECK;
      showPlayBanner('good', 'Gerade noch so!', 1200);
      updateUI();
    }

    function onOverloadMayHit12(r, why){
      if (state.gameOver) return;
      if (r.reached12){
        log('warn','Overload erreicht <b>12</b> (' + esc(why) + ') ‚Üí <b>Katastrophen-Check</b>. Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');
        catastropheCheck();
      }
    }

    function ensureDecisionPhase(){
      if (state.gameOver) return;
      state.awaitingDecision = true;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.botChoices = {};
      state.encoreChain = 0;
      setPhase('decision');

      setSummary('Entscheidung',
        [
          { cls:'good', sym:'‚úÖ', text:'Bleib: Live bleibt im Risiko' },
          { cls:'warn', sym:'üèïÔ∏è', text:'Camp: nur mit mindestens 1 Live' },
          { cls:'blue', sym:'üéÅ', text:'Pool-Bonus: poolTake = min(Pool, 1 + Gefahr)' }
        ],
        'Simultan, offen'
      );

      updateUI();
      startDecisionTimer();
    }

    function resolveCountdownTick(){
      if (!state.countdownActive) return;
      if (state.gameOver) return;
      setPhase('countdown');

      var add = 1;
      if (isAggCountdown() && state.pool >= 3) add += 1;

      var r = applyOverloadDelta(+add);
      var capNote = describeOverloadCap(r.before, add, r.after);
      log('warn','<b>Countdown</b>: Nach dem Event steigt Overload automatisch um +' + add + ' ‚Üí ' + r.before + ' + ' + add + ' = <b>' + r.after + '</b>' + capNote + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');

      setSummary('Countdown',
        [
          { cls:'warn', sym:'‚è±Ô∏è', text:'Overload +' + add + ' ‚Üí ' + r.after + (capNote ? ' (cap)' : '') },
          (isAggCountdown() ? { cls:'blue', sym:'üéÅ', text:(state.pool >= 3 ? 'Pool ‚â•3: extra +1 aktiv' : 'Pool <3: kein Extra') } : { cls:'blue', sym:'‚öôÔ∏è', text:'Aggressiv: aus' })
        ],
        'Countdown ist aktiv, solange die Runde l√§uft'
      );

      updateUI();
      onOverloadMayHit12(r, 'Countdown');
    }

    // ---------- Bot-Module (Wrapper) ----------
    function botWantsToCamp(pi){
      var p = state.players[pi];
      var bot = getBotModule(p.botId || state.botProfileId);
      var res = bot.decideCamp(botCtx(pi));
      return res === 'camp';
    }

    function botEncoreStop(pi){
      var p = state.players[pi];
      var bot = getBotModule(p.botId || state.botProfileId);
      return !!bot.stopEncore(botCtx(pi));
    }

    function botStageDivePay(pi){
      var p = state.players[pi];
      var bot = getBotModule(p.botId || state.botProfileId);
      return !!bot.stageDivePay(botCtx(pi));
    }

    function botPickStageDiveTarget(revealer){
      var p = state.players[revealer];
      var bot = getBotModule(p.botId || state.botProfileId);
      return bot.pickStageDiveTarget(botCtx(revealer));
    }

    // ---------- event effects ----------
    function hasFeedbackRule(){
      return !!(state.stageRule && state.stageRule.fx === 'feedback');
    }

    function applyPush(rev, card){
      var p = state.players[rev];
      var base = (typeof card.delta === 'number') ? card.delta : 1;
      var mod = hasFeedbackRule() ? 1 : 0;
      var total = base + mod;
      var before = state.overload;
      var liveBefore = p.live;
      var campBefore = p.camp;
      var poolBefore = state.pool;
      var unclamped = before + total;
      var after = Math.min(MAX_OVERLOAD, unclamped);
      var capNote = describeOverloadCap(before, total, after);
      state.overload = after;
      var r = { before: before, after: after, delta: (after - before), reached12: (before < MAX_OVERLOAD && after === MAX_OVERLOAD) };
      p.live += 1;
      state.pool += 1;

      setSummary('‚ö° Push ‚Äì ' + card.name,
        [
          { cls:'bad',  sym:'‚ö°', text:'Overload +' + total + ' ‚Üí ' + r.after + (capNote ? ' (cap)' : '') },
          { cls:'blue', sym:'üéüÔ∏è', text:p.name + ' Live +1 (jetzt ' + p.live + ')' },
          { cls:'warn', sym:'üéÅ', text:'Pool +1 (jetzt ' + state.pool + ')' }
        ],
        'Danach: Entscheidung Bleib/Camp'
      );

      log('info','<b>' + esc(p.name) + '</b> deckt ‚ö° <b>' + esc(card.name) + '</b> auf ‚Üí Overload ' + before + ' + (' + base + ' Karte +' + mod + ' Feedback) = <b>' + after + '</b>' + capNote + ' ¬∑ Pool ' + poolBefore + '‚Üí' + state.pool + ' ¬∑ Live ' + liveBefore + '‚Üí' + p.live + ' ¬∑ Camp ' + campBefore + '.');
      updateUI();
      onOverloadMayHit12(r, 'Push');
    }

    function applyStabilize(rev, card){
      var p = state.players[rev];
      var beforeOver = state.overload;
      var liveBefore = p.live;
      var campBefore = p.camp;
      var poolBefore = state.pool;
      var valueAbs = Math.abs((typeof card.delta === 'number') ? card.delta : -2);
      var unclamped = beforeOver - valueAbs;
      var afterOver = Math.max(0, unclamped);
      var floorNote = describeOverloadFloor(beforeOver, valueAbs, afterOver);
      state.overload = afterOver;

      log('good','<b>' + esc(p.name) + '</b> deckt üõ†Ô∏è <b>' + esc(card.name) + '</b> auf ‚Üí Overload ' + beforeOver + ' ‚àí' + valueAbs + ' = <b>' + afterOver + '</b>' + floorNote + ' ¬∑ Pool ' + poolBefore + '‚Üí' + state.pool + ' ¬∑ Live ' + liveBefore + '‚Üí' + p.live + ' ¬∑ Camp ' + campBefore + '.');

      // Patch P2: Ertrag nur wenn Overload VOR dem Senken 8+ war
      var got = 0;
      if (beforeOver >= 8){
        p.live += 1;
        got = 1;
        log('good','Stabilisieren-Ertrag: Overload vor dem Senken war <b>' + beforeOver + '</b> (8+) ‚Üí ' + esc(p.name) + ' erh√§lt <b>+1 Live</b> (Vorrat). Overload ' + state.overload + ' ¬∑ Pool ' + poolBefore + '‚Üí' + state.pool + ' ¬∑ Live ' + liveBefore + '‚Üí' + p.live + ' ¬∑ Camp ' + campBefore + '.');
      } else {
        log('info','Stabilisieren-Ertrag: Overload vor dem Senken war <b>' + beforeOver + '</b> (&lt;8) ‚Üí kein Ertrag. Overload ' + state.overload + ' ¬∑ Pool ' + poolBefore + '‚Üí' + state.pool + ' ¬∑ Live ' + liveBefore + '‚Üí' + p.live + ' ¬∑ Camp ' + campBefore + '.');
      }

      setSummary('üõ†Ô∏è Stabilisieren ‚Äì ' + card.name,
        [
          { cls:'good', sym:'üõ†Ô∏è', text:'Overload ‚àí' + valueAbs + ' ‚Üí ' + afterOver },
          (got ? { cls:'blue', sym:'üéüÔ∏è', text:p.name + ' Live +1 (jetzt ' + p.live + ')' } : { cls:'blue', sym:'‚Äî', text:'Kein Live-Ertrag (Overload vor dem Senken <8)' })
        ],
        'Danach: Entscheidung Bleib/Camp'
      );

      updateUI();
    }

    function applyTwist(rev, card, doneCb){
      var p = state.players[rev];

      if (card.stage){
        if (state.stageRule && state.stageRule._cardRef){
          state.discard.push(state.stageRule._cardRef);
          log('warn','üåÄ‚àû B√ºhnenregel wird ersetzt: <b>' + esc(state.stageRule.name) + '</b> ‚Üí <b>' + esc(card.name) + '</b>.');
        } else {
          log('warn','üåÄ‚àû Neue B√ºhnenregel: <b>' + esc(card.name) + '</b>.');
        }
        state.stageRule = { name: card.name, text: card.text, fx: card.fx, _cardRef: card };
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'flipDir'){
        state.direction *= -1;
        var nextFlip = nextActiveFrom(state.revealer, state.direction);
        var nextFlipName = (nextFlip === -1) ? '‚Äî' : state.players[nextFlip].name;
        log('warn','<b>' + esc(p.name) + '</b> deckt üåÄ <b>' + esc(card.name) + '</b> auf ‚Üí Richtung dreht sich: ' + (state.direction === 1 ? '<b>‚Üª</b>' : '<b>‚Ü∫</b>') + '. N√§chster Aufdecker: <b>' + esc(nextFlipName) + '</b>.');
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'pyro'){
        var r = applyOverloadDelta(+2);
        var capNote = describeOverloadCap(r.before, 2, r.after);
        log('warn','<b>' + esc(p.name) + '</b> deckt üåÄ <b>' + esc(card.name) + '</b> auf ‚Üí Overload ' + r.before + ' +2 = <b>' + r.after + '</b>' + capNote + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');
        updateUI();
        onOverloadMayHit12(r, 'Pyro');
        doneCb();
        return;
      }

      if (card.fx === 'setwechsel'){
        state.extraRevealSame = true;
        log('warn','<b>' + esc(p.name) + '</b> deckt üåÄ <b>' + esc(card.name) + '</b> auf ‚Üí N√§chstes Event deckt der gleiche Spieler auf. N√§chster Aufdecker: <b>' + esc(p.name) + '</b>.');
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'stageDive'){
        if (rev === state.humanIndex) {
          if (isAutoAll()){
            var aiTarget = botPickStageDiveTarget(rev);
            if (aiTarget === rev){
              log('warn','Stage Dive: Kein anderer aktiver Spieler ‚Üí Effekt verpufft.');
              doneCb();
              return;
            }
            resolveStageDiveTarget(rev, aiTarget, doneCb);
            return;
          }

          var opts = [];
          for (var i=0;i<state.players.length;i++){
            if (state.players[i].roundState !== 'active') continue;
            if (i === rev) continue;
            opts.push({ label: state.players[i].name + ' (Live ' + state.players[i].live + ')', value: i });
          }
          if (!opts.length){
            log('warn','Stage Dive: Kein anderer aktiver Spieler ‚Üí Effekt verpufft.');
            doneCb();
            return;
          }

          askPickOne(
            'Stage Dive ‚Äì Ziel w√§hlen',
            '<b>Stage Dive</b>: W√§hle einen aktiven Spieler. Er zahlt 1 Live oder bleibt beim n√§chsten Camp-Entscheid automatisch drin.',
            opts,
            function(val){
              if (val === null || typeof val !== 'number'){
                log('warn','Stage Dive: Keine Auswahl ‚Üí Effekt verpufft.');
                doneCb();
                return;
              }
              resolveStageDiveTarget(rev, val, doneCb);
            }
          );
          return;
        }

        if (areBotsManual()){
          var optsBot = [];
          for (var j=0;j<state.players.length;j++){
            if (state.players[j].roundState !== 'active') continue;
            if (j === rev) continue;
            optsBot.push({ label: state.players[j].name + ' (Live ' + state.players[j].live + ')', value: j });
          }
          if (!optsBot.length){
            log('warn','Stage Dive: Kein anderer aktiver Spieler ‚Üí Effekt verpufft.');
            doneCb();
            return;
          }
          askPickOne(
            'Stage Dive ‚Äì Ziel f√ºr ' + state.players[rev].name,
            '<b>Stage Dive</b>: Du steuerst die Bots. W√§hle das Ziel.',
            optsBot,
            function(val){
              if (val === null || typeof val !== 'number'){
                log('warn','Stage Dive: Keine Auswahl ‚Üí Effekt verpufft.');
                doneCb();
                return;
              }
              resolveStageDiveTarget(rev, val, doneCb);
            }
          );
          return;
        }

        var targetIdx = botPickStageDiveTarget(rev);
        resolveStageDiveTarget(rev, targetIdx, doneCb);
        return;
      }

      log('info','Twist ohne Effekt: <b>' + esc(card.name) + '</b>.');
      doneCb();
    }

    function resolveStageDiveTarget(rev, targetIdx, doneCb){
      var revP = state.players[rev];
      var tP = state.players[targetIdx];

      // Stage Dive darf nie den Aufdecker selbst treffen.
      if (targetIdx === rev){
        log('warn','Stage Dive: Kein anderes aktives Ziel ‚Üí Effekt verpufft.');
        doneCb();
        return;
      }

      if (!tP || tP.roundState !== 'active'){
        log('warn','Stage Dive: Ziel ist nicht aktiv ‚Üí Effekt verpufft.');
        doneCb();
        return;
      }

      log('warn','<b>' + esc(revP.name) + '</b> l√∂st üåÄ <b>Stage Dive</b> aus auf <b>' + esc(tP.name) + '</b>.');
      updateUI();

      if (tP.forcedStay){
        if (STAGE_DIVE_REPLACEMENT === 'overload'){
          var before = state.overload;
          var r = applyOverloadDelta(1);
          var capNote = describeOverloadCap(before, 1, r.after);
          log('warn','Stage Dive auf <b>' + esc(tP.name) + '</b>: bereits aktiv ‚Üí Ersatz-Effekt Overload ' + before + ' +1 = <b>' + r.after + '</b>' + capNote + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');
          onOverloadMayHit12(r, 'Stage Dive Ersatz');
        } else {
          var poolBefore = state.pool;
          state.pool += 1;
          log('warn','Stage Dive auf <b>' + esc(tP.name) + '</b>: bereits aktiv ‚Üí Ersatz-Effekt Pool +1 (Pool ' + poolBefore + '‚Üí' + state.pool + '). Overload ' + state.overload + ' ¬∑ Pool ' + poolBefore + '‚Üí' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');
        }
        updateUI();
        doneCb();
        return;
      }

      if (targetIdx === state.humanIndex){
        if (isAutoAll()){
          if (tP.live > 0 && botStageDivePay(targetIdx)){
            tP.live = Math.max(0, tP.live - 1);
            log('good','Du zahlst <b>1 Live</b> ‚Üí Stage Dive ignoriert. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + (tP.live + 1) + '‚Üí' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
            doneCb();
            return;
          }
          tP.forcedStay = true;
          log('bad','Stage Dive: <b>' + esc(tP.name) + '</b> muss beim n√§chsten Entscheid <b>Bleib</b> w√§hlen (sofern er noch aktiv ist). Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
          doneCb();
          return;
        }

        if (tP.live <= 0){
          tP.forcedStay = true;
          log('bad','Stage Dive: <b>' + esc(tP.name) + '</b> muss beim n√§chsten Entscheid <b>Bleib</b> w√§hlen (sofern er noch aktiv ist). Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
          toast('Stage Dive', 'Du musst drin bleiben (kein Live zum Zahlen).');
          doneCb();
          return;
        }

        askYesNo(
          'Stage Dive ‚Äì Zahlen?',
          '<b>Stage Dive</b> trifft dich.<br><br>Willst du <b>1 Live</b> zahlen, um nicht betroffen zu sein?',
          '1 Live zahlen',
          'Nicht zahlen',
          function(use){
            if (use){
              tP.live = Math.max(0, tP.live - 1);
              log('good','Du zahlst <b>1 Live</b> ‚Üí Stage Dive ignoriert. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + (tP.live + 1) + '‚Üí' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
              toast('Bezahlt', 'Stage Dive ignoriert.');
            } else {
              tP.forcedStay = true;
              log('bad','Stage Dive: <b>' + esc(tP.name) + '</b> muss beim n√§chsten Entscheid <b>Bleib</b> w√§hlen (sofern er noch aktiv ist). Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
              toast('Stage Dive', 'Du musst drin bleiben.');
            }
            doneCb();
          }
        );
        return;
      }

      if (areBotsManual()){
        if (tP.live <= 0){
          tP.forcedStay = true;
          log('bad','Stage Dive: <b>' + esc(tP.name) + '</b> muss beim n√§chsten Entscheid <b>Bleib</b> w√§hlen (sofern er noch aktiv ist). Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
          doneCb();
          return;
        }
        askYesNo(
          'Stage Dive ‚Äì ' + tP.name + ' zahlen?',
          '<b>' + esc(tP.name) + '</b> ist Ziel. Soll 1 Live gezahlt werden?',
          '1 Live zahlen',
          'Nicht zahlen',
          function(use){
            if (use){
              tP.live = Math.max(0, tP.live - 1);
              log('good', esc(tP.name) + ' zahlt 1 Live ‚Üí ignoriert Stage Dive. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + (tP.live + 1) + '‚Üí' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
            } else {
              tP.forcedStay = true;
              log('bad','Stage Dive: <b>' + esc(tP.name) + '</b> muss beim n√§chsten Entscheid <b>Bleib</b> w√§hlen (sofern er noch aktiv ist). Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
            }
            doneCb();
          }
        );
        return;
      }

      if (tP.live > 0 && botStageDivePay(targetIdx)){
        tP.live = Math.max(0, tP.live - 1);
        log('good', esc(tP.name) + ' zahlt 1 Live ‚Üí ignoriert Stage Dive. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + (tP.live + 1) + '‚Üí' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
        doneCb();
        return;
      }

      tP.forcedStay = true;
      log('bad','Stage Dive: <b>' + esc(tP.name) + '</b> muss beim n√§chsten Entscheid <b>Bleib</b> w√§hlen (sofern er noch aktiv ist). Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + tP.live + ' ¬∑ Camp ' + tP.camp + '.');
      doneCb();
    }

    function applyEncore(rev, card, cb){
      var p = state.players[rev];
      var canPay = p.live >= 1;

      function proceed(stop){
        if (stop){
          p.live = Math.max(0, p.live - 1);
          log('good','<b>' + esc(p.name) + '</b> stoppt üé§ <b>Encore!</b> durch Zahlung von 1 Live. (Live jetzt ' + p.live + ')');
          toast('Encore gestoppt', p.name + ' zahlt 1 Live.');
          state.encoreChain = 0;
          cb(false);
          return;
        }
        log('warn','üé§ <b>Encore!</b> l√§uft ‚Üí sofort noch ein Event (keine Camp-Entscheidung dazwischen).');
        state.encoreChain = (state.encoreChain || 0) + 1;
        cb(true);
      }

      log('warn','<b>' + esc(p.name) + '</b> deckt üé§ <b>Encore!</b> auf.');

      if (rev === state.humanIndex){
        if (isAutoAll()){
          if (!canPay){
            log('bad','Du hast <b>0 Live</b> ‚Üí du kannst Encore nicht stoppen.');
            proceed(false);
            return;
          }
          proceed(!!botEncoreStop(rev));
          return;
        }

        if (!canPay){
          log('bad','Du hast <b>0 Live</b> ‚Üí du kannst Encore nicht stoppen.');
          proceed(false);
          return;
        }
        askYesNo(
          'Encore! ‚Äì Stoppen?',
          'Encore! w√ºrde ein weiteres Event ausl√∂sen.<br><br>Willst du <b>1 Live</b> zahlen, um Encore zu stoppen?',
          'Stoppen (1 Live)',
          'Weiterlaufen lassen',
          function(use){ proceed(!!use); }
        );
        return;
      }

      if (areBotsManual()){
        if (!canPay){
          log('bad', esc(p.name) + ' hat <b>0 Live</b> ‚Üí Encore kann nicht gestoppt werden.');
          proceed(false);
          return;
        }
        askYesNo(
          'Encore! ‚Äì ' + p.name + ' stoppen?',
          '<b>' + esc(p.name) + '</b> darf Encore stoppen. Willst du 1 Live zahlen?',
          'Stoppen (1 Live)',
          'Weiterlaufen lassen',
          function(use){ proceed(!!use); }
        );
        return;
      }

      if (canPay && botEncoreStop(rev)) proceed(true);
      else proceed(false);
    }

    // ---------- main loop ----------
    function revealEvent(){
      if (state.gameOver) return;
      if (state.awaitingDecision) return;
      if (!state.players.length){
        log('bad','Keine Spieler gefunden ‚Üí Neustart n√∂tig.');
        restart();
        return;
      }
      if (!anyActive()) { endRound('Alle gecampt'); return; }

      var rev = normalizeRevealerIndex();
      state.revealer = rev;
      var revP = state.players[rev];
      if (!revP || revP.roundState !== 'active'){
        var nxt0 = nextActiveFrom(state.revealer, state.direction);
        if (nxt0 === -1) { endRound('Alle gecampt'); return; }
        state.revealer = nxt0;
        rev = nxt0;
        revP = state.players[rev];
      }

      state.turnId += 1;
      setPhase('event');

      var card = draw(1)[0] || null;
      if (!card){
        log('bad','Keine Karte verf√ºgbar ‚Üí Runde endet.');
        endRound('Deck leer');
        return;
      }

      state.lastEvent = card;
      setEventCard(card);
      updateUI();

      log('info','<b>' + esc(revP.name) + '</b> deckt auf: <b>' + esc(card.name) + '</b>.');

      var roundResetId = state.roundResetId;
      resolveEventCard(rev, card, function(){
        if (state.gameOver || state.roundResetId !== roundResetId) { updateUI(); return; }

        resolveCountdownTick();
        if (state.gameOver || state.roundResetId !== roundResetId) { updateUI(); return; }

        ensureDecisionPhase();
        pumpBots();
      });
    }

    function resolveEventCard(rev, card, done){
      var type = card.type;

      if (type === 'push'){
        applyPush(rev, card);
        state.discard.push(card);
        done();
        return;
      }

      if (type === 'stabilize'){
        applyStabilize(rev, card);
        state.discard.push(card);
        done();
        return;
      }

      if (type === 'twist'){
        applyTwist(rev, card, function(){
          if (!card.stage) state.discard.push(card);
          done();
        });
        return;
      }

      if (type === 'encore'){
        state.discard.push(card);
        applyEncore(rev, card, function(shouldChain){
          if (!shouldChain){ done(); return; }
          if (state.gameOver){ done(); return; }

          var next = draw(1)[0] || null;
          if (!next){
            log('bad','Encore wollte ketten, aber keine Karte verf√ºgbar.');
            done();
            return;
          }

          state.lastEvent = next;
          setEventCard(next, 'Encore-Kette');
          updateUI();
          log('warn','Encore-Kette: <b>' + esc(state.players[rev].name) + '</b> deckt sofort noch auf: <b>' + esc(next.name) + '</b>.');

          resolveEventCard(rev, next, done);
        });
        return;
      }

      state.discard.push(card);
      done();
    }

    function applyCampTransfer(p, overloadAtDecision, extraCamp){
      var liveBefore = p.live;
      var campBefore = p.camp;
      var poolBefore = state.pool;
      var poolTake = poolTakeFor(overloadAtDecision, state.pool);
      p.camp += liveBefore + poolTake + extraCamp;
      p.live = 0;
      state.pool = Math.max(0, state.pool - poolTake);
      p.roundState = 'camped';
      return {
        liveBefore: liveBefore,
        campBefore: campBefore,
        poolBefore: poolBefore,
        poolTake: poolTake,
        extraCamp: extraCamp || 0
      };
    }

    function forceCampLastActive(reason){
      var idx = getLastActiveIndex();
      if (idx === -1) return;

      var p = state.players[idx];
      log('warn','<b>Anti-Solo</b>: Nur noch <b>1</b> Spieler aktiv ‚Üí Runde endet sofort.');
      setHeadline('Anti-Solo: letzter Spieler campt', 1600);
      showPlayBanner('warn', 'Anti-Solo: letzter Spieler campt', 1600);
      var pity = (p.live === 0) ? 1 : 0;
      var transfer = applyCampTransfer(p, state.overload, pity);
      log('warn','Anti-Solo: letzter aktiver Spieler <b>' + esc(p.name) + '</b> campt sofort: +' + transfer.liveBefore + ' Live‚ÜíCamp +' + transfer.poolTake + ' Pool‚ÜíCamp +' + transfer.extraCamp + ' Trost => Camp ' + transfer.campBefore + '‚Üí' + p.camp + '. Overload ' + state.overload + ' ¬∑ Pool ' + transfer.poolBefore + '‚Üí' + state.pool + ' ¬∑ Live ' + transfer.liveBefore + '‚Üí0 ¬∑ Camp ' + transfer.campBefore + '‚Üí' + p.camp + '.');
      toast('Runde endet', p.name + ' campt sofort (Anti-Solo).');

      if (checkWin()) { updateUI(); return; }
      endRound(reason || 'Anti-Solo');
    }

    function resolveDecisions(){
      setPhase('event');
      if (state.gameOver) return;
      if (!state.awaitingDecision) return;
      if (!state.players.length){
        log('bad','Keine Spieler gefunden ‚Üí Neustart.');
        restart();
        return;
      }
      // Aufdecker-Index absichern, bevor die Reihenfolge bestimmt wird.
      state.revealer = normalizeRevealerIndex();
      stopDecisionTimer();

      var choices = [];
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (p.roundState !== 'active') continue;

        var choice = 'stay';
        if (i === state.humanIndex){
          if (isAutoAll()){
            choice = botWantsToCamp(i) ? 'camp' : 'stay';
          } else if (p.forcedStay) {
            choice = 'stay';
          } else {
            if (state.humanChoice === 'camp' && p.live <= 0) choice = 'stay';
            else choice = state.humanChoice;
          }
        } else {
          if (areBotsManual()){
            choice = state.botChoices[String(i)] || 'stay';
          } else {
            choice = botWantsToCamp(i) ? 'camp' : 'stay';
          }
          if (p.forcedStay) choice = 'stay';
        }

        if (choice === 'camp' && p.live <= 0) choice = 'stay';
        choices.push({ idx:i, choice:choice, forced:(p.forcedStay && p.roundState === 'active') });
      }

      var parts = [];
      for (var j=0;j<choices.length;j++){
        var label = (choices[j].choice === 'camp') ? 'Camp' : 'Bleib';
        if (choices[j].forced && choices[j].choice === 'stay') label = 'Bleib (Zwang)';
        parts.push(state.players[choices[j].idx].name + ': ' + label);
      }
      log('info','<b>Entscheidung</b> (simultan): ' + esc(parts.join(' ¬∑ ')) + ' ¬∑ Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live/Camp unver√§ndert.');

      for (var x=0;x<choices.length;x++){
        var pl = state.players[choices[x].idx];
        if (pl.forcedStay) pl.forcedStay = false;
      }

      var order = orderFrom(state.revealer, state.direction);
      var campersSet = {};
      for (var k=0;k<choices.length;k++) if (choices[k].choice === 'camp') campersSet[String(choices[k].idx)] = true;

      var anySuccessfulCamp = false;

      for (var o=0;o<order.length;o++){
        var idx = order[o];
        if (!campersSet[String(idx)]) continue;
        var p2 = state.players[idx];
        if (p2.roundState !== 'active') continue;

        if (p2.live <= 0){
          log('warn','<b>' + esc(p2.name) + '</b> wollte campen, hat aber 0 Live ‚Üí bleibt drin. Overload ' + state.overload + ' ¬∑ Pool ' + state.pool + ' ¬∑ Live ' + p2.live + ' ¬∑ Camp ' + p2.camp + '.');
          continue;
        }

        var transfer = applyCampTransfer(p2, state.overload, 0);
        anySuccessfulCamp = true;
        log('warn','<b>' + esc(p2.name) + '</b> campt: +' + transfer.liveBefore + ' (Live‚ÜíCamp) +' + transfer.poolTake + ' (Pool‚ÜíCamp) => Camp ' + transfer.campBefore + '‚Üí' + p2.camp + ', Pool ' + transfer.poolBefore + '‚Üí' + state.pool + '. Overload ' + state.overload + ' ¬∑ Pool ' + transfer.poolBefore + '‚Üí' + state.pool + ' ¬∑ Live ' + transfer.liveBefore + '‚Üí0 ¬∑ Camp ' + transfer.campBefore + '‚Üí' + p2.camp + '.');
      }
      if (anySuccessfulCamp){
        showPlayBanner('good', 'Camp-Aufl√∂sung abgeschlossen', 1200);
      }

      if (!state.countdownActive && anySuccessfulCamp){
        state.countdownActive = true;
        log('warn','<b>Countdown aktiv</b>: Ab jetzt steigt Overload nach jedem Event automatisch um +1.' + (isAggCountdown() ? ' (Aggressiv m√∂glich bei Pool ‚â•3)' : ''));
      }

      state.awaitingDecision = false;
      state.humanChoice = 'stay';

      if (checkWin()) { updateUI(); return; }

      // Anti-Solo
      if (activeCount() === 1){
        updateUI();
        forceCampLastActive('Anti-Solo');
        return;
      }

      if (activeCount() === 0){
        log('good','Alle Spieler sind gecampt ‚Üí Runde endet.');
        endRound('Alle gecampt');
        return;
      }

      if (state.extraRevealSame){
        state.extraRevealSame = false;
        log('info','Setwechsel: <b>' + esc(state.players[state.revealer].name) + '</b> deckt noch einmal auf.');
      } else {
        var nxt = nextActiveFrom(state.revealer, state.direction);
        if (nxt === -1){
          endRound('Alle gecampt');
          return;
        }
        state.revealer = nxt;
      }

      updateUI();
      pumpBots();
    }

    // ---------- bots automation ----------
    function pumpBots(){
      if (state.gameOver) return;
      if (!state.players.length) return;
      state.revealer = normalizeRevealerIndex();

      if (isAutoAll()){
        if (state.askOpen) return;

        if (state.awaitingDecision){
          scheduleAuto(function(){
            if (state.gameOver) return;
            if (!state.awaitingDecision) return;
            if (state.askOpen) return;

            var h = state.players[state.humanIndex];
            if (h && h.roundState === 'active' && !h.forcedStay && h.live > 0){
              state.humanChoice = botWantsToCamp(state.humanIndex) ? 'camp' : 'stay';
            } else {
              state.humanChoice = 'stay';
            }

            resolveDecisions();
          });
          return;
        }

        scheduleAuto(function(){
          if (state.gameOver) return;
          if (state.awaitingDecision) return;
          if (state.askOpen) return;
          revealEvent();
        });
        return;
      }

      stopAutoTimer();

      // Manuell: Bot-Z√ºge laufen automatisch, au√üer Bots werden manuell gesteuert.
      if (!state.awaitingDecision && state.revealer !== state.humanIndex && areBotsAuto()){
        var r = state.revealer;
        if (state.players[r].roundState !== 'active'){
          var nxt = nextActiveFrom(r, state.direction);
          if (nxt === -1){ endRound('Alle gecampt'); return; }
          state.revealer = nxt;
          updateUI();
          r = nxt;
        }

        setTimeout(function(){
          if (state.gameOver || state.awaitingDecision) return;
          if (state.revealer === state.humanIndex) return;
          revealEvent();
        }, 650);
        return;
      }
    }

    // ---------- log copy ----------
    function copyLog(){
      var el = document.getElementById('log');
      var text = (el.innerText || '').trim();
      if (!text){ toast('Log leer', 'Nichts zu kopieren.'); return; }

      if (navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(text)
          .then(function(){ toast('Kopiert','Log wurde in die Zwischenablage kopiert.'); })
          .catch(function(){ fallbackCopy(text); });
        return;
      }
      fallbackCopy(text);
    }

    function fallbackCopy(text){
      var ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand('copy'); toast('Kopiert','Log wurde in die Zwischenablage kopiert.'); }
      catch(e){ toast('Copy fehlgeschlagen','Browser erlaubt keinen Zugriff auf Zwischenablage.'); }
      document.body.removeChild(ta);
    }

    // ---------- patch notes modal ----------
    function openPatchNotes(){
      var back = document.getElementById('pnBack');
      var body = document.getElementById('pnBody');

      var html = '';
      for (var i=0;i<PATCH_NOTES.length;i++){
        var p = PATCH_NOTES[i];
        var items = '';
        for (var k=0;k<p.items.length;k++) items += '<li>' + esc(p.items[k]) + '</li>';

        html +=
          '<div style="margin-bottom:12px">' +
            '<div style="display:flex;justify-content:space-between;gap:12px;align-items:baseline">' +
              '<b style="font-weight:950">' + esc(p.ver) + '</b>' +
              '<small style="color:var(--muted)">' + esc(p.date) + '</small>' +
            '</div>' +
            '<ul style="margin:6px 0 0 18px;color:#d6dbea">' + items + '</ul>' +
          '</div>';
      }

      body.innerHTML = html;
      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    function closePatchNotes(){
      var back = document.getElementById('pnBack');
      back.style.display = 'none';
      back.setAttribute('aria-hidden','true');
    }

    function openRules(){
      var back = document.getElementById('rulesBack');
      if (!back) return;
      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    function closeRules(){
      var back = document.getElementById('rulesBack');
      if (!back) return;
      back.style.display = 'none';
      back.setAttribute('aria-hidden','true');
    }

    function togglePlayLog(forceOpen){
      var drawer = document.getElementById('playLogDrawer');
      if (!drawer) return;
      var shouldOpen = (typeof forceOpen === 'boolean') ? forceOpen : !drawer.classList.contains('open');
      drawer.classList.toggle('open', shouldOpen);
      drawer.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
    }

    // ---------- self tests ----------
    function shouldRunSelfTests(){
      // Selbsttests nur explizit per URL aktivieren, damit Logs/UI nicht im Normalbetrieb beeinflusst werden.
      return window.location.search.indexOf('selftest=1') !== -1;
    }

    function runSelfTests(){
      var results = [];
      function ok(name, cond){ results.push({ name:name, pass:!!cond }); }

      ok('DOM: #players existiert', !!document.getElementById('players'));
      ok('Deck: mkDeck() hat 60 Karten', mkDeck().length === 60);

      // Katastrophen-Check non-push -> overload 10
      (function(){
        var oldDeck = state.deck.slice();
        var oldDiscard = state.discard.slice();
        var oldOver = state.overload;
        var oldPlayers = state.players.slice();
        var oldGO = state.gameOver;

        // minimal players, damit doKnall/Logs nicht crashen
        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'active', forcedStay:false }
        ];

        state.deck = [{ type:'stabilize', name:'X', delta:-2 }];
        state.discard = [];
        state.overload = 12;
        state.gameOver = false;
        catastropheCheck();
        ok('Katastrophen-Check non-push -> overload 10', state.overload === OVERLOAD_RESET_AFTER_CHECK);

        // Katastrophen-Check discard pushed
        state.deck = [{ type:'push', name:'Y', delta:1 }];
        state.discard = [];
        state.overload = 12;
        state.gameOver = true; // verhindert endRound-Kaskade
        catastropheCheck();
        ok('Katastrophen-Check discard pushed', state.discard.length === 1);

        state.deck = oldDeck;
        state.discard = oldDiscard;
        state.overload = oldOver;
        state.players = oldPlayers;
        state.gameOver = oldGO;
      })();

      // Stabilisieren-Ertrag nur bei 8+ vorher
      (function(){
        var oldOver = state.overload;
        var oldPlayers = state.players.slice();
        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'active', forcedStay:false }
        ];

        state.overload = 7;
        applyStabilize(0, { type:'stabilize', name:'Test', delta:-2, text:'' });
        ok('Stabilisieren: bei Overload 7 vorher kein Live-Ertrag', state.players[0].live === 0);

        state.overload = 8;
        applyStabilize(0, { type:'stabilize', name:'Test', delta:-2, text:'' });
        ok('Stabilisieren: bei Overload 8 vorher +1 Live-Ertrag', state.players[0].live === 1);

        state.overload = oldOver;
        state.players = oldPlayers;
      })();

      // Anti-Solo: letzter Spieler camped inkl. Pool-Bonus und Trostpunkt
      (function(){
        var oldPlayers = state.players.slice();
        var oldPool = state.pool;
        var oldOver = state.overload;
        var oldGO = state.gameOver;

        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'camped', forcedStay:false }
        ];
        state.pool = 3;
        state.overload = 8;
        state.gameOver = false;
        forceCampLastActive('Test');
        ok('Anti-Solo: Pool-Take wird genommen', state.pool === 1);
        ok('Anti-Solo: Trostpunkt greift', state.players[0].camp === 3);

        state.players = oldPlayers;
        state.pool = oldPool;
        state.overload = oldOver;
        state.gameOver = oldGO;
      })();

      // Mini-Testlauf (Seeded RNG): Nach RoundReset keine Entscheidung ohne Event.
      (function(){
        var oldRand = Math.random;
        var seed = 1337;
        Math.random = function(){
          seed = (seed * 1664525 + 1013904223) % 4294967296;
          return seed / 4294967296;
        };

        var oldState = {
          deck: state.deck.slice(),
          discard: state.discard.slice(),
          players: state.players.slice(),
          overload: state.overload,
          pool: state.pool,
          round: state.round,
          awaitingDecision: state.awaitingDecision,
          humanChoice: state.humanChoice,
          humanLockedIn: state.humanLockedIn,
          lastEvent: state.lastEvent,
          phase: state.phase,
          roundResetId: state.roundResetId,
          gameOver: state.gameOver,
          turnId: state.turnId,
          startPlayer: state.startPlayer,
          revealer: state.revealer,
          direction: state.direction,
          extraRevealSame: state.extraRevealSame,
          stageRule: state.stageRule,
          countdownActive: state.countdownActive,
          encoreChain: state.encoreChain,
          botChoices: state.botChoices
        };

        state.players = [
          { name:'Du', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:1, roundState:'active', forcedStay:false }
        ];
        state.overload = 11;
        state.pool = 0;
        state.round = 1;
        state.awaitingDecision = false;
        state.humanChoice = 'stay';
        state.humanLockedIn = false;
        state.lastEvent = null;
        state.phase = 'reveal';
        state.roundResetId = 0;
        state.gameOver = false;
        state.turnId = 0;
        state.startPlayer = 0;
        state.revealer = 0;
        state.direction = 1;
        state.extraRevealSame = false;
        state.stageRule = null;
        state.countdownActive = false;
        state.encoreChain = 0;
        state.botChoices = {};
        state.deck = [
          { type:'push', name:'Check', delta:1, text:'' },
          { type:'push', name:'Test-Push', delta:1, text:'' }
        ];
        state.discard = [];

        revealEvent();

        ok('Mini-Test: RoundReset blockt Entscheidung ohne Event',
          !state.awaitingDecision && state.phase === 'reveal' && state.lastEvent === null);

        state.deck = oldState.deck;
        state.discard = oldState.discard;
        state.players = oldState.players;
        state.overload = oldState.overload;
        state.pool = oldState.pool;
        state.round = oldState.round;
        state.awaitingDecision = oldState.awaitingDecision;
        state.humanChoice = oldState.humanChoice;
        state.humanLockedIn = oldState.humanLockedIn;
        state.lastEvent = oldState.lastEvent;
        state.phase = oldState.phase;
        state.roundResetId = oldState.roundResetId;
        state.gameOver = oldState.gameOver;
        state.turnId = oldState.turnId;
        state.startPlayer = oldState.startPlayer;
        state.revealer = oldState.revealer;
        state.direction = oldState.direction;
        state.extraRevealSame = oldState.extraRevealSame;
        state.stageRule = oldState.stageRule;
        state.countdownActive = oldState.countdownActive;
        state.encoreChain = oldState.encoreChain;
        state.botChoices = oldState.botChoices;
        Math.random = oldRand;
      })();

      window.FestivalOverloadTests = results;
      try {
        var failed = 0;
        for (var i=0;i<results.length;i++) if (!results[i].pass) failed++;
        if (failed) console.warn('FestivalOverloadTests: FAIL', results);
        else console.log('FestivalOverloadTests: OK', results);
      } catch(e){}
    }

    // ---------- init / restart ----------
    function restart(){
      stopDecisionTimer();
      if (state.uiHeadlineTimer) clearTimeout(state.uiHeadlineTimer);
      if (state.playBannerTimer) clearTimeout(state.playBannerTimer);
      state.uiHeadlineTimer = null;
      state.playBannerTimer = null;
      state.round = 1;
      state.overload = 0;
      state.pool = 0;
      state.uiHeadline = null;
      state.stageRule = null;
      state.countdownActive = false;
      state.direction = 1;
      state.startPlayer = 0;
      state.revealer = 0;
      state.extraRevealSame = false;
      state.botProfileId = botProfilePick();
      state.botCount = clampBotCount(state.botCount || 3);

      state.deck = mkDeck();
      state.discard = [];

      state.players = buildPlayers(state.botCount);

      state.awaitingDecision = false;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.lastEvent = null;
      state.gameOver = false;
      state.turnId = 0;
      state.encoreChain = 0;
      state.botChoices = {};
      state.askOpen = false;
      state.roundResetId = 0;
      var askBack = document.getElementById('askBack');
      if (askBack){
        askBack.style.display = 'none';
        askBack.setAttribute('aria-hidden','true');
      }

      state.phase = 'reveal';
      state.lastSummary = null;

      document.getElementById('log').innerHTML = '';
      var playLog = document.getElementById('logPlay');
      if (playLog) playLog.innerHTML = '';
      togglePlayLog(false);
      setEventCard(null);
      setSummary('Bereit',
        [
          { cls:'blue', sym:'‚ñ∂', text:'Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten' },
          { cls:'warn', sym:'üèÅ', text:'Ziel: ' + WIN_CAMP + ' Camp' },
          { cls:'good', sym:'üõ†Ô∏è', text:'Stabilisieren gibt Ertrag nur bei Overload 8+ (vor dem Senken)' }
        ],
        'Runde 1 beginnt'
      );
      log('info','Prototyp gestartet. Ziel: <b>' + WIN_CAMP + '</b> Camp. Runde 1 ‚Äì Startspieler: <b>' + esc(state.players[state.startPlayer].name) + '</b>.');
      setPhase('reveal');
      updateUI();
      pumpBots();
    }

    // ---------- wiring ----------
    document.getElementById('verText').textContent = VERSION;
    document.getElementById('verBtn').onclick = openPatchNotes;
    document.getElementById('pnClose').onclick = closePatchNotes;
    document.getElementById('pnBack').addEventListener('click', function(e){ if (e.target.id === 'pnBack') closePatchNotes(); });

    document.addEventListener('keydown', function(e){
      if (e.key === 'Escape'){
        closePatchNotes();
        closeRules();
        togglePlayLog(false);
        if (state.askOpen){
          var back = document.getElementById('askBack');
          back.style.display = 'none';
          back.setAttribute('aria-hidden','true');
          state.askOpen = false;
        }
      }
    });

    var btnModePlay = document.getElementById('btnModePlay');
    if (btnModePlay) btnModePlay.onclick = function(){ setUiMode('play'); };
    var btnModeDev = document.getElementById('btnModeDev');
    if (btnModeDev) btnModeDev.onclick = function(){ setUiMode('dev'); };
    var btnPlayPreview = document.getElementById('btnPlayPreview');
    if (btnPlayPreview) btnPlayPreview.onclick = function(){ setUiMode('play'); };

    var btnReveal = document.getElementById('btnReveal');
    if (btnReveal) btnReveal.onclick = function(){ revealEvent(); };
    var btnRevealPlay = document.getElementById('btnRevealPlay');
    if (btnRevealPlay) btnRevealPlay.onclick = function(){ revealEvent(); };
    var btnRestart = document.getElementById('btnRestart');
    if (btnRestart) btnRestart.onclick = function(){ restart(); };
    var btnLog = document.getElementById('btnLog');
    if (btnLog){
      btnLog.onclick = function(){
        if (window.matchMedia('(max-width:1150px)').matches){
          document.body.classList.toggle('logOpen');
        } else {
          document.body.classList.toggle('logHidden');
        }
      };
    }
    var btnCopyLog = document.getElementById('btnCopyLog');
    if (btnCopyLog) btnCopyLog.onclick = copyLog;
    var btnPlayLog = document.getElementById('btnPlayLog');
    if (btnPlayLog) btnPlayLog.onclick = function(){ togglePlayLog(); };
    var btnPlayLogClose = document.getElementById('btnPlayLogClose');
    if (btnPlayLogClose) btnPlayLogClose.onclick = function(){ togglePlayLog(false); };
    var btnPlayRules = document.getElementById('btnPlayRules');
    if (btnPlayRules) btnPlayRules.onclick = openRules;
    var rulesClose = document.getElementById('rulesClose');
    if (rulesClose) rulesClose.onclick = closeRules;
    var rulesBack = document.getElementById('rulesBack');
    if (rulesBack) rulesBack.addEventListener('click', function(e){ if (e.target.id === 'rulesBack') closeRules(); });

    var botProfileSelect = document.getElementById('optBotProfile');
    if (botProfileSelect){
      botProfileSelect.innerHTML = '';
      for (var i=0;i<BOT_MODULES.length;i++){
        var opt = document.createElement('option');
        opt.value = BOT_MODULES[i].id;
        opt.textContent = BOT_MODULES[i].name;
        botProfileSelect.appendChild(opt);
      }
      botProfileSelect.value = state.botProfileId;
      botProfileSelect.onchange = function(){
        applyBotProfileToBots(botProfilePick());
        updateUI();
      };
    }

    var optControlMode = document.getElementById('optControlMode');
    if (optControlMode) optControlMode.onchange = function(){ updateUI(); pumpBots(); };
    var optSpeed = document.getElementById('optSpeed');
    if (optSpeed) optSpeed.onchange = function(){ pumpBots(); };
    var optAggCountdown = document.getElementById('optAggCountdown');
    if (optAggCountdown) optAggCountdown.onchange = function(){ updateUI(); };
    var optDecisionTimer = document.getElementById('optDecisionTimer');
    if (optDecisionTimer){
      optDecisionTimer.onchange = function(){
        updateUI();
        if (state.awaitingDecision) startDecisionTimer();
      };
    }
    var btnAddBot = document.getElementById('btnAddBot');
    if (btnAddBot) btnAddBot.onclick = addBot;
    var btnRemoveBot = document.getElementById('btnRemoveBot');
    if (btnRemoveBot) btnRemoveBot.onclick = removeBot;

    var btnStay = document.getElementById('btnStay');
    if (btnStay) btnStay.onclick = function(){ state.humanChoice = 'stay'; state.humanLockedIn = true; updateUI(); };
    var btnCamp = document.getElementById('btnCamp');
    if (btnCamp) btnCamp.onclick = function(){ state.humanChoice = 'camp'; state.humanLockedIn = true; updateUI(); };
    var btnResolve = document.getElementById('btnResolve');
    if (btnResolve) btnResolve.onclick = function(){ resolveDecisions(); };

    // init
    if (shouldRunSelfTests()){
      runSelfTests();
    }
    restart();
    setUiMode('play');
  })();
  </script>
</body>
</html>
