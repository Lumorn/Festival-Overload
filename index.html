<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Festival Overload ‚Äì spielbarer Prototyp (Simultan Camp/Bleib)</title>
  <style>
    :root{
      --bg1:#050812; --bg2:#0b1020; --bg3:#060812;
      --panel:rgba(20,27,42,.92);
      --panel2:rgba(11,15,23,.55);
      --stroke:rgba(148,163,184,.16);
      --stroke2:rgba(148,163,184,.22);
      --muted:#9aa8c1;
      --mutedStrong:#b4c0d8;
      --text:#e8edf7;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --chip:rgba(31,42,68,.92);
      --shadow:0 12px 38px rgba(0,0,0,.45);
      --blue:#60a5fa;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    html, body{height:100%}
    body{margin:0;color:var(--text);background:
      radial-gradient(900px 380px at 10% 0%, rgba(99,102,241,.20), transparent 55%),
      radial-gradient(700px 320px at 80% 8%, rgba(34,197,94,.18), transparent 55%),
      radial-gradient(800px 360px at 30% 90%, rgba(245,158,11,.14), transparent 55%),
      linear-gradient(180deg,var(--bg1), var(--bg2) 45%, var(--bg3));
      overflow:hidden;
    }

    .wrap{max-width:1400px;margin:0 auto;padding:14px;height:100%;display:flex;flex-direction:column;gap:12px}

    .devOnly{display:block}
    .playOnly{display:none}
    body.ui-play .devOnly{display:none}
    body.ui-play .playOnly{display:block}
    body.ui-dev .devOnly{display:block}
    body.ui-dev .playOnly{display:none}

    .topBar{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      border-radius:16px;
      background:rgba(11,15,23,.55);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      min-height:64px;
    }
    .topLeft{display:flex;align-items:center;gap:12px}
    .topCenter{text-align:center}
    .topRight{display:flex;justify-content:flex-end;align-items:center;gap:10px;flex-wrap:wrap}
    .gameTitle{display:flex;flex-direction:column;gap:2px}
    .gameTitle b{font-size:16px;letter-spacing:.2px}
    .gameTitle span{font-size:12px;color:var(--mutedStrong)}
    .playTitle{font-size:13px;color:var(--mutedStrong);font-weight:700;letter-spacing:.25px}
    .playTitle b{color:var(--text)}
    .roundEvent{font-size:16px;font-weight:900;letter-spacing:.2px}
    .roundEvent small{display:block;font-size:12px;color:var(--mutedStrong);font-weight:500}
    .statusHeadline{font-size:24px;font-weight:950;letter-spacing:.3px}
    .roundBadge{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:999px;background:rgba(31,42,68,.7);border:1px solid rgba(148,163,184,.18);font-size:12px;position:relative}
    .goalChip{padding:6px 10px;border-radius:999px;background:rgba(34,197,94,.16);border:1px solid rgba(34,197,94,.38);font-size:12px;font-weight:700}
    .statusIcons{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .statusChip{display:none;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.18);background:rgba(31,42,68,.6);font-size:12px}
    .statusChip.active{display:inline-flex}
    .statusChip.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .statusChip.blue{border-color:rgba(96,165,250,.4);background:rgba(96,165,250,.12)}
    .statusChip.bad{border-color:rgba(239,68,68,.4);background:rgba(239,68,68,.12)}
    .modeToggle{display:inline-flex;gap:6px}
    .modeToggle .btn.active{border-color:rgba(226,232,240,.45);background:rgba(255,255,255,.08);font-weight:800}

    h1{margin:0;font-size:20px;letter-spacing:.2px}
    .sub{color:var(--mutedStrong);font-size:14px;max-width:920px;line-height:1.45}

    .ver{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:14px;
      background:rgba(31,42,68,.55);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      cursor:pointer;
      user-select:none;
      transition:.12s transform,.12s border-color,.12s filter;
    }
    .ver:hover{transform:translateY(-1px);border-color:rgba(226,232,240,.35);filter:brightness(1.03)}
    .ver b{font-weight:900}

    .grid{display:grid;grid-template-columns:1.4fr .9fr;gap:12px;flex:1;min-height:0}
    .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;padding:12px;box-shadow:var(--shadow);min-height:0;display:flex;flex-direction:column;gap:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .pill{background:var(--chip);border:1px solid var(--stroke2);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--text);position:relative}
    .pill b{font-weight:800}
    .pill.good{border-color:rgba(34,197,94,.35)}
    .pill.warn{border-color:rgba(245,158,11,.35)}
    .pill.bad{border-color:rgba(239,68,68,.35)}
    .pill.blue{border-color:rgba(96,165,250,.35)}
    .big{font-size:14px}

    .bar{height:12px;background:rgba(148,163,184,.14);border-radius:999px;overflow:hidden;border:1px solid var(--stroke2);position:relative}
    .bar > div{height:100%;background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444);width:0%;transition:width .18s ease}
    .bar:after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}

    .tableau{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:10px}
    .stack{
      background:rgba(11,15,23,.35);
      border:1px solid rgba(148,163,184,.12);
      border-radius:16px;
      padding:10px;
      min-height:160px;
      position:relative;
      overflow:hidden;
    }
    .stackTitle{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:12px}
    .stackTitle b{color:var(--text)}
    .cardStack{position:relative;height:110px;margin-top:8px}
    .cardStack.empty{opacity:.45}
    .cardBack{
      position:absolute;inset:0;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.22);
      background:
        linear-gradient(135deg, rgba(99,102,241,.22), rgba(15,23,42,.85)),
        radial-gradient(180px 120px at 20% 20%, rgba(255,255,255,.08), transparent 60%);
      box-shadow:0 12px 28px rgba(0,0,0,.35);
    }
    .cardBack.layer2{transform:translate(6px,6px);opacity:.75}
    .cardBack.layer3{transform:translate(12px,12px);opacity:.5}
    .cardBack.discard{
      background:
        linear-gradient(135deg, rgba(239,68,68,.18), rgba(15,23,42,.85)),
        radial-gradient(180px 120px at 20% 20%, rgba(255,255,255,.06), transparent 60%);
    }

    .cardFace{
      position:relative;
      height:110px;
      border-radius:14px;
      padding:10px;
      border:1px solid rgba(148,163,184,.22);
      background:
        radial-gradient(140px 90px at 20% 20%, rgba(255,255,255,.12), transparent 60%),
        rgba(31,42,68,.78);
      box-shadow:0 14px 30px rgba(0,0,0,.4);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .cardFace:before{
      content:"";
      position:absolute;left:0;right:0;top:0;height:8px;
      background:rgba(148,163,184,.35);
    }
    .cardFace[data-type="push"]:before{background:rgba(239,68,68,.85)}
    .cardFace[data-type="stabilize"]:before{background:rgba(34,197,94,.85)}
    .cardFace[data-type="twist"]:before{background:rgba(245,158,11,.85)}
    .cardFace[data-type="encore"]:before{background:rgba(96,165,250,.85)}
    .cardFace[data-type="empty"]:before{background:rgba(148,163,184,.35)}

    .rTop{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-top:6px}
    .rName{font-weight:900;font-size:12px}
    .rType{font-size:11px;color:#d6dbea}
    .rText{font-size:11px;color:#d6dbea;line-height:1.28}

    .hint{color:var(--mutedStrong);font-size:12px;margin-top:10px;line-height:1.45}
    .mini{font-size:12px;color:var(--mutedStrong);line-height:1.45}
    .sep{height:1px;background:rgba(148,163,184,.14);margin:10px 0}

    .players{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .p{background:var(--panel2);border:1px solid rgba(148,163,184,.14);border-radius:14px;padding:10px}
    .p .name{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;gap:10px}
    .tag{font-size:11px;color:var(--muted)}
    .turn{color:#fff;background:rgba(34,197,94,.18);border:1px solid rgba(34,197,94,.35);padding:2px 8px;border-radius:999px;font-size:11px;white-space:nowrap}
    .camped{color:#fff;background:rgba(245,158,11,.18);border:1px solid rgba(245,158,11,.35);padding:2px 8px;border-radius:999px;font-size:11px;white-space:nowrap}

    .eventWrap{
      margin-top:8px;
      padding:12px;
      background:rgba(11,15,23,.35);
      border:1px solid rgba(148,163,184,.12);
      border-radius:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .eventCard{
      position:relative;
      border-radius:18px;
      padding:12px 12px 14px;
      border:1px solid rgba(148,163,184,.22);
      box-shadow:0 14px 34px rgba(0,0,0,.38);
      background:
        radial-gradient(180px 110px at 18% 16%, rgba(255,255,255,.10), transparent 60%),
        radial-gradient(220px 120px at 90% 10%, rgba(99,102,241,.18), transparent 62%),
        radial-gradient(240px 140px at 20% 110%, rgba(34,197,94,.10), transparent 62%),
        rgba(31,42,68,.75);
      min-height:118px;
      overflow:hidden;
    }
    .eventCard:before{
      content:"";
      position:absolute;inset:0;
      background:
        linear-gradient(120deg, rgba(255,255,255,.10), transparent 35%, rgba(255,255,255,.06) 55%, transparent 72%),
        radial-gradient(420px 180px at 20% 0%, rgba(255,255,255,.07), transparent 55%);
      opacity:.75;
      pointer-events:none;
    }
    .eventCard:after{
      content:"";
      position:absolute;inset:7px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      pointer-events:none;
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.18);
    }
    .stripe{position:absolute;left:0;top:0;right:0;height:8px;background:rgba(148,163,184,.35);box-shadow:0 10px 24px rgba(0,0,0,.18)}
    .eventCard[data-type="push"] .stripe{background:rgba(239,68,68,.85)}
    .eventCard[data-type="stabilize"] .stripe{background:rgba(34,197,94,.85)}
    .eventCard[data-type="twist"] .stripe{background:rgba(245,158,11,.85)}
    .eventCard[data-type="encore"] .stripe{background:rgba(96,165,250,.85)}

    .kTop{display:flex;justify-content:space-between;align-items:center;margin-top:6px;margin-bottom:10px;gap:10px;position:relative;z-index:2}
    .kName{font-weight:950;letter-spacing:.2px}
    .kType{display:inline-flex;align-items:center;gap:6px;font-size:11px;color:#d7deee;white-space:nowrap}
    .dot{width:8px;height:8px;border-radius:999px;display:inline-block}
    .kText{font-size:12px;color:#d6dbea;line-height:1.28;position:relative;z-index:2}

    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:0;justify-content:flex-end}
    .btn{background:rgba(148,163,184,.10);border:1px solid rgba(148,163,184,.22);border-radius:14px;padding:10px 12px;color:var(--text);cursor:pointer;transition:.12s transform,.12s border-color}
    .btn:hover{transform:translateY(-1px);border-color:rgba(226,232,240,.35)}
    .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
    .btn.warn{background:rgba(245,158,11,.16);border-color:rgba(245,158,11,.32)}
    .btn.bad{background:rgba(239,68,68,.14);border-color:rgba(239,68,68,.32)}
    .btn.good{background:rgba(34,197,94,.14);border-color:rgba(34,197,94,.32)}
    .btn.blue{background:rgba(96,165,250,.14);border-color:rgba(96,165,250,.32)}
    .btn.slim{padding:8px 10px;border-radius:12px;font-size:12px}

    .decision{
      margin-top:0;
      display:none;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(245,158,11,.10);
      border:1px solid rgba(245,158,11,.25);
    }
    .decision b{font-weight:950}
    .decisionRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}
    .choice{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

    .logWrap{display:flex;flex-direction:column;gap:8px;min-height:0}
    .logHead{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .logActions{display:flex;gap:8px;align-items:center}
    .log{flex:1;min-height:240px;overflow:auto;background:rgba(16,22,35,.65);border:1px solid rgba(148,163,184,.18);border-radius:14px;padding:12px;font-size:13px;line-height:1.5}
    .log .t{color:var(--muted)}
    .playLog .t{color:var(--muted)}
    .log .evt{padding:8px 10px;border-radius:12px;border:1px solid rgba(148,163,184,.16);background:rgba(0,0,0,.18);margin-bottom:8px;box-shadow:0 10px 22px rgba(0,0,0,.18)}
    .log .evt.good{border-color:rgba(34,197,94,.22);background:rgba(34,197,94,.06)}
    .log .evt.warn{border-color:rgba(245,158,11,.22);background:rgba(245,158,11,.06)}
    .log .evt.bad{border-color:rgba(239,68,68,.22);background:rgba(239,68,68,.06)}
    .log .evt.info{border-color:rgba(99,102,241,.18);background:rgba(99,102,241,.05)}
    .playLog .evt{padding:8px 10px;border-radius:12px;border:1px solid rgba(148,163,184,.16);background:rgba(0,0,0,.18);margin-bottom:8px;box-shadow:0 10px 22px rgba(0,0,0,.18)}
    .playLog .evt.good{border-color:rgba(34,197,94,.22);background:rgba(34,197,94,.06)}
    .playLog .evt.warn{border-color:rgba(245,158,11,.22);background:rgba(245,158,11,.06)}
    .playLog .evt.bad{border-color:rgba(239,68,68,.22);background:rgba(239,68,68,.06)}
    .playLog .evt.info{border-color:rgba(99,102,241,.18);background:rgba(99,102,241,.05)}

    .toggle{display:flex;gap:10px;align-items:flex-end;flex-wrap:wrap;justify-content:flex-end}
    .botControls{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    input[type=checkbox]{transform:scale(1.08)}
    select{background:rgba(148,163,184,.10);color:var(--text);border:1px solid rgba(148,163,184,.22);border-radius:10px;padding:6px 8px}

    .toast{position:fixed;left:18px;bottom:18px;max-width:520px;padding:10px 12px;border-radius:14px;background:rgba(31,42,68,.92);border:1px solid rgba(148,163,184,.22);color:var(--text);box-shadow:var(--shadow);display:none;z-index:80}
    .toast small{color:var(--muted)}

    .modalBack{
      position:fixed;inset:0;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:90;
      padding:18px;
    }
    .modal{
      width:min(720px, 100%);
      background:rgba(20,27,42,.97);
      border:1px solid rgba(148,163,184,.22);
      border-radius:18px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalTop{
      display:flex;justify-content:space-between;align-items:center;gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(148,163,184,.14);
      background:rgba(11,15,23,.35);
    }
    .modalTop b{font-weight:950}
    .modalBody{padding:12px 14px;max-height:62vh;overflow:auto}

    .confirmText{color:#d6dbea;line-height:1.35}
    .confirmBtns{display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;margin-top:12px}

    .pickList{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .pickBtn{width:100%;text-align:left}

    code{color:#d6dbea}

    /* --- UX: Phase + Steps + Summary --- */
    .steps{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .step{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(31,42,68,.45);border:1px solid rgba(148,163,184,.14);font-size:12px;color:var(--muted);user-select:none}
    .step .n{width:18px;height:18px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;background:rgba(148,163,184,.16);border:1px solid rgba(148,163,184,.18);color:var(--text);font-weight:900;font-size:11px}
    .step.active{color:var(--text);border-color:rgba(226,232,240,.35);background:rgba(31,42,68,.85);box-shadow:0 8px 20px rgba(0,0,0,.25)}
    .step.active .n{background:rgba(99,102,241,.32);border-color:rgba(99,102,241,.45)}
    .steps.compact{gap:6px;margin-top:6px}
    .steps.compact .step{padding:4px 8px;font-size:11px}
    .steps.compact .step .n{width:16px;height:16px;font-size:10px}

    /* Spielmodus: kompakte Phasenleiste */
    .playSteps{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .playSteps .step{padding:4px 8px;font-size:11px;border-radius:999px;background:rgba(31,42,68,.35);border:1px solid rgba(148,163,184,.12);color:var(--mutedStrong)}
    .playSteps .step .n{width:16px;height:16px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;background:rgba(148,163,184,.16);border:1px solid rgba(148,163,184,.18);color:var(--text);font-weight:900;font-size:10px}
    .playSteps .step.active{color:var(--text);border-color:rgba(226,232,240,.3);background:rgba(31,42,68,.7);box-shadow:0 8px 18px rgba(0,0,0,.22)}
    .playSteps .step.active .n{background:rgba(99,102,241,.28);border-color:rgba(99,102,241,.38)}

    .banner{display:none;margin-top:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(148,163,184,.14);background:rgba(31,42,68,.35);box-shadow:0 10px 28px rgba(0,0,0,.25)}
    .banner.show{display:block}
    .banner.good{border-color:rgba(34,197,94,.30);background:rgba(34,197,94,.06)}
    .banner.warn{border-color:rgba(245,158,11,.30);background:rgba(245,158,11,.06)}
    .banner.bad{border-color:rgba(239,68,68,.30);background:rgba(239,68,68,.06)}
    .banner b{font-weight:950}
    .banner small{color:var(--muted)}

    .eventSummary{margin-top:10px;padding:10px 12px;border-radius:14px;background:rgba(31,42,68,.45);border:1px solid rgba(148,163,184,.14)}
    .sumTitle{display:flex;justify-content:space-between;align-items:baseline;gap:10px}
    .sumRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .dChip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.10);border:1px solid rgba(148,163,184,.14);font-size:12px}
    .dChip.good{border-color:rgba(34,197,94,.30)}
    .dChip.warn{border-color:rgba(245,158,11,.30)}
    .dChip.bad{border-color:rgba(239,68,68,.30)}
    .dChip.blue{border-color:rgba(96,165,250,.30)}
    .dChip .sym{opacity:.95}

    .bar .tick{position:absolute;top:-22px;transform:translateX(-50%);font-size:11px;color:var(--muted);padding:2px 6px;border-radius:999px;background:rgba(0,0,0,.16);border:1px solid rgba(148,163,184,.14)}
    .bar .tick:after{content:"";position:absolute;left:50%;top:100%;width:1px;height:16px;background:rgba(148,163,184,.18)}
    .bar .t8{left:66.6667%}
    .bar .t12{left:100%}

    .decide{color:#fff;background:rgba(96,165,250,.18);border:1px solid rgba(96,165,250,.35);padding:2px 8px;border-radius:999px;font-size:11px;white-space:nowrap}

    .p.turnGlow{border-color:rgba(34,197,94,.35);box-shadow:0 0 0 1px rgba(34,197,94,.18), 0 12px 34px rgba(0,0,0,.25)}
    .p.decideGlow{border-color:rgba(245,158,11,.35);box-shadow:0 0 0 1px rgba(245,158,11,.16), 0 12px 34px rgba(0,0,0,.22)}
    .p.campedDim{opacity:.78}

    /* --- Visual Clarity Patch: Feedback, Deltas, Impact --- */
    .pill:focus{outline:none}

    .deltaBadge{
      position:absolute;right:-8px;top:-8px;
      display:none;
      align-items:center;justify-content:center;
      padding:3px 7px;
      border-radius:999px;
      font-size:11px;
      font-weight:950;
      letter-spacing:.15px;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(31,42,68,.92);
      box-shadow:0 12px 34px rgba(0,0,0,.35);
      transform:translateY(0) scale(.98);
      opacity:0;
      pointer-events:none;
      z-index:5;
    }

    @keyframes popBadge{
      0%{opacity:0;transform:translateY(4px) scale(.95)}
      18%{opacity:1;transform:translateY(0) scale(1)}
      100%{opacity:0;transform:translateY(-4px) scale(.98)}
    }

    @keyframes statPulse{
      0%{box-shadow:0 0 0 0 rgba(255,255,255,0)}
      40%{box-shadow:0 0 0 3px rgba(255,255,255,.06), 0 16px 46px rgba(0,0,0,.34)}
      100%{box-shadow:0 0 0 0 rgba(255,255,255,0)}
    }

    .flash-good{border-color:rgba(34,197,94,.45)!important;animation:statPulse .55s ease}
    .flash-warn{border-color:rgba(245,158,11,.45)!important;animation:statPulse .55s ease}
    .flash-bad{border-color:rgba(239,68,68,.50)!important;animation:statPulse .55s ease}
    .flash-blue{border-color:rgba(96,165,250,.50)!important;animation:statPulse .55s ease}

    .flash-good .deltaBadge{display:inline-flex;border-color:rgba(34,197,94,.45);background:rgba(34,197,94,.14);animation:popBadge .75s ease}
    .flash-warn .deltaBadge{display:inline-flex;border-color:rgba(245,158,11,.45);background:rgba(245,158,11,.14);animation:popBadge .75s ease}
    .flash-bad  .deltaBadge{display:inline-flex;border-color:rgba(239,68,68,.55);background:rgba(239,68,68,.12);animation:popBadge .75s ease}
    .flash-blue .deltaBadge{display:inline-flex;border-color:rgba(96,165,250,.55);background:rgba(96,165,250,.12);animation:popBadge .75s ease}

    /* Pool kleine Stapel-Optik */
    #poolChip::after{
      content:"";
      position:absolute;right:10px;bottom:8px;
      width:18px;height:14px;
      border-radius:4px;
      background:rgba(255,255,255,.05);
      box-shadow:
        -4px -3px 0 0 rgba(255,255,255,.03),
        -8px -6px 0 0 rgba(255,255,255,.02);
      border:1px solid rgba(148,163,184,.16);
      opacity:.9;
      pointer-events:none;
    }

    /* Event Impact Row */
    .impact{display:flex;gap:8px;flex-wrap:wrap;margin:-2px 0 10px;position:relative;z-index:2}
    .imp{display:inline-flex;align-items:center;gap:7px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.14);background:rgba(0,0,0,.12);font-size:12px;color:#e8edf7}
    .imp b{font-weight:950}
    .imp.good{border-color:rgba(34,197,94,.28);background:rgba(34,197,94,.06)}
    .imp.warn{border-color:rgba(245,158,11,.28);background:rgba(245,158,11,.06)}
    .imp.bad{border-color:rgba(239,68,68,.28);background:rgba(239,68,68,.06)}
    .imp.blue{border-color:rgba(96,165,250,.28);background:rgba(96,165,250,.06)}

    /* Spieler: deutlicher Live/Camp als Karten-Icons + Deltazeile */
    .pPills{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pPill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.10);border:1px solid rgba(148,163,184,.14);font-size:12px}
    .pPill b{font-weight:950}
    .ci{width:12px;height:10px;border-radius:3px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);box-shadow:0 6px 18px rgba(0,0,0,.22)}
    .ci.live{transform:rotate(-14deg)}
    .deltaLine{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
    .dTag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid rgba(148,163,184,.14);background:rgba(0,0,0,.10);font-size:11px;color:#d6dbea}
    .dTag.good{border-color:rgba(34,197,94,.28);background:rgba(34,197,94,.05)}
    .dTag.warn{border-color:rgba(245,158,11,.28);background:rgba(245,158,11,.05)}
    .dTag.bad{border-color:rgba(239,68,68,.28);background:rgba(239,68,68,.05)}
    .dTag.blue{border-color:rgba(96,165,250,.28);background:rgba(96,165,250,.05)}

    /* Bildschirm-Flash bei Knall/Sieg */
    body.flashBad::before, body.flashGood::before{
      content:"";position:fixed;inset:0;pointer-events:none;z-index:999;
      background:transparent;
      animation:screenFlash .55s ease;
    }
    body.flashBad::before{background:rgba(239,68,68,.14)}
    body.flashGood::before{background:rgba(34,197,94,.12)}
    @keyframes screenFlash{0%{opacity:0}20%{opacity:1}100%{opacity:0}}

    /* Event Card: kleine Reveal-Animation */
    @keyframes cardPop{0%{transform:translateY(8px) scale(.985);filter:brightness(.96)}40%{transform:translateY(0) scale(1);filter:brightness(1.05)}100%{transform:translateY(0) scale(1);filter:brightness(1)}}
    .eventCard.pop{animation:cardPop .32s ease}

    .mainColumns{display:grid;grid-template-columns:minmax(0,1fr) 360px;gap:12px;align-items:start;min-height:0}
    .sideCard{min-height:0}
    .sideScroll{overflow:auto;min-height:0;display:flex;flex-direction:column;gap:12px}

    .sideSection{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.16);
      background:rgba(31,42,68,.28);
    }
    .sideTitle{
      font-size:13px;
      font-weight:800;
      letter-spacing:.2px;
      margin-bottom:6px;
    }
    .ruleList{list-style:none;padding:0;margin:8px 0 0;display:flex;flex-direction:column;gap:8px}
    .ruleList li{padding:8px 10px;border-radius:12px;border:1px solid rgba(148,163,184,.12);background:rgba(0,0,0,.12);line-height:1.45}
    .ruleList li b{font-weight:800}

    .actionDock{
      display:grid;
      grid-template-columns:minmax(0,1fr) auto;
      gap:12px;
      align-items:center;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.14);
      background:rgba(31,42,68,.35);
    }
    .actionDock .decision{padding:0;border:0;background:transparent}
    .actionDock .decisionRow{justify-content:flex-start}
    .actionDock .controls{gap:12px}

    .btn.primary{
      background:linear-gradient(135deg, rgba(34,197,94,.25), rgba(34,197,94,.08));
      border-color:rgba(34,197,94,.4);
      box-shadow:0 12px 28px rgba(0,0,0,.25);
      font-weight:700;
    }

    details.fold{border:1px solid rgba(148,163,184,.14);border-radius:14px;padding:8px 10px;background:rgba(31,42,68,.28)}
    details.fold summary{cursor:pointer;list-style:none;font-size:12px;color:var(--muted);font-weight:700}
    details.fold summary::-webkit-details-marker{display:none}
    details.fold .hint{margin-top:8px}

    /* --- Scorett Layout --- */
    .mainGrid{display:grid;grid-template-columns:minmax(0,1.6fr) minmax(0,.9fr) minmax(0,1fr);gap:12px;flex:1;min-height:0}
    .playLayout{display:none;grid-template-columns:minmax(0,1.2fr) minmax(0,.8fr);gap:12px;flex:1;min-height:0}
    body.ui-play .playLayout{display:grid}
    body.ui-play .devLayout{display:none}
    body.ui-dev .playLayout{display:none}
    body.ui-dev .devLayout{display:grid}

    .playStage{
      display:flex;
      flex-direction:column;
      gap:14px;
      padding:16px;
      border-radius:18px;
      background:var(--panel);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      min-height:0;
    }
    .playOverloadTrack{padding:14px;border-radius:18px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.14)}
    .playOverloadTrack .overloadPill{font-size:12px;padding:8px 0}
    .playOverloadTrack.pulse{animation:trackPulse .55s ease}
    .playOverloadTrack.pulseStrong{animation:trackPulseStrong .6s ease}
    .playOverloadTrack.shake{animation:trackShake .5s ease}
    @keyframes trackPulse{0%{box-shadow:0 0 0 rgba(255,255,255,0)}40%{box-shadow:0 0 0 4px rgba(255,255,255,.08)}100%{box-shadow:0 0 0 rgba(255,255,255,0)}}
    @keyframes trackPulseStrong{0%{box-shadow:0 0 0 rgba(245,158,11,0)}40%{box-shadow:0 0 0 6px rgba(245,158,11,.18)}100%{box-shadow:0 0 0 rgba(245,158,11,0)}}
    @keyframes trackShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}}

    .playCard{
      min-height:420px;
      border-radius:22px;
      padding:18px;
      background:rgba(31,42,68,.82);
      border:1px solid rgba(148,163,184,.22);
      box-shadow:0 20px 46px rgba(0,0,0,.45);
    }
    .playCard .kName{font-size:22px}
    .playCard .kType{font-size:13px}
    .playCard .kText{font-size:16px;line-height:1.4;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
    .playChips{display:flex;gap:8px;flex-wrap:wrap}
    .playChip{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border-radius:999px;border:1px solid rgba(148,163,184,.18);background:rgba(0,0,0,.18);font-size:13px;font-weight:700}
    .playChip.good{border-color:rgba(34,197,94,.38);background:rgba(34,197,94,.12)}
    .playChip.warn{border-color:rgba(245,158,11,.38);background:rgba(245,158,11,.12)}
    .playChip.bad{border-color:rgba(239,68,68,.38);background:rgba(239,68,68,.12)}
    .playChip.blue{border-color:rgba(96,165,250,.38);background:rgba(96,165,250,.12)}
    .playMeta{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .playMetaChip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:rgba(31,42,68,.65);border:1px solid rgba(148,163,184,.18);font-size:12px;font-weight:700}
    .playMetaChip b{font-weight:900}

    .playPoolRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .playPoolChip{padding:10px 16px;border-radius:999px;background:rgba(96,165,250,.18);border:1px solid rgba(96,165,250,.4);font-size:16px;font-weight:900}
    .playCountdownBadge{padding:6px 10px;border-radius:999px;border:1px solid rgba(245,158,11,.35);background:rgba(245,158,11,.16);font-size:12px;font-weight:800;display:none}
    .playCountdownBadge.active{display:inline-flex}
    .playPrimary{padding:14px 18px;font-size:16px;font-weight:800;border-radius:16px}
    .playPrimary:disabled{opacity:.5}

    .playPlayers{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:16px;
      border-radius:18px;
      background:var(--panel);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
      min-height:0;
    }
    .playPlayersHeader{display:flex;justify-content:space-between;align-items:center;font-weight:900}
    .playPlayersList{display:flex;flex-direction:column;gap:10px;overflow:auto;min-height:0}
    .playPlayer{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 12px;border-radius:14px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.16)}
    .playPlayerMain{display:flex;align-items:center;gap:8px;font-weight:800}
    .playPlayerRight{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .playStatus{font-size:11px;padding:4px 8px;border-radius:999px}
    .playStatus.active{background:rgba(34,197,94,.18);border:1px solid rgba(34,197,94,.4)}
    .playStatus.camped{background:rgba(245,158,11,.18);border:1px solid rgba(245,158,11,.4)}
    .playStatus.out{background:rgba(239,68,68,.18);border:1px solid rgba(239,68,68,.4)}
    .playStats{display:flex;gap:8px;font-size:12px;color:var(--mutedStrong)}
    .playRevealer{font-size:12px;padding:2px 6px;border-radius:999px;background:rgba(96,165,250,.2);border:1px solid rgba(96,165,250,.4)}

    .playDrawer{
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }
    .playLogDrawer{
      position:fixed;
      left:12px;
      right:12px;
      bottom:12px;
      max-height:40vh;
      background:rgba(20,27,42,.98);
      border:1px solid rgba(148,163,184,.22);
      border-radius:18px;
      box-shadow:0 20px 60px rgba(0,0,0,.6);
      padding:12px;
      display:none;
      z-index:140;
    }
    .playLogDrawer.open{display:block}
    .playLogHead{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .playLog{overflow:auto;max-height:30vh;border-radius:12px;border:1px solid rgba(148,163,184,.16);background:rgba(11,15,23,.55);padding:10px;font-size:12px;line-height:1.5}

    .playBanner{
      display:none;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(31,42,68,.45);
      border:1px solid rgba(148,163,184,.16);
      font-weight:800;
    }
    .playBanner.show{display:block}
    .playBanner.good{border-color:rgba(34,197,94,.35);background:rgba(34,197,94,.08)}
    .playBanner.warn{border-color:rgba(245,158,11,.35);background:rgba(245,158,11,.08)}
    .playBanner.bad{border-color:rgba(239,68,68,.35);background:rgba(239,68,68,.08)}

    .stageCard{display:flex;flex-direction:column;gap:12px}
    .stageTop{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .stageMeta{display:flex;gap:8px;flex-wrap:wrap}
    .stageChip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:rgba(31,42,68,.65);border:1px solid rgba(148,163,184,.18);font-size:12px;position:relative}
    .stageChip b{font-weight:900}
    .stageChip.blue{border-color:rgba(96,165,250,.4);background:rgba(96,165,250,.12)}
    .stageChip.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .stageChip.bad{border-color:rgba(239,68,68,.4);background:rgba(239,68,68,.12)}

    .overloadTrack{display:flex;flex-direction:column;gap:8px;padding:10px;border-radius:16px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.14)}
    .overloadTrackHeader{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .overloadPills{display:grid;grid-template-columns:repeat(13, minmax(0,1fr));gap:6px}
    .overloadPill{display:flex;align-items:center;justify-content:center;padding:6px 0;border-radius:999px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.6);font-size:11px;color:var(--muted)}
    .overloadPill.mark{border-color:rgba(245,158,11,.4);color:#fff}
    .overloadPill.danger{border-color:rgba(239,68,68,.45);color:#fff}
    .overloadPill.active{box-shadow:0 0 0 2px rgba(255,255,255,.12), 0 0 16px rgba(99,102,241,.25);background:rgba(99,102,241,.28);color:#fff;font-weight:900}
    .overloadHint{font-size:12px;color:var(--mutedStrong)}
    .overloadHint .chip{padding:4px 8px;border-radius:999px;background:rgba(245,158,11,.12);border:1px solid rgba(245,158,11,.3);font-size:11px}

    .stageGrid{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,280px);gap:12px;min-height:0}
    .currentCard{min-height:360px;border-radius:20px;padding:16px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.75);box-shadow:0 18px 38px rgba(0,0,0,.45);position:relative;overflow:hidden}
    .currentCard .kName{font-size:18px}
    .currentCard .kText{font-size:14px}
    .currentCard .impact{margin-top:8px}

    .poolPanel{display:flex;flex-direction:column;gap:10px;padding:12px;border-radius:16px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.14)}
    .poolChip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(96,165,250,.16);border:1px solid rgba(96,165,250,.38);font-size:14px;font-weight:900}
    .poolStack{display:flex;gap:8px;align-items:center}
    .poolCards{display:flex;gap:6px}
    .poolCard{width:36px;height:48px;border-radius:8px;border:1px solid rgba(148,163,184,.22);background:linear-gradient(135deg, rgba(99,102,241,.2), rgba(15,23,42,.85));box-shadow:0 10px 24px rgba(0,0,0,.35)}
    .poolCard:nth-child(2){transform:translateY(4px);opacity:.8}
    .poolCard:nth-child(3){transform:translateY(8px);opacity:.6}

    .actionRow{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;padding:10px 12px;border-radius:14px;background:rgba(31,42,68,.35);border:1px solid rgba(148,163,184,.14)}
    .actionRow .controls{margin:0}

    .playersCard{display:flex;flex-direction:column;gap:12px;min-height:0}
    .playersHeader{display:flex;justify-content:space-between;align-items:center}
    .leaderSummary{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .playersList{display:flex;flex-direction:column;gap:10px;overflow:auto;min-height:0}
    .playerCard{padding:12px;border-radius:16px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.16);display:flex;flex-direction:column;gap:10px}
    .playerHeader{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .playerName{font-weight:900;font-size:14px;display:flex;align-items:center;gap:8px}
    .playerAvatar{width:32px;height:32px;border-radius:10px;background:rgba(99,102,241,.25);display:flex;align-items:center;justify-content:center;font-weight:900}
    .playerBadge{padding:4px 10px;border-radius:999px;font-size:11px;font-weight:800;letter-spacing:.2px}
    .badgeActive{background:rgba(34,197,94,.16);border:1px solid rgba(34,197,94,.35);color:#fff}
    .badgeCamp{background:rgba(245,158,11,.16);border:1px solid rgba(245,158,11,.35);color:#fff}
    .playerStats{display:flex;gap:8px;flex-wrap:wrap}
    .playerStat{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.18);border:1px solid rgba(148,163,184,.18);font-size:12px}
    .playerStat b{font-weight:900}
    .playerActions{display:flex;gap:6px;flex-wrap:wrap}
    .playerMark{padding:4px 8px;border-radius:999px;font-size:11px;background:rgba(96,165,250,.14);border:1px solid rgba(96,165,250,.3)}
    .playerMark.warn{background:rgba(245,158,11,.14);border-color:rgba(245,158,11,.3)}
    .playerCard.turnGlow{border-color:rgba(34,197,94,.35);box-shadow:0 0 0 1px rgba(34,197,94,.18), 0 12px 34px rgba(0,0,0,.25)}
    .playerCard.decideGlow{border-color:rgba(245,158,11,.35);box-shadow:0 0 0 1px rgba(245,158,11,.16), 0 12px 34px rgba(0,0,0,.22)}
    .playerCard.campedDim{opacity:.78}

    .rightPanel{display:flex;flex-direction:column;gap:12px;min-height:0}
    .rightPanel .sideSection{background:rgba(11,15,23,.45)}
    .rightPanel .log{min-height:200px}

    .decisionOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:120;background:rgba(3,6,12,.78);backdrop-filter:blur(6px)}
    .decisionOverlay.show{display:flex}
    .decisionModal{width:min(820px, 100%);background:rgba(20,27,42,.97);border:1px solid rgba(148,163,184,.22);border-radius:20px;box-shadow:0 22px 70px rgba(0,0,0,.6);padding:18px;display:flex;flex-direction:column;gap:14px}
    .decisionHeader{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .decisionTitle{font-size:22px;font-weight:950}
    .decisionStats{display:flex;gap:8px;flex-wrap:wrap}
    .decisionStat{padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.2);border:1px solid rgba(148,163,184,.16);font-size:13px}
    .decisionAvatars{display:flex;gap:8px;flex-wrap:wrap}
    .decisionMain{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
    .decisionBots{display:flex;flex-direction:column;gap:10px}
    .decisionBots.hidden{display:none}
    .decisionBotRow{display:flex;flex-direction:column;gap:8px;padding:10px 12px;border-radius:14px;border:1px solid rgba(148,163,184,.18);background:rgba(11,15,23,.45)}
    .decisionBotHead{display:flex;justify-content:space-between;align-items:center;gap:10px;font-weight:800}
    .decisionBotChoices{display:flex;gap:8px;flex-wrap:wrap}
    .decisionBotBtn{padding:8px 12px;border-radius:12px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.6);cursor:pointer}
    .decisionBotBtn.good{border-color:rgba(34,197,94,.4);background:rgba(34,197,94,.12)}
    .decisionBotBtn.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .decisionBotBtn.selected{box-shadow:0 0 0 2px rgba(255,255,255,.14), 0 12px 28px rgba(0,0,0,.25)}
    .decisionBtn{padding:16px;border-radius:16px;border:1px solid rgba(148,163,184,.22);background:rgba(31,42,68,.6);display:flex;flex-direction:column;gap:6px;align-items:flex-start;cursor:pointer}
    .decisionBtn strong{font-size:20px}
    .decisionBtn small{color:var(--mutedStrong)}
    .decisionBtn.good{border-color:rgba(34,197,94,.4);background:rgba(34,197,94,.12)}
    .decisionBtn.warn{border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.12)}
    .decisionBtn:disabled{opacity:.5;cursor:not-allowed}
    .decisionBtn.selected{box-shadow:0 0 0 2px rgba(255,255,255,.14), 0 12px 28px rgba(0,0,0,.25);transform:translateY(-1px)}
    .decisionPreview{padding:10px 12px;border-radius:14px;background:rgba(11,15,23,.45);border:1px solid rgba(148,163,184,.16);display:flex;flex-direction:column;gap:6px}
    .decisionPlayers{display:flex;gap:8px;flex-wrap:wrap}
    .decisionPlayer{width:28px;height:28px;border-radius:10px;background:rgba(148,163,184,.18);display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:800;color:var(--muted)}
    .decisionPlayer.done{background:rgba(34,197,94,.22);color:#fff}
    .decisionTimer{width:44px;height:44px;border-radius:999px;border:2px solid rgba(96,165,250,.4);display:flex;align-items:center;justify-content:center;font-size:11px;color:#fff}

    .logDrawer{display:block}
    body.logHidden .logDrawer{display:none}
    body.logOpen .logDrawer{display:block}
    body.logOpen .logDrawer .sideSection{max-height:60vh}

    @media (max-width:1150px){
      .mainColumns{grid-template-columns:1fr}
      .mainGrid{grid-template-columns:1fr}
      .playLayout{grid-template-columns:1fr}
      .topBar{grid-template-columns:1fr;gap:8px}
      .topCenter{text-align:left}
      .playersList{max-height:240px}
      .rightPanel{order:3}
      .playersCard{order:2}
      .stageCard{order:1}
      .stageGrid{grid-template-columns:1fr}
      .decisionMain{grid-template-columns:1fr}
      .logDrawer{display:none}
      .playDrawer{
        position:fixed;
        left:12px;
        right:12px;
        bottom:12px;
        background:rgba(11,15,23,.6);
        border:1px solid rgba(148,163,184,.18);
        border-radius:16px;
        padding:8px 10px;
        z-index:150;
        justify-content:space-between;
      }
      body.logOpen .logDrawer{
        display:block;
        position:fixed;
        inset:auto 12px 12px 12px;
        z-index:130;
        border-radius:18px;
        box-shadow:0 20px 60px rgba(0,0,0,.6);
      }
    }
    @media (max-height:900px){
      body{overflow:auto}
      .wrap{height:auto}
    }
  </style>
</head>
<body class="ui-play">
  <div class="wrap">
    <div class="topBar">
      <div class="topLeft">
        <div class="ver" id="verBtn" title="Patch Notes anzeigen">
          <span>üéõÔ∏è</span><b id="verText">v0.0</b><span class="mini">(klicken)</span>
        </div>
        <div class="gameTitle devOnly">
          <b>Festival Overload</b>
          <span>Scorett UI ¬∑ Prototyp</span>
        </div>
        <div class="playTitle playOnly">
          <b>Festival Overload</b> ¬∑ <span id="playVersion">v0.0</span>
        </div>
      </div>
      <div class="topCenter">
        <div class="roundEvent devOnly">
          Runde <span class="roundBadge" id="roundBadge"><span id="roundNo">1</span></span>
          ¬∑ Event <span class="roundBadge" id="eventBadge"><span id="eventNo">0</span></span>
        </div>
        <div class="statusHeadline playOnly" id="statusHeadline">Event aufdecken</div>
        <small class="mini devOnly">Ein Blick: Overload ¬∑ Pool ¬∑ Karte ¬∑ Aktivit√§t</small>
      </div>
      <div class="topRight">
        <div class="goalChip">Ziel: 8 Camp</div>
        <div class="modeToggle" role="group" aria-label="Modus wechseln">
          <button class="btn slim" id="btnModePlay">Spielmodus</button>
          <button class="btn slim" id="btnModeDev">Dev</button>
        </div>
        <div class="statusIcons devOnly">
          <span class="statusChip warn" id="countdownStatus">üî• Countdown aktiv</span>
          <span class="statusChip blue" id="stageRuleChip">üåÄ B√ºhnenregel</span>
          <span class="statusChip bad" id="twistPyroChip">üî• PYRO aktiv</span>
          <span class="statusChip warn" id="twistRichtungswechselChip">üîÑ Richtungswechsel</span>
          <span class="statusChip blue" id="twistAfterpartyChip">üéâ Afterparty</span>
          <span class="statusChip bad" id="encoreChip">üé§ Endkarte</span>
        </div>
      </div>
    </div>

    <div class="playLayout">
      <section class="playStage">
        <div class="playOverloadTrack" id="playOverloadTrack" aria-label="Overload-Track">
          <div class="overloadTrackHeader">
            <div><b>Overload</b> <span class="mini">0‚Äì12</span></div>
            <div class="overloadHint"><span class="chip">‚è±Ô∏è Countdown +1</span> <span class="mini" id="playCountdownHint">inaktiv</span></div>
          </div>
          <div class="overloadPills" id="overloadPillsPlay"></div>
        </div>
        <div class="playSteps" id="playSteps" aria-label="Phasen">
          <div class="step" data-step="reveal" title="Der aktive Spieler deckt genau 1 Event auf"><span class="n">1</span>Aufdecken</div>
          <div class="step" data-step="event" title="Event-Effekt wird ausgef√ºhrt (inkl. Endkarten, Twist, Overload-Check)"><span class="n">2</span>Effekt</div>
          <div class="step" data-step="countdown" title="Wenn Countdown aktiv ist: nach dem Event Overload +1 (Afterparty: +2), optional +1 extra bei Pool ‚â•3 (falls aktiviert)"><span class="n">3</span>Countdown</div>
          <div class="step" data-step="decision" title="Alle aktiven Spieler entscheiden gleichzeitig Bleib/Camp"><span class="n">4</span>Entscheidung</div>
        </div>

        <div class="playMeta" aria-label="Meta-Infos">
          <div class="playMetaChip">Aufdecker: <b id="playRevealerName">‚Äî</b></div>
          <div class="playMetaChip">Richtung: <b id="playDirection">‚Üª</b></div>
        </div>
        <div class="playMeta" aria-label="Deck-Status">
          <div class="playMetaChip">Deck: <b id="deckCountPlay">0</b></div>
          <div class="playMetaChip">Ablage: <b id="discardCountPlay">0</b></div>
        </div>

        <div class="eventCard playCard" id="playEventCard" data-type="twist">
          <div class="stripe"></div>
          <div class="kTop">
            <div class="kName" id="playEventName">Bereit</div>
            <div class="kType" id="playEventType"><span class="dot" style="background:rgba(148,163,184,.6)"></span> ‚è∫Ô∏è Event</div>
          </div>
          <div class="kText" id="playEventText">Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten.</div>
        </div>

        <div class="playChips" id="playEventChips">‚Äî</div>

        <div class="playPoolRow">
          <div class="playPoolChip">Pool: <span id="poolValuePlay">0</span></div>
          <div class="playCountdownBadge" id="playCountdownBadge">Countdown +1</div>
        </div>

        <button class="btn good primary playPrimary" id="btnRevealPlay">Event aufdecken</button>
        <div class="playBanner" id="playBanner"></div>
      </section>

      <section class="playPlayers">
        <div class="playPlayersHeader">
          <span>Spielerleisten</span>
          <span class="mini">Status & Werte</span>
        </div>
        <div class="leaderSummary">
          <span class="pill blue" id="leaderSummaryPlay">Leader: ‚Äî ¬∑ Camp ‚Äî ¬∑ Abstand ‚Äî</span>
        </div>
        <div class="playPlayersList" id="playersPlay"></div>
      </section>
    </div>

    <div class="playDrawer playOnly">
      <button class="btn slim" id="btnPlayLog">Log</button>
      <button class="btn slim" id="btnPlayRules" aria-label="Kurzregeln">?</button>
    </div>

    <div class="playLogDrawer" id="playLogDrawer" aria-hidden="true">
      <div class="playLogHead">
        <b>Log</b>
        <button class="btn slim" id="btnPlayLogClose">Schlie√üen</button>
      </div>
      <div class="playLog" id="logPlay"></div>
    </div>

    <div class="mainGrid devLayout">
      <section class="card stageCard">
        <div class="stageTop">
          <div class="stageMeta">
            <div class="stageChip" id="overloadChip"><b>Overload</b> <span id="overloadValue">0</span> / 12</div>
            <div class="stageChip blue" id="poolChip"><b>Pool</b> <span id="poolValue">0</span></div>
            <div class="stageChip" id="deckChip"><b>Deck</b> <span id="deckCount">0</span></div>
            <div class="stageChip" id="discardChip"><b>Ablage</b> <span id="discardCount">0</span></div>
          </div>
          <div class="stageMeta">
            <div class="stageChip" id="stateChip"><b>Status</b>: Normal</div>
            <div class="stageChip warn" id="countdownChip"><b>Countdown</b>: <span id="countdown">aus</span></div>
            <div class="stageChip blue"><b>Phase</b>: <span id="phase">Aufdecken</span></div>
          </div>
        </div>

        <div class="overloadTrack" aria-label="Overload-Track">
          <div class="overloadTrackHeader">
            <div><b>Overload-Track</b> <span class="mini">0‚Äì12</span></div>
            <div class="overloadHint"><span class="chip">‚è±Ô∏è Countdown +1</span> <span class="mini" id="countdownHint">inaktiv</span></div>
          </div>
          <div class="overloadPills" id="overloadPills"></div>
        </div>

        <div class="steps" id="steps" aria-label="Phasen">
          <div class="step" data-step="reveal" title="Der aktive Spieler deckt genau 1 Event auf"><span class="n">1</span>Aufdecken</div>
          <div class="step" data-step="event" title="Event-Effekt wird ausgef√ºhrt (inkl. Endkarten, Twist, Overload-Check)"><span class="n">2</span>Effekt</div>
          <div class="step" data-step="countdown" title="Wenn Countdown aktiv ist: nach dem Event Overload +1 (Afterparty: +2), optional +1 extra bei Pool ‚â•3 (falls aktiviert)"><span class="n">3</span>Countdown</div>
          <div class="step" data-step="decision" title="Alle aktiven Spieler entscheiden gleichzeitig Bleib/Camp"><span class="n">4</span>Entscheidung</div>
        </div>

        <div class="stageGrid">
          <div>
            <div class="row" style="justify-content:space-between">
              <div>
                <b>Aktuelle Karte</b>
                <span class="mini">(aufgedeckt von: <b id="revealerName">‚Äî</b> ¬∑ Richtung: <b id="dir">‚Üª</b>)</span>
              </div>
              <div class="mini">B√ºhnenregel: <b id="stageRule">‚Äî</b></div>
            </div>

            <div class="eventCard currentCard" id="eventCard" data-type="twist">
              <div class="stripe"></div>
              <div class="kTop">
                <div class="kName" id="eventName">Bereit</div>
                <div class="kType" id="eventType"><span class="dot" style="background:rgba(148,163,184,.6)"></span> ‚è∫Ô∏è Event</div>
              </div>
              <div class="impact" id="eventImpact">‚Äî</div>
              <div class="kText" id="eventText">Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten.</div>
            </div>

            <div class="eventSummary" id="eventSummary">‚Äî</div>

            <div class="actionRow">
              <div class="mini">Simultane Entscheidung erscheint als Overlay nach Eventende.</div>
              <div class="controls">
                <button class="btn good primary" id="btnReveal">Aufdecken</button>
                <button class="btn blue" id="btnLog">Log</button>
              </div>
            </div>

            <details class="fold">
              <summary>Regelhilfe & Pool-Bonus</summary>
              <div class="hint">
                <b>Camp (nur mit Live):</b> Ohne mindestens <b>1 Live</b> gibt es keinen Cashout.
                <br>
                <b>Pool-Bonus:</b> Pool‚ÜíCamp ist nur bei <b>Live ‚â•2</b> (bzw. <b>Live ‚â•3</b> bei Richtungswechsel) erlaubt. Zus√§tzlich gilt ein Overload-Gate: <b>0/1/2</b> (bei Overload &lt;7 / 7‚Äì9 / 10+).
                <br>
                <b>Wichtig:</b> Ma√ügeblich ist der <b>Overload nach dem Event</b> (inkl. Countdown/Checks), direkt vor der Camp-Entscheidung.
                <br>
                <b>Verteilung (gleichzeitig campen):</b> In Zugreihenfolge (ab Aufdecker) erh√§lt jeder Camper maximal bis zum Gate, solange Pool verf√ºgbar ist.
              </div>
            </details>
          </div>

          <div class="poolPanel">
            <div class="poolChip">Pool: <span id="poolValueSide">0</span></div>
            <div class="poolStack">
              <div class="poolCards">
                <div class="poolCard"></div>
                <div class="poolCard"></div>
                <div class="poolCard"></div>
              </div>
              <div class="mini" id="poolHint">Camp-Bonus: Gate 0/1/2 (Overload), Live ‚â•2/3</div>
            </div>

            <div class="tableau">
              <div class="stack">
                <div class="stackTitle"><b>Deck</b><span id="deckCountMini">0 Karten</span></div>
                <div class="cardStack" id="deckStack">
                  <div class="cardBack layer3"></div>
                  <div class="cardBack layer2"></div>
                  <div class="cardBack"></div>
                </div>
              </div>
              <div class="stack">
                <div class="stackTitle"><b>Aufgedeckt</b><span id="revealMeta">‚Äî</span></div>
                <div class="cardFace" id="revealCard" data-type="empty">
                  <div class="rTop">
                    <span class="rName" id="revealName">Noch keine Karte</span>
                    <span class="rType" id="revealType">‚Äî</span>
                  </div>
                  <div class="rText" id="revealText">Klicke auf ‚ÄûAufdecken‚Äú, um den ersten Draw zu sehen.</div>
                </div>
              </div>
              <div class="stack">
                <div class="stackTitle"><b>Ablage</b><span id="discardCountMini">0 Karten</span></div>
                <div class="cardStack" id="discardStack">
                  <div class="cardBack discard layer3"></div>
                  <div class="cardBack discard layer2"></div>
                  <div class="cardBack discard"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="banner" id="banner"></div>
      </section>

      <section class="card playersCard">
        <div class="playersHeader">
          <b>Spielerleisten</b>
          <span class="mini">Reihenfolge & Status</span>
        </div>
        <div class="leaderSummary">
          <span class="pill blue" id="leaderSummary">Leader: ‚Äî ¬∑ Camp ‚Äî ¬∑ Abstand ‚Äî</span>
        </div>
        <div class="playersList" id="players"></div>
      </section>

      <section class="card rightPanel">
        <div class="sideSection">
          <div class="sideTitle">Regelerinnerung</div>
          <ul class="ruleList mini">
            <li><b>Nach jedem Event</b>: Bleib oder Camp.</li>
            <li><b>Camp</b>: nur mit mindestens 1 Live.</li>
            <li><b>Bei 12</b>: Katastrophen-Check.</li>
          </ul>
        </div>
        <div class="sideSection logDrawer">
          <div class="logHead">
            <b>Log</b>
            <div class="logActions">
              <button class="btn slim" id="btnCopyLog">Log kopieren</button>
              <button class="btn slim" id="btnExportDebug">Debug exportieren</button>
            </div>
          </div>
          <div class="log" id="log"></div>
        </div>
        <div class="sideSection">
          <div class="sideTitle">Einstellungen</div>
          <div class="toggle">
            <label class="mini"><input id="optPflaster" type="checkbox" checked> Pflaster nach Knall: +1 Live nach Halbierung (nur wenn Live vorher ‚â•1)</label>
            <label class="mini"><input id="optAggCountdown" type="checkbox"> Countdown aggressiv: +1 extra wenn Pool ‚â•3</label>
            <label class="mini">Steuerung:
              <select id="optControlMode">
                <option value="bots-auto" selected>Nur Bots automatisch</option>
                <option value="bots-manual">Alle Bots manuell</option>
                <option value="all-auto">Alles automatisch (inkl. Du)</option>
              </select>
            </label>
            <label class="mini">Bot-Profil:
              <select id="optBotProfile"></select>
            </label>
            <div class="botControls mini">
              <span id="botCountLabel">Bots: 3</span>
              <button class="btn slim" id="btnAddBot">Bot hinzuf√ºgen</button>
              <button class="btn slim" id="btnRemoveBot">Bot entfernen</button>
              <span class="tag">nur vor Spielstart</span>
            </div>
            <label class="mini"><input id="optDecisionTimer" type="checkbox" checked> Timer aktiv (20s, Auto-Bleib)</label>
            <label class="mini"><input id="optDebugAssertFail" type="checkbox"> Debug: ASSERT_FAIL erzwingen</label>
            <label class="mini">Tempo:
              <select id="optSpeed">
                <option value="250">schnell</option>
                <option value="650" selected>normal</option>
                <option value="1100">langsam</option>
              </select>
            </label>
            <button class="btn blue" id="btnPlayPreview">Spielmodus Vorschau</button>
            <button class="btn bad" id="btnRestart">Neustart</button>
          </div>
        </div>
        <div class="sideSection">
          <div class="sideTitle">Test-Deck (60 Karten)</div>
          <div class="mini">‚ö° Push 26 ¬∑ üõ†Ô∏è Stabilisieren 14 ¬∑ üåÄ Twist 14 ¬∑ üé§ Encore 6</div>
        </div>
        <div class="sideSection mini">
          <b>Dev:</b> Browser-Konsole: <code>FestivalOverloadTests</code>
        </div>
      </section>
    </div>
  </div>

  <div class="decisionOverlay" id="decisionOverlay" aria-hidden="true">
    <div class="decisionModal" role="dialog" aria-modal="true" aria-label="Entscheidung">
      <div class="decisionHeader">
        <div>
          <div class="decisionTitle">Entscheidung!</div>
          <div class="decisionStats">
            <div class="decisionStat">Overload: <b id="decisionOverload">0</b></div>
            <div class="decisionStat">Pool: <b id="decisionPool">0</b></div>
            <div class="decisionStat">Live: <b id="decisionLive">0</b></div>
          </div>
        </div>
        <div class="decisionTimer" id="decisionTimer">20s</div>
      </div>

      <div>
        <div class="mini">Wer hat schon gew√§hlt?</div>
        <div class="decisionAvatars" id="decisionPlayers"></div>
      </div>

      <div class="decisionMain">
        <button class="decisionBtn good" id="btnStay">
          <strong>BLEIB</strong>
          <small>Live bleibt riskant</small>
        </button>
        <button class="decisionBtn warn" id="btnCamp">
          <strong>CAMP</strong>
          <small id="campHint">Du sicherst dein Live</small>
        </button>
      </div>
      <div class="decisionBots hidden" id="decisionBots"></div>

      <div class="decisionPreview" id="decisionPreview">
        <div class="mini" id="decisionHint">W√§hle Bleib oder Camp. Danach wird simultan aufgel√∂st.</div>
        <div class="mini" id="decisionGain">‚Äî</div>
        <div class="mini" id="decisionTotal">‚Äî</div>
      </div>

      <div class="controls" style="justify-content:flex-end">
        <button class="btn blue" id="btnResolve">Entscheidung ausf√ºhren</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Patch Notes Modal -->
  <div class="modalBack" id="pnBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Patch Notes">
      <div class="modalTop">
        <b>Patch Notes</b>
        <button class="btn slim" id="pnClose">Schlie√üen</button>
      </div>
      <div class="modalBody" id="pnBody"></div>
    </div>
  </div>

  <!-- Generic Ask Modal -->
  <div class="modalBack" id="askBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Aktion">
      <div class="modalTop">
        <b id="askTitle">Aktion</b>
        <button class="btn slim" id="askX">Schlie√üen</button>
      </div>
      <div class="modalBody">
        <div class="confirmText" id="askText"></div>
        <div class="pickList" id="askPick" style="display:none"></div>
        <div class="confirmBtns" id="askBtns">
          <button class="btn" id="askNo">Abbrechen</button>
          <button class="btn good" id="askYes">OK</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Kurzregeln Modal (Spielmodus) -->
  <div class="modalBack" id="rulesBack" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Kurzregeln">
      <div class="modalTop">
        <b>Kurzregeln</b>
        <button class="btn slim" id="rulesClose">Schlie√üen</button>
      </div>
      <div class="modalBody">
        <ul class="ruleList mini">
          <li><b>Nach jedem Event</b>: Alle aktiven Spieler entscheiden simultan Bleib oder Camp.</li>
          <li><b>Camp</b> ist nur mit mindestens 1 Live m√∂glich.</li>
          <li><b>Pool-Bonus</b>: Nur bei Live ‚â•2 (bzw. ‚â•3 bei Richtungswechsel) und Overload-Gate 0/1/2 (bei &lt;7 / 7‚Äì9 / 10+), Reihenfolge ab Aufdecker.</li>
          <li><b>Crowd-Mood</b>: Jede Push-Erh√∂hung wird durch das Mood-Deck leicht verschoben (min. +1).</li>
          <li><b>Twists</b>: Pyro, Richtungswechsel und Afterparty gelten bis Rundenende.</li>
          <li><b>Overload 12</b>: Katastrophen-Check ‚Äì Push bedeutet Knall.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    var VERSION = 'v0.40';
    var RULESET_VERSION = '0.8';
    var OVERLOAD_RESET_AFTER_CHECK = 10;
    var STAGE_DIVE_REPLACEMENT = 'overload';
    var MOOD_DECK_BASE = [-1, 0, 0, 1, 1, 2];
    var MIN_LIVE_FOR_POOL_BASE = 2;
    var STABILIZE_CARDS = [
      { name:'Atem holen', value:2, count:8 },
      { name:'Security greift ein', value:3, count:6 }
    ];
    var EFFECT_IDS = {
      PUSH: 'PUSH',
      STABILIZE: 'STABILIZE',
      TWIST_PYRO: 'TWIST_PYRO',
      TWIST_AFTERPARTY: 'TWIST_AFTERPARTY',
      TWIST_RICHTUNGSWECHSEL: 'TWIST_RICHTUNGSWECHSEL',
      TWIST_NO_EFFECT: 'TWIST_NO_EFFECT',
      STAGE_RULE_ADD: 'STAGE_RULE_ADD',
      STAGE_RULE_REPLACE: 'STAGE_RULE_REPLACE',
      FEEDBACK_LEVEL_UP: 'FEEDBACK_LEVEL_UP',
      STAGE_DIVE: 'STAGE_DIVE',
      END_ENCORE: 'END_ENCORE',
      ENCORE_CHAIN_START: 'ENCORE_CHAIN_START',
      ENCORE_STOP: 'ENCORE_STOP',
      UNKNOWN: 'UNKNOWN_EFFECT'
    };

    // Bot-Limits f√ºr die UI-Anpassung
    var MIN_BOTS = 1;
    var MAX_BOTS = 6;

    // Patch notes: newest first
    var PATCH_NOTES = [
      {
        ver: 'v0.40',
        date: '2026-02-27',
        items: [
          'Neu: Vereinfachte Phasenleiste im Spielmodus direkt unter dem Overload-Track, synchron zum Status.'
        ]
      },
      {
        ver: 'v0.39',
        date: '2026-02-20',
        items: [
          'Neu: Fortschrittsblock bei den Spielerleisten zeigt Leader, Camp-Stand und Abstand zum Ziel.'
        ]
      },
      {
        ver: 'v0.38',
        date: '2026-02-12',
        items: [
          'Neu: Deck- und Ablage-Status im Spielmodus direkt in der B√ºhne.',
          'Neu: Kompakte Phasenleiste im Spielmodus, synchron zum aktuellen Status.',
          'Fix: Catch-up greift nur noch strikt hinter dem Leader und erst ab Abstand ‚â•2 (max. 1√ó pro Spieler/Runde).',
          'Fix: Countdown startet sofort bei Overload ‚â•8, tickt im selben Zug und pr√ºft Risiko vor Camp.',
          'Fix: Logger nutzt feste EffectIds, keine UNKNOWN_EFFECT mehr, Details ohne HTML-Escapes.',
          'Fix: ROUND_END-Logs sind entdoppelt (Summary eigenes ActionType).',
          'Neu: RNG mit numerischem Seed im State/Log + Debug-Helper f√ºr deterministische Engine-Checks.'
        ]
      },
      {
        ver: 'ruleset 0.8',
        date: '2026-02-02',
        items: [
          'Neu: Crowd-Mood-Deck (‚àí1/0/0/+1/+1/+2) modifiziert jede Push-Erh√∂hung, inkl. Log.',
          'Neu: Stabilisieren gibt keinen Pool mehr; Bonus-Live nur bei Overload ‚â•9.',
          'Neu: Pool‚ÜíCamp ist per Overload-Gate 0/1/2 begrenzt; Live-Schwelle steigt bei Richtungswechsel.',
          'Neu: Twist-Effekte sind bis Rundenende aktiv (Pyro, Richtungswechsel, Afterparty).',
          'Neu: Afterparty startet Countdown sofort und erh√∂ht den Tick auf +2.',
          'Neu: Endkarte Encore! gibt allen Aktiven +1 Live und triggert finale Camp-Entscheidung.',
          'Neu: Catch-up-Bonus +1 Camp f√ºr Letzte bei Overload ‚â•8.',
          'Neu: Bots nutzen die neuen Camp-Gates und finale Camp-Phase.',
          'Fix: Nach jeder Kartenaufl√∂sung werden Overload/Pool/Live/Camp geklammert.'
        ]
      },
      {
        ver: 'v0.37',
        date: '2026-01-22',
        items: [
          'Neu: Pool‚ÜíCamp nur bei Live ‚â•2; Camp mit Live=1 erh√§lt keinen Pool-Bonus (klar geloggt).',
          'Neu: DecisionWindow wird √ºbersprungen, wenn es keine sinnvolle Entscheidung gibt (Log: DecisionWindow=SKIP).',
          'Neu: Final Push mit 1 Gnaden-Bleib, danach erzwungenes Camp (Last Call).',
          'Neu: Encore-Stop erlaubt bei Live 0, kostet Overload +1 (cap) und ist geloggt.',
          'Fix: Null-Stabi (Overload 0) gibt keinen Pool-Ertrag mehr.'
        ]
      },
      {
        ver: 'v0.36',
        date: '2026-01-21',
        items: [
          'Neu: Log-Schema vollst√§ndig auf key=value umgestellt, inkl. Step-ID, Reason und globaler Flags.',
          'Neu: Debug-Snapshots pro Step + Export mit Logzeilen (window.exportDebug).',
          'Neu: Validator f√ºr Log-Format und State-Invarianten, ASSERT_FAIL per Debug-Schalter erzwingbar.',
          'Fix: Encore-Logging nur einmal DRAW f√ºr Encore!, danach Chain-Start und Chain-Draw.',
          'Fix: Countdown-Start loggt CountdownActive false->true, POOL_DISTRIBUTION nur als Plan ohne Delta.'
        ]
      },
      {
        ver: 'v0.35',
        date: '2026-01-20',
        items: [
          'Neu: KNALL halbiert Live der aktiven Spieler (Abrunden), Pflaster rettet +1 Live nach Halbierung (nur wenn Live vorher ‚â•1).',
          'Neu: Final-Push-Regel ersetzt Anti-Solo ‚Äì letzter aktiver Spieler bekommt 1 Extra-Event, danach normale Camp-Entscheidung.',
          'Neu: Stabilisieren gibt +1 Pool bei Overload 4‚Äì7, +1 Live bei 8+, Null-Stabi (0) gibt keinen Ertrag.',
          'Neu: Pool‚ÜíCamp ist auf +1 pro Camper begrenzt (cap1), Rundenverteilung bleibt nur als Reihenfolge.',
          'Neu: Schritt-Logformat mit Step-ID, Actor/ActionType, Delta-Reasons und Debug-Export (JSON-Snapshots).'
        ]
      },
      {
        ver: 'v0.34',
        date: '2026-01-19',
        items: [
          'Neu: Camp-Pool wird bei simultanen Camps rundenbasiert verteilt (max. +1 pro Runde je Camper, Reihenfolge ab Aufdecker).',
          'Neu: Null-Stabi-Regel ‚Äì bei Overload 0 gibt Stabilisieren keinen Ertrag (klar geloggt).',
          'Fix: Camp-Aufl√∂sung loggt die Pool-Rundenverteilung samt Priorit√§t sichtbar.'
        ]
      },
      {
        ver: 'v0.33',
        date: '2026-01-18',
        items: [
          'Fix: Entscheidungs-Log trennt Choice-Zeile von Camp/Anti-Solo/Reset-Abwicklung.',
          'Fix: Feedback stapelt Level (0‚Äì3), Push nutzt den Level als Modifikator und Logs zeigen Levelwechsel.',
          'Fix: State-Logs ohne ‚ÄûLive/Camp unver√§ndert‚Äú, mit konsistenter Reihenfolge Overload ‚Üí Pool ‚Üí Live ‚Üí Camp.',
          'Fix: Camp- und Anti-Solo-Logs ohne doppelte Delta-Wiederholungen.'
        ]
      },
      {
        ver: 'v0.32',
        date: '2026-01-15',
        items: [
          'Fix: RoundReset r√§umt Entscheidung-Flags/Queues und blockt Entscheidungs-Phase nach Knall/Rundenende.',
          'Fix: KNALL-Pflaster eindeutig umgesetzt und pro Spieler vollst√§ndig geloggt.',
          'Fix: Stage Dive setzt ‚ÄûMuss bleiben‚Äú nur einmal, loggt Zwang im Entscheidungs-Log und nutzt Ersatz-Effekt.',
          'Fix: Rundenende loggt Pool-Verfall explizit; Richtungswechsel/Setwechsel zeigen den n√§chsten Aufdecker.',
          'Fix: Logs nutzen konsistente Werte-Reihenfolge (Overload, Pool, Live, Camp) und Selftest pr√ºft RoundReset.'
        ]
      },
      {
        ver: 'v0.31',
        date: '2026-01-11',
        items: [
          'Fix: Log-Ausgaben enthalten konsistent Overload/Live/Camp/Pool-√Ñnderungen.',
          'Fix: Stabilisieren/Push/Countdown-Logs zeigen Vorzeichen, Cap/Min-0 und Basis/Modifier exakt.',
          'Fix: Katastrophen-Check/Anti-Solo/Stage-Dive-Logs folgen einheitlichem Format.'
        ]
      },
      {
        ver: 'v0.30',
        date: '2026-01-10',
        items: [
          'Fix: Pool-Bonus wird deterministisch pro Camper verteilt (Reihenfolge ab Aufdecker, aktuelle Richtung).',
          'Fix: Camp-Logs zeigen Live‚ÜíCamp und Pool‚ÜíCamp pro Spieler inkl. Camp/Pool-Delta.',
          'Fix: Stabilisieren- und Push-Logs nutzen feste Kartenwerte, zeigen Vorzeichen korrekt und beachten min 0/Cap 12.',
          'Fix: Katastrophen-Check loggt Check-Karte klar und setzt Overload bei Safe auf 10.',
          'Fix: Anti-Solo camped den letzten Spieler inkl. Pool-Bonus und Trostpunkt bei 0 Live.',
          'Fix: Stage Dive stapelt kein ‚ÄûMuss bleiben‚Äú mehr; Ersatz-Effekt greift stattdessen.'
        ]
      },
      {
        ver: 'v0.29',
        date: '2026-01-14',
        items: [
          'Fix: Zentrale UI-Labels werden nur aktualisiert, wenn die Elemente vorhanden sind.'
        ]
      },
      {
        ver: 'v0.28',
        date: '2026-01-13',
        items: [
          'Fix: Status-Chips werden nur aktualisiert, wenn die UI-Elemente existieren.'
        ]
      },
      {
        ver: 'v0.27',
        date: '2026-01-12',
        items: [
          'Fix: Event-Handler in den Einstellungen werden nur gebunden, wenn die Elemente existieren.'
        ]
      },
      {
        ver: 'v0.26',
        date: '2026-01-11',
        items: [
          'Fix: Aufdecker-Index wird auch vor der Entscheidungsreihenfolge und im Bot-Autopump normalisiert.'
        ]
      },
      {
        ver: 'v0.25',
        date: '2026-01-10',
        items: [
          'Fix: Fehlende Spieler werden in EndRound/Entscheidung sicher per Neustart abgefangen.',
          'Fix: Bot-Autopump ignoriert leere Spielerlisten.'
        ]
      },
      {
        ver: 'v0.24',
        date: '2026-01-09',
        items: [
          'Fix: Revealer-Index wird normalisiert, um inkonsistente Zust√§nde beim Spielstart abzufangen.',
          'Fix: Fehlende Spielerliste f√ºhrt zu einem sicheren Neustart statt zu Folgefehlern.'
        ]
      },
      {
        ver: 'v0.23',
        date: '2026-01-08',
        items: [
          'Fix: Selbsttests laufen nur noch bei ?selftest=1, um Logs/UI im normalen Spielstart nicht zu beeinflussen.'
        ]
      },
      {
        ver: 'v0.22',
        date: '2026-01-07',
        items: [
          'Fix: Bot-Anzahl wird auf eine ganze Zahl gerundet, um inkonsistente Zust√§nde zu vermeiden.'
        ]
      },
      {
        ver: 'v0.21',
        date: '2026-01-06',
        items: [
          'Fix: Stage-Dive-Ziel kann nicht mehr der Aufdecker selbst sein.',
          'Fix: Bot-Anzahl-Input wird robuster gegen ung√ºltige Werte gepr√ºft.'
        ]
      },
      {
        ver: 'v0.20',
        date: '2026-01-05',
        items: [
          'Fix: Overload-Delta in Log/Overlay nutzt jetzt den tats√§chlich angewendeten (gecappten) Wert.',
          'Fix: Countdown/Push/Stabilisieren/Pyro zeigen konsistente Overload-√Ñnderungen an.'
        ]
      },
      {
        ver: 'v0.19',
        date: '2026-01-04',
        items: [
          'Neu: Bot-Anzahl vor Spielstart anpassbar (Bot hinzuf√ºgen/entfernen).',
          'UI: Bot-Z√§hler in den Einstellungen erg√§nzt, inkl. Sperre nach Spielstart.'
        ]
      },
      {
        ver: 'v0.18',
        date: '2026-01-03',
        items: [
          'Neu: Steuerungsmodi f√ºr Bots (Bots automatisch, Bots manuell, alles automatisch inkl. Du).',
          'Neu: Modulares Bot-Profil-System, vorbereitet f√ºr weitere Bot-Strategien.',
          'UI: Bot-Entscheidungen im Overlay w√§hlbar, wenn Bots manuell gesteuert werden.'
        ]
      },
      {
        ver: 'v0.17',
        date: '2026-01-02',
        items: [
          'UI: Spielmodus mit minimaler B√ºhne, gro√üem Statussatz, Overload-Track und Kartenfokus erg√§nzt.',
          'UI: Dev-Modus bleibt vollst√§ndig, inkl. Schnellwechsel √ºber Modus-Toggle und Vorschau-Button.',
          'UI: Bleib/Camp-Overlay mit klaren Vorschauzeilen und optionalem 20s-Timer erweitert.',
          'UX: Log/Regeln im Spielmodus als Drawer/Modal, Overload-Pulse und Ergebnisbanner f√ºr Knall/Checks.'
        ]
      },
      {
        ver: 'v0.16',
        date: '2025-12-30',
        items: [
          'UI: Neues ‚ÄûScorett‚Äú-Layout mit Top-Bar, 3-Spalten-B√ºhne und klaren Chips f√ºr Overload/Pool/Deck/Ablage.',
          'UI: Overload-Track als 0‚Äì12 Pills plus Status-Chips f√ºr Countdown, B√ºhnenregel und Encore.',
          'UI: Spielerleisten als gro√üe Cards mit Live/Camp-Chips, Status-Badges und Wahlmarkern.',
          'UI: Simultane Entscheidung als Vollbild-Overlay mit Vorschau und Spielerstatus.',
          'UX: Log als Drawer (per Button), Einstellungen in die rechte Spalte verschoben.'
        ]
      },
      {
        ver: 'v0.15',
        date: '2025-12-29',
        items: [
          'UI: Lesbarkeit erh√∂ht (st√§rkerer Kontrast, gr√∂√üere Schrift f√ºr Hinweise/Log).',
          'UI: Aktiver Phasen-Schritt deutlicher hervorgehoben und prim√§rer Aktionsbutton st√§rker gewichtet.',
          'UI: Mini-Regel√ºbersicht in strukturierte Abschnitte mit Listen aufgeteilt.'
        ]
      },
      {
        ver: 'v0.14',
        date: '2025-12-28',
        items: [
          'UI: Aktionsleiste b√ºndelt Event- und Entscheidungs-Buttons f√ºr eine kompakte Bedienung ohne Scrollen.',
          'UI: Layout gestrafft, Log/Regeln sind innerhalb der Karten scrollbar, damit die Spielfl√§che im Viewport bleibt.',
          'UI: Regelhilfe zur Camp-Phase als einklappbarer Bereich im Event-Bereich.'
        ]
      },
      {
        ver: 'v0.13',
        date: '2025-12-27',
        items: [
          'Neu: Kartenoptik f√ºr Deck, Ablage und zuletzt aufgedeckte Karte, damit man den Spielfluss besser sieht.',
          'UI: Zus√§tzliche Kartenfl√§che mit Live-Infos zur zuletzt aufgedeckten Karte.'
        ]
      },
      {
        ver: 'v0.12',
        date: '2025-12-26',
        items: [
          'Fix: JavaScript Syntaxfehler entfernt (Sieg-Log/Flash, Toast beim Knall, Klammerung bei Stabilisieren).',
          'Neu: Zus√§tzliche Self-Tests f√ºr Stabilisieren-Ertrag und Anti-Solo-Pool-Verwurf.'
        ]
      },
      {
        ver: 'v0.11',
        date: '2025-12-26',
        items: [
          'Patch P2: Stabilisieren-Ertrag nur noch im roten Bereich (Overload vor dem Senken 8+ ‚Üí +1 Live, sonst kein Ertrag).',
          'Patch P2: Pool-Bonus eindeutig ‚Äì ma√ügeblich ist der Overload nach dem Event (inkl. Countdown/Checks) direkt vor der Entscheidung.',
          'Patch P2: Anti-Solo-Downtime ‚Äì letzter aktiver Spieler bekommt keinen Pool-Bonus, Rest-Pool wird verworfen.',
          'Optional: Checkbox f√ºr aggressiven Countdown (+1 extra wenn Pool ‚â•3).'
        ]
      },
      {
        ver: 'v0.10',
        date: '2025-12-26',
        items: [
          'Patch 0.7-PL-P1: Camp nur mit mindestens 1 Live (kein ‚ÄûCamp bei 0‚Äú).',
          'Patch 0.7-PL-P1: Pool-Verteilung in Durchl√§ufen (erst jeder 1, dann bei Overload 8+ ggf. jeder 1).',
          'Patch 0.7-PL-P1: Countdown startet erst beim ersten erfolgreichen Camp (mit Live).',
          'Patch 0.7-PL-P1: Stabilisieren buff ‚Äì Aufdecker erh√§lt immer 1 Live (Pool ‚Üí sonst Vorrat).',
          'Patch 0.7-PL-P1: Anti-Solo-Downtime ‚Äì sobald nur noch 1 Spieler aktiv ist, endet die Runde sofort.'
        ]
      },
      {
        ver: 'v0.9',
        date: '2025-12-26',
        items: [
          'Neu: Autoplay (Zuschauermodus) ‚Äì Bots spielen automatisch weiter (Aufdecken + Entscheidungen), inkl. Auto-Entscheidungen f√ºr ‚ÄûDu‚Äú.',
          'Neu: Tempo-Auswahl f√ºr Autoplay.'
        ]
      },
      {
        ver: 'v0.8',
        date: '2025-12-26',
        items: [
          'Neu: Integrierte Push-your-Luck-Version ohne Handkarten: Event aufdecken ‚Üí simultan Bleib/Camp.',
          'Neu: B√ºhnen-Pool (Mitte) + Pool-Bonus beim Campen (1 oder 2 je nach Overload).',
          'Neu: Encore als Ketten-Event (Aufdecker kann 1 Live zahlen, um zu stoppen).',
          'Neu: Overload-Check bei 12 mit Katastrophen-Check (Push = Knall, sonst R√ºcksto√ü auf 10).',
          'Neu: Countdown nach erstem Camper (+1 Overload nach jedem weiteren Event).'
        ]
      }
    ];

    var WIN_CAMP = 8;
    var MAX_OVERLOAD = 12;

    var BOT_MODULES = [
      {
        id: 'standard',
        name: 'Standard',
        decideCamp: function(ctx){
          var p = ctx.player;
          if (p.roundState !== 'active') return 'stay';
          if (p.forcedStay) return 'stay';
          if (p.live <= 0) return 'stay';
          if (ctx.finalCamp) return 'camp';
          if (p.camp + p.live >= WIN_CAMP) return 'camp';
          if (p.live >= 4) return 'camp';
          if (ctx.overload >= 9) return 'camp';
          if (ctx.overload >= 7 && p.live >= ctx.minLiveForPool && ctx.pool > 0 && ctx.poolGate > 0) return 'camp';
          return 'stay';
        },
        stopEncore: function(ctx){
          var p = ctx.player;
          if (p.live <= 0){
            if (ctx.overload >= 10) return true;
            if (ctx.overload >= 8) return (rand() < 0.45);
            return (rand() < 0.2);
          }
          if (ctx.overload >= 10) return true;
          if (p.live >= 2 && rand() < 0.7) return true;
          return (rand() < 0.25);
        },
        stageDivePay: function(ctx){
          var p = ctx.player;
          if (p.live <= 0) return false;
          if (ctx.overload >= 8) return true;
          if (p.camp + p.live >= WIN_CAMP - 1) return true;
          return (rand() < 0.45);
        },
        pickStageDiveTarget: function(ctx){
          var best = -1;
          var bestLive = -1;
          for (var i=0;i<ctx.players.length;i++){
            if (i === ctx.revealer) continue;
            var candidate = ctx.players[i];
            if (candidate.roundState !== 'active') continue;
            if (candidate.live > bestLive){ bestLive = candidate.live; best = i; }
          }
          if (best === -1) best = ctx.revealer;
          return best;
        }
      }
    ];

    var state = {
      round: 1,
      overload: 0,
      pool: 0,
      uiMode: 'play',
      activeEffects: [],
      uiHeadline: null,
      uiHeadlineTimer: null,
      playBannerTimer: null,
      stageRule: null, // { name, text, fx, _cardRef }
      feedbackLevel: 0,
      countdownActive: false,
      direction: 1, // 1 clockwise, -1 counter
      startPlayer: 0,
      revealer: 0,
      extraRevealSame: false,
      moodDeck: [],
      twistEffects: { pyro:false, richtungswechsel:false, afterparty:false },
      forceFinalCampWindow: false,
      skipCountdownOnce: false,

      deck: [],
      discard: [],

      players: [],
      humanIndex: 0,
      botProfileId: 'standard',
      botCount: 3,

      awaitingDecision: false,
      humanChoice: 'stay', // 'stay' | 'camp'
      botChoices: {},
      lastEvent: null,
      gameOver: false,

      turnId: 0,
      askOpen: false,
      encoreChain: 0,
      humanLockedIn: false,
      finalPushUsed: false,
      logSubStep: 0,
      debugSnapshots: [],
      debugLogEntries: [],
      rngSeed: Date.now(),
      rngState: 0,
      rngStep: 0,
      lastGlobalSnapshot: null,
      decisionWindowId: 0,
      debugAssertFail: false,
      debugAssertTriggered: false,
      finalPushGraceUsed: false,
      finalPushForceNext: false,
      finalPushActor: -1,
      catchUpGrantedRound: {},

      autoTimer: null,
      decisionTimer: { enabled:true, seconds:20, remaining:20, timerId:null },

      phase: 'reveal',
      banner: null,
      lastSummary: null,
      roundResetId: 0
    };

    // ---------- helpers ----------
    function esc(s){
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;');
    }

    function unescapeText(s){
      return String(s)
        .replace(/&quot;/g,'"')
        .replace(/&#39;/g,"'")
        .replace(/&lt;/g,'<')
        .replace(/&gt;/g,'>')
        .replace(/&amp;/g,'&');
    }

    function cardCountLabel(n){
      return n + (n === 1 ? ' Karte' : ' Karten');
    }

    function formatStateLine(overBefore, overAfter, poolBefore, poolAfter, liveBefore, liveAfter, campBefore, campAfter){
      return 'Overload ' + overBefore + '‚Üí' + overAfter +
        ' ¬∑ Pool ' + poolBefore + '‚Üí' + poolAfter +
        ' ¬∑ Live ' + liveBefore + '‚Üí' + liveAfter +
        ' ¬∑ Camp ' + campBefore + '‚Üí' + campAfter;
    }

    function formatOverPoolLine(overBefore, overAfter, poolBefore, poolAfter){
      return 'Overload ' + overBefore + '‚Üí' + overAfter + ' ¬∑ Pool ' + poolBefore + '‚Üí' + poolAfter;
    }

    function formatDelta(delta){
      return (delta >= 0 ? '+' : '') + delta;
    }

    function resetLogSubStep(){
      state.logSubStep = 0;
    }

    function nextLogStepId(){
      state.logSubStep = (state.logSubStep || 0) + 1;
      return 'R' + state.round + '-T' + state.turnId + '-S' + state.logSubStep;
    }

    function actorSnapshot(actorIdx){
      if (typeof actorIdx !== 'number' || !state.players[actorIdx]){
        return {
          overload: state.overload,
          pool: state.pool,
          live: null,
          camp: null
        };
      }
      return {
        overload: state.overload,
        pool: state.pool,
        live: state.players[actorIdx].live,
        camp: state.players[actorIdx].camp
      };
    }

    function formatValue(val){
      if (val === null || typeof val === 'undefined') return '‚Äî';
      return String(val);
    }

    function formatReasonBlock(reasons, before, after){
      if (!reasons) return '';
      var parts = [];
      if (reasons.overload && before.overload !== after.overload) parts.push('OverloadChangeReason="' + esc(reasons.overload) + '"');
      if (reasons.pool && before.pool !== after.pool) parts.push('PoolChangeReason="' + esc(reasons.pool) + '"');
      if (reasons.live && before.live !== null && after.live !== null && before.live !== after.live) parts.push('LiveChangeReason="' + esc(reasons.live) + '"');
      if (reasons.camp && before.camp !== null && after.camp !== null && before.camp !== after.camp) parts.push('CampChangeReason="' + esc(reasons.camp) + '"');
      return parts.join(' | ');
    }

    function normalizeDetail(msgHtml){
      if (!msgHtml) return null;
      var text = String(msgHtml)
        .replace(/<br\s*\/?>/gi, ' ')
        .replace(/<[^>]+>/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      if (!text) return null;
      return unescapeText(text).replace(/\|/g, '/');
    }

    function isPlayerActor(actorIdx){
      return (typeof actorIdx === 'number' && state.players[actorIdx]);
    }

    function getGlobalSnapshot(){
      return {
        feedbackLevel: feedbackLevel(),
        countdownActive: !!state.countdownActive,
        direction: state.direction,
        activePlayers: getActivePlayerNames()
      };
    }

    function getActivePlayerNames(){
      var names = [];
      for (var i=0;i<state.players.length;i++){
        if (state.players[i].roundState === 'active') names.push(state.players[i].name);
      }
      return names;
    }

    function formatDirection(val){
      return (val === -1) ? 'ccw' : 'cw';
    }

    function formatActivePlayers(list){
      return '[' + list.join(', ') + ']';
    }

    function deriveEffectId(msg){
      var text = String(msg || '').toLowerCase();
      if (text.indexOf('stage_dive') !== -1 || text.indexOf('stage dive') !== -1) return EFFECT_IDS.STAGE_DIVE;
      if (text.indexOf('push') !== -1) return EFFECT_IDS.PUSH;
      if (text.indexOf('stabilisieren') !== -1 || text.indexOf('stabilize') !== -1) return EFFECT_IDS.STABILIZE;
      if (text.indexOf('feedback') !== -1) return EFFECT_IDS.FEEDBACK_LEVEL_UP;
      if (text.indexOf('encore_chain') !== -1 || text.indexOf('encore chain') !== -1) return EFFECT_IDS.ENCORE_CHAIN_START;
      if (text.indexOf('encore_stop') !== -1 || text.indexOf('encore stop') !== -1) return EFFECT_IDS.ENCORE_STOP;
      return EFFECT_IDS.UNKNOWN;
    }

    function buildLogLine(data){
      var parts = [];
      parts.push('ActionType=' + data.ActionType);
      parts.push('Actor=' + data.Actor);
      parts.push('Overload=' + data.Overload.before + '->' + data.Overload.after);
      parts.push('Pool=' + data.Pool.before + '->' + data.Pool.after);
      if (data.Live){
        parts.push('Live=' + data.Live.before + '->' + data.Live.after);
      }
      if (data.Camp){
        parts.push('Camp=' + data.Camp.before + '->' + data.Camp.after);
      }
      parts.push('Reason=' + data.Reason);
      if (data.Flags && data.Flags.length){
        parts = parts.concat(data.Flags);
      }
      if (data.Fields && data.Fields.length){
        parts = parts.concat(data.Fields);
      }
      if (data.ChangeReasons && data.ChangeReasons.length){
        parts = parts.concat(data.ChangeReasons);
      }
      return parts.join(' | ');
    }

    function validateLogLine(data){
      var issues = [];
      if (!data.ActionType) issues.push('ActionType fehlt');
      if (!data.Actor) issues.push('Actor fehlt');
      if (!data.Reason) issues.push('Reason fehlt');
      if (!data.Overload || typeof data.Overload.before === 'undefined' || typeof data.Overload.after === 'undefined'){
        issues.push('Overload fehlt');
      }
      if (!data.Pool || typeof data.Pool.before === 'undefined' || typeof data.Pool.after === 'undefined'){
        issues.push('Pool fehlt');
      }
      if (data.Actor === 'System' && (data.Live || data.Camp)){
        issues.push('System darf keine Live/Camp-Werte loggen');
      }
      return issues;
    }

    function validateStateInvariants(){
      var issues = [];
      if (state.overload < 0 || state.overload > MAX_OVERLOAD) issues.push('Overload au√üerhalb 0..12');
      if (state.pool < 0) issues.push('Pool unter 0');
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (p.live < 0) issues.push('Live unter 0 bei ' + p.name);
        if (p.camp < 0) issues.push('Camp unter 0 bei ' + p.name);
      }
      if (state.activePlayers && state.activePlayers.length){
        var actual = getActivePlayerNames();
        if (state.activePlayers.join('|') !== actual.join('|')) issues.push('ActivePlayers passt nicht zu roundState');
      }
      if (state.debugAssertFail && !state.debugAssertTriggered){
        state.debugAssertTriggered = true;
        issues.push('DebugAssertFail aktiviert');
      }
      return issues;
    }

    function appendLogEntry(targetEl, cls, hh, mm, stepId, line){
      if (!targetEl) return;
      var entry = document.createElement('div');
      entry.className = 'evt ' + cls;
      var timeSpan = document.createElement('span');
      timeSpan.className = 't';
      timeSpan.textContent = '[' + hh + ':' + mm + ']';
      var stepSpan = document.createElement('span');
      stepSpan.className = 't';
      stepSpan.textContent = '(' + stepId + ')';
      entry.appendChild(timeSpan);
      entry.appendChild(document.createTextNode(' '));
      entry.appendChild(stepSpan);
      entry.appendChild(document.createTextNode(' ' + line));
      targetEl.appendChild(entry);
      targetEl.scrollTop = targetEl.scrollHeight;
    }

    function logStep(kind, opts){
      var el = document.getElementById('log');
      var play = document.getElementById('logPlay');
      var t = new Date();
      var hh = String(t.getHours()); if (hh.length < 2) hh = '0'+hh;
      var mm = String(t.getMinutes()); if (mm.length < 2) mm = '0'+mm;
      var cls = kind || 'info';
      var stepId = nextLogStepId();
      var actor = opts.actor || 'System';
      var action = opts.action || 'CHECK';
      var actorIdx = (typeof opts.actorIdx === 'number') ? opts.actorIdx : null;
      var before = opts.before || actorSnapshot(actorIdx);
      var after = opts.after || actorSnapshot(actorIdx);
      if (actor === 'System'){
        before = { overload: before.overload, pool: before.pool, live: null, camp: null };
        after = { overload: after.overload, pool: after.pool, live: null, camp: null };
      }
      var reasonText = opts.reason || (opts.reasons && opts.reasons.extra) || action;
      var includeActorValues = (actor !== 'System' && isPlayerActor(actorIdx));
      var reasonBlock = formatReasonBlock(opts.reasons, before, after);
      var detail = normalizeDetail(opts.msgHtml);
      var fields = [];
      var fieldMap = opts.fields || {};
      if (action === 'EFFECT'){
        fieldMap.EffectId = opts.effectId || fieldMap.EffectId || deriveEffectId(opts.msgHtml);
      }
      for (var k in fieldMap){
        if (Object.prototype.hasOwnProperty.call(fieldMap, k) && typeof fieldMap[k] !== 'undefined' && fieldMap[k] !== null){
          fields.push(k + '=' + fieldMap[k]);
        }
      }
      if (detail) fields.push('Detail=' + detail);
      var globalBefore = opts.globalBefore || state.lastGlobalSnapshot || getGlobalSnapshot();
      var globalAfter = opts.globalAfter || getGlobalSnapshot();
      var flagParts = [];
      flagParts.push('FeedbackLevel=' + globalBefore.feedbackLevel + '->' + globalAfter.feedbackLevel);
      flagParts.push('CountdownActive=' + globalBefore.countdownActive + '->' + globalAfter.countdownActive);
      flagParts.push('Direction=' + formatDirection(globalBefore.direction) + '->' + formatDirection(globalAfter.direction));
      if (globalBefore.activePlayers.join('|') !== globalAfter.activePlayers.join('|')){
        flagParts.push('ActivePlayers=' + formatActivePlayers(globalBefore.activePlayers) + '->' + formatActivePlayers(globalAfter.activePlayers));
      }
      var changeReasons = [];
      if (reasonBlock) changeReasons = reasonBlock.split(' | ');
      var data = {
        ActionType: action,
        Actor: actor,
        Overload: { before: before.overload, after: after.overload },
        Pool: { before: before.pool, after: after.pool },
        Reason: reasonText,
        Flags: flagParts,
        Fields: fields,
        ChangeReasons: changeReasons
      };
      if (includeActorValues){
        data.Live = { before: before.live, after: after.live };
        data.Camp = { before: before.camp, after: after.camp };
      }
      var line = buildLogLine(data);
      appendLogEntry(el, cls, hh, mm, stepId, line);
      appendLogEntry(play, cls, hh, mm, stepId, line);
      state.debugLogEntries.push({
        stepId: stepId,
        time: '[' + hh + ':' + mm + ']',
        line: line,
        data: data
      });
      state.lastGlobalSnapshot = globalAfter;
      recordDebugSnapshot(action);
      if (!logStep._guard){
        logStep._guard = true;
        var logIssues = validateLogLine(data);
        var stateIssues = validateStateInvariants();
        if (logIssues.length || stateIssues.length){
          console.warn('Log/State Validation', logIssues.concat(stateIssues));
          logStep('bad', {
            action: 'ASSERT_FAIL',
            actor: 'System',
            reason: 'AssertFail',
            before: { overload: state.overload, pool: state.pool, live: null, camp: null },
            after: { overload: state.overload, pool: state.pool, live: null, camp: null },
            fields: { Issue: esc(logIssues.concat(stateIssues).join(', ')) }
          });
        }
        logStep._guard = false;
      }
    }

    function recordDebugSnapshot(label){
      var activeNames = getActivePlayerNames();
      var playersSnapshot = {};
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        playersSnapshot[p.name] = {
          live: p.live,
          camp: p.camp,
          roundState: p.roundState,
          forcedStay: !!p.forcedStay
        };
      }
      state.debugSnapshots.push({
        round: state.round,
        turn: state.turnId,
        substep: state.logSubStep,
        overload: state.overload,
        pool: state.pool,
        feedbackLevel: feedbackLevel(),
        countdownActive: state.countdownActive,
        direction: state.direction,
        activePlayers: activeNames,
        players: playersSnapshot,
        deck: {
          remaining: state.deck.length,
          discardCount: state.discard.length,
          topIndex: state.deck.length ? (state.deck.length - 1) : -1
        },
        rng: { seed: state.rngSeed, step: state.rngStep },
        label: label || ''
      });
    }

    function exportDebug(){
      var payload = JSON.stringify({
        snapshots: state.debugSnapshots,
        logs: state.debugLogEntries
      }, null, 2);
      if (!payload){ toast('Debug leer', 'Keine Snapshots vorhanden.'); return payload; }
      if (navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(payload)
          .then(function(){ toast('Debug kopiert', 'JSON wurde kopiert.'); })
          .catch(function(){ fallbackCopy(payload); });
      } else {
        fallbackCopy(payload);
      }
      return payload;
    }

    function normalizeRevealerIndex(){
      var n = state.players.length;
      if (!n) return -1;
      var idx = Number(state.revealer);
      if (!isFinite(idx)) idx = 0;
      idx = Math.floor(idx);
      if (idx < 0 || idx >= n) idx = 0;
      return idx;
    }

    function clampBotCount(count){
      var safeCount = Number(count);
      if (!isFinite(safeCount)) safeCount = MIN_BOTS;
      // Bot-Anzahl muss ganzzahlig bleiben, sonst entstehen inkonsistente Zust√§nde.
      safeCount = Math.round(safeCount);
      if (safeCount < MIN_BOTS) return MIN_BOTS;
      if (safeCount > MAX_BOTS) return MAX_BOTS;
      return safeCount;
    }

    function botNameForIndex(idx){
      var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      if (idx < letters.length) return 'Bot ' + letters.charAt(idx);
      return 'Bot ' + (idx + 1);
    }

    function buildPlayers(botCount){
      // Spieler-Setup neu aufbauen (nur vor Spielstart anpassen).
      var list = [
        { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false }
      ];

      for (var i=0;i<botCount;i++){
        list.push({
          name: botNameForIndex(i),
          camp: 0,
          live: 0,
          roundState: 'active',
          forcedStay: false,
          botId: state.botProfileId
        });
      }
      return list;
    }

    function canAdjustBots(){
      return state.turnId === 0 && !state.awaitingDecision && !state.gameOver;
    }

    function toast(msg, sub){
      sub = sub || '';
      var el = document.getElementById('toast');
      el.innerHTML = '<div><b>' + esc(msg) + '</b></div>' + (sub ? '<small>' + esc(sub) + '</small>' : '');
      el.style.display = 'block';
      if (toast._t) clearTimeout(toast._t);
      toast._t = setTimeout(function(){ el.style.display = 'none'; }, 2200);
    }

    function log(kind, msgHtml){
      logStep(kind, {
        action: 'CHECK',
        actor: 'System',
        msgHtml: msgHtml,
        before: actorSnapshot(null),
        after: actorSnapshot(null)
      });
    }

    function seedRng(seed){
      var s = Number(seed);
      if (!isFinite(s)) s = Date.now();
      s = Math.floor(Math.abs(s));
      if (s === 0) s = 1;
      state.rngSeed = s;
      state.rngState = s >>> 0;
      state.rngStep = 0;
      return s;
    }

    function rand(){
      state.rngStep = (state.rngStep || 0) + 1;
      if (!state.rngState) seedRng(state.rngSeed);
      state.rngState = (state.rngState * 1664525 + 1013904223) >>> 0;
      return state.rngState / 4294967296;
    }

    function shuffle(a){
      var arr = a.slice();
      for (var i = arr.length - 1; i > 0; i--) {
        var j = Math.floor(rand() * (i + 1));
        var tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
      }
      return arr;
    }

    function draw(n){
      if (typeof n === 'undefined') n = 1;
      var out = [];
      for (var i=0;i<n;i++){
        if (!state.deck.length){
          if (state.discard.length){
            state.deck = shuffle(state.discard);
            state.discard = [];
            logStep('warn', {
              action: 'CHECK',
              actor: 'System',
              msgHtml: '<b>Deck leer</b> ‚Äì Ablage wird gemischt.',
              before: actorSnapshot(null),
              after: actorSnapshot(null),
              reasons: { extra: 'DeckReshuffle' }
            });
          } else {
            logStep('bad', {
              action: 'CHECK',
              actor: 'System',
              msgHtml: '<b>Deck & Ablage leer</b> ‚Äì keine Karte verf√ºgbar.',
              before: actorSnapshot(null),
              after: actorSnapshot(null),
              reasons: { extra: 'DeckEmpty' }
            });
            break;
          }
        }
        var deckPos = state.deck.length - 1;
        var card = state.deck.pop();
        if (card){
          card._drawMeta = {
            deckPos: deckPos,
            deckRemaining: state.deck.length,
            discardCount: state.discard.length
          };
        }
        out.push(card);
      }
      return out;
    }

    function resetMoodDeck(){
      // Crowd-Mood-Deck wird zu Rundenbeginn frisch gemischt.
      state.moodDeck = shuffle(MOOD_DECK_BASE);
    }

    function drawCrowdMoodValue(){
      // Zyklisches Ziehen: wenn leer, neu mischen.
      if (!state.moodDeck || !state.moodDeck.length) resetMoodDeck();
      return state.moodDeck.pop();
    }

    function clampOverload(x){ return Math.max(0, Math.min(MAX_OVERLOAD, x)); }

    function clampStateAfterCard(){
      // Nach jeder Kartenaufl√∂sung: Werte in g√ºltige Bereiche zwingen.
      state.overload = clampOverload(state.overload);
      state.pool = Math.max(0, state.pool);
      for (var i=0;i<state.players.length;i++){
        state.players[i].live = Math.max(0, state.players[i].live);
        state.players[i].camp = Math.max(0, state.players[i].camp);
      }
    }

    function resetTwistEffects(){
      state.twistEffects = { pyro:false, richtungswechsel:false, afterparty:false };
    }

    function isTwistActive(key){
      return !!(state.twistEffects && state.twistEffects[key]);
    }

    function minLiveForPool(){
      var minLive = MIN_LIVE_FOR_POOL_BASE;
      if (isTwistActive('richtungswechsel')) minLive += 1;
      return minLive;
    }

    function maxPoolToCampThisCamp(){
      if (state.overload >= 10) return 2;
      if (state.overload >= 7) return 1;
      return 0;
    }

    function countdownTickValue(){
      return isTwistActive('afterparty') ? 2 : 1;
    }

    function controlMode(){
      var el = document.getElementById('optControlMode');
      return (el && el.value) ? el.value : 'bots-auto';
    }

    function isAutoAll(){
      return controlMode() === 'all-auto';
    }

    function areBotsAuto(){
      var mode = controlMode();
      return (mode === 'bots-auto' || mode === 'all-auto');
    }

    function areBotsManual(){
      return controlMode() === 'bots-manual';
    }

    function isAggCountdown(){
      var el = document.getElementById('optAggCountdown');
      return !!(el && el.checked);
    }

    function getAutoDelay(){
      var el = document.getElementById('optSpeed');
      var v = el ? Number(el.value) : 650;
      if (!isFinite(v) || v <= 0) v = 650;
      return Math.max(60, Math.min(3000, v));
    }

    function scheduleAuto(fn){
      if (state.autoTimer) { clearTimeout(state.autoTimer); state.autoTimer = null; }
      state.autoTimer = setTimeout(fn, getAutoDelay());
    }

    function stopAutoTimer(){
      if (state.autoTimer) { clearTimeout(state.autoTimer); state.autoTimer = null; }
    }

    function anyActive(){
      for (var i=0;i<state.players.length;i++) if (state.players[i].roundState === 'active') return true;
      return false;
    }

    function activeCount(){
      var c=0;
      for (var i=0;i<state.players.length;i++) if (state.players[i].roundState === 'active') c++;
      return c;
    }

    function getLastActiveIndex(){
      for (var i=0;i<state.players.length;i++) if (state.players[i].roundState === 'active') return i;
      return -1;
    }

    function nextActiveFrom(startIdx, step){
      var n = state.players.length;
      for (var k=1;k<=n;k++){
        var idx = (startIdx + k*step + n*1000) % n;
        if (state.players[idx].roundState === 'active') return idx;
      }
      return -1;
    }

    function orderFrom(startIdx, step){
      var n = state.players.length;
      var out = [];
      for (var k=0;k<n;k++) out.push((startIdx + k * step + n * 1000) % n);
      return out;
    }

    function darfPoolZuCamp(live){
      // Pool‚ÜíCamp ist nur erlaubt, wenn die Live-Schwelle erreicht ist.
      return live >= minLiveForPool();
    }

    function darfJetztCampen(p){
      return p.roundState === 'active' && p.live > 0;
    }

    function poolTakeFor(pool, maxPerCamper){
      return Math.min(pool, Math.max(0, maxPerCamper || 0));
    }

    function planCampPoolDistribution(order, poolAvailable, maxPerCamper){
      var perCap = Math.max(0, maxPerCamper || 0);
      var takes = {};
      for (var i=0;i<order.length;i++) takes[String(order[i])] = 0;
      var rounds = [];
      var remaining = poolAvailable;
      for (var r=0;r<perCap && remaining > 0;r++){
        var round = [];
        for (var j=0;j<order.length;j++){
          if (remaining <= 0) break;
          var idx = order[j];
          if (takes[String(idx)] >= perCap) continue;
          takes[String(idx)] += 1;
          remaining -= 1;
          round.push(idx);
        }
        if (round.length) rounds.push(round);
      }
      return { takes: takes, rounds: rounds, maxPerCamper: perCap };
    }

    function describeOverloadCap(before, add, after){
      return (before + add > MAX_OVERLOAD && after === MAX_OVERLOAD) ? ' (cap)' : '';
    }

    function describeOverloadFloor(before, sub, after){
      return (before - sub < 0 && after === 0) ? ' (min 0)' : '';
    }

    function labelType(t){
      if (t === 'push') return { txt:'Push', dot:'var(--bad)', icon:'‚ö°' };
      if (t === 'stabilize') return { txt:'Stabilisieren', dot:'var(--good)', icon:'üõ†Ô∏è' };
      if (t === 'twist') return { txt:'Twist', dot:'var(--warn)', icon:'üåÄ' };
      if (t === 'encore') return { txt:'Encore', dot:'var(--blue)', icon:'üé§' };
      return { txt:t, dot:'rgba(148,163,184,.6)', icon:'‚ùî' };
    }

    function getBotModule(botId){
      for (var i=0;i<BOT_MODULES.length;i++){
        if (BOT_MODULES[i].id === botId) return BOT_MODULES[i];
      }
      return BOT_MODULES[0];
    }

    function botCtx(idx){
      return {
        player: state.players[idx],
        players: state.players,
        overload: state.overload,
        pool: state.pool,
        revealer: state.revealer,
        minLiveForPool: minLiveForPool(),
        poolGate: maxPoolToCampThisCamp(),
        finalCamp: !!state.forceFinalCampWindow
      };
    }

    function botProfilePick(){
      var el = document.getElementById('optBotProfile');
      return (el && el.value) ? el.value : state.botProfileId;
    }

    function screenFlash(kind){
      try{
        document.body.classList.remove('flashBad','flashGood');
        void document.body.offsetWidth;
        if (kind === 'bad') document.body.classList.add('flashBad');
        else if (kind === 'good') document.body.classList.add('flashGood');
        setTimeout(function(){ document.body.classList.remove('flashBad','flashGood'); }, 650);
      } catch(e){}
    }

    function flashStat(id, kind, deltaText){
      var el = document.getElementById(id);
      if (!el) return;
      var cls = 'flash-' + (kind || 'warn');

      // delta badge
      var b = el.querySelector('.deltaBadge');
      if (!b){
        b = document.createElement('span');
        b.className = 'deltaBadge';
        el.appendChild(b);
      }
      b.textContent = deltaText || '';

      el.classList.remove('flash-good','flash-warn','flash-bad','flash-blue');
      void el.offsetWidth;
      el.classList.add(cls);

      setTimeout(function(){
        el.classList.remove('flash-good','flash-warn','flash-bad','flash-blue');
      }, 560);
    }

    function impactHTML(c){
      if (!c) return '‚Äî';
      var t = c.type;
      var parts = [];

      if (t === 'push'){
        var add = (c.delta || 1) + feedbackLevel();
        parts.push('<span class="imp bad">‚ö° <b>Overload +' + add + ' (+ Crowd-Mood)</b></span>');
        parts.push('<span class="imp blue">üéüÔ∏è <b>Aufdecker +1 Live</b></span>');
        parts.push('<span class="imp warn">üéÅ <b>Pool +1</b></span>');
        if (hasFeedbackRule()) parts.push('<span class="imp warn">üåÄ‚àû <b>Feedback L' + feedbackLevel() + ' aktiv</b></span>');
        if (isTwistActive('pyro')) parts.push('<span class="imp bad">üî• <b>Pyro aktiv: +1 Overload</b></span>');
        parts.push('<span class="imp blue">üë• <b>Danach: Entscheidung</b></span>');
      }
      else if (t === 'stabilize'){
        var d = (typeof c.delta === 'number' ? c.delta : -2);
        parts.push('<span class="imp good">üõ†Ô∏è <b>Overload ' + d + '</b></span>');
        parts.push('<span class="imp blue">üéüÔ∏è <b>+1 Live nur bei Overload 9+ vorher</b></span>');
        parts.push('<span class="imp warn">üéÅ <b>Pool +0</b></span>');
        parts.push('<span class="imp blue">üë• <b>Danach: Entscheidung</b></span>');
      }
      else if (t === 'twist'){
        if (c.stage){
          parts.push('<span class="imp warn">üåÄ‚àû <b>B√ºhnenregel</b></span>');
          parts.push('<span class="imp blue">‚è≥ <b>Gilt bis Rundenende</b></span>');
        } else {
          parts.push('<span class="imp warn">üåÄ <b>Rundeneffekt bis Rundenende</b></span>');
        }
        if (c.fx === 'pyro') parts.push('<span class="imp bad">üî• <b>Push +1 Overload</b></span>');
        if (c.fx === 'flipDir') parts.push('<span class="imp warn">üîÑ <b>Pool‚ÜíCamp erst ab Live 3</b></span>');
        if (c.fx === 'afterparty') parts.push('<span class="imp warn">üéâ <b>Countdown sofort, Tick +2</b></span>');
        if (c.fx === 'stageDive') parts.push('<span class="imp bad">ü™Ç <b>Ziel: zahlen 1 Live oder muss bleiben</b></span>');
        parts.push('<span class="imp blue">üë• <b>Danach: Entscheidung</b></span>');
      }
      else if (t === 'encore'){
        parts.push('<span class="imp blue">üé§ <b>Endkarte: Encore!</b></span>');
        parts.push('<span class="imp blue">üéüÔ∏è <b>Alle Aktiven +1 Live</b></span>');
        parts.push('<span class="imp warn">üèïÔ∏è <b>Finale Camp-Entscheidung</b></span>');
      }
      else {
        parts.push('<span class="imp">Event</span>');
      }

      return parts.join('');
    }

    function setEventCard(card, extraText){
      var c = card || { type:'twist', name:'Bereit', text:'Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten.' };
      var meta = labelType(c.type);

      var el = document.getElementById('eventCard');
      el.setAttribute('data-type', c.type);
      el.classList.remove('pop');
      void el.offsetWidth;
      el.classList.add('pop');

      document.getElementById('eventName').textContent = c.name;
      document.getElementById('eventType').innerHTML = '<span class="dot" style="background:'+meta.dot+'"></span> '+meta.icon+' '+meta.txt;

      var imp = document.getElementById('eventImpact');
      if (imp) imp.innerHTML = impactHTML(card) + (extraText ? '<span class="imp blue">‚õìÔ∏è <b>' + esc(extraText) + '</b></span>' : '');

      document.getElementById('eventText').innerHTML = esc(c.text) + (extraText ? '<br><span class="mini">'+esc(extraText)+'</span>' : '');

      var playCard = document.getElementById('playEventCard');
      if (playCard){
        playCard.setAttribute('data-type', c.type);
        playCard.classList.remove('pop');
        void playCard.offsetWidth;
        playCard.classList.add('pop');
      }
      var playName = document.getElementById('playEventName');
      if (playName) playName.textContent = c.name;
      var playType = document.getElementById('playEventType');
      if (playType) playType.innerHTML = '<span class="dot" style="background:'+meta.dot+'"></span> '+meta.icon+' '+meta.txt;
      var playText = document.getElementById('playEventText');
      if (playText) playText.textContent = c.text + (extraText ? ' ¬∑ ' + extraText : '');
      renderPlayChips(card);
    }

    function renderPlayChips(card){
      var wrap = document.getElementById('playEventChips');
      if (!wrap) return;
      if (!card){
        wrap.innerHTML = '<span class="playChip">Bereit</span>';
        return;
      }

      var chips = [];
      var t = card.type;
      var addFeedback = feedbackLevel();

      if (t === 'push'){
        chips.push({ cls:'bad', text:'Overload +' + ((card.delta || 1) + addFeedback) + ' (+ Mood)' });
        chips.push({ cls:'blue', text:(state.revealer === state.humanIndex ? '+1 Live (Du)' : 'Aufdecker +1 Live') });
        chips.push({ cls:'warn', text:'Pool +1' });
        if (isTwistActive('pyro')) chips.push({ cls:'bad', text:'Pyro aktiv: +1 Overload' });
      } else if (t === 'stabilize'){
        chips.push({ cls:'good', text:'Overload ' + (card.delta || -2) });
        chips.push({ cls:'blue', text:'Live +1 nur bei Overload 9+ vorher' });
        chips.push({ cls:'warn', text:'Pool +0' });
      } else if (t === 'twist'){
        if (card.stage) chips.push({ cls:'warn', text:'B√ºhnenregel: ' + card.name });
        if (card.fx === 'pyro') chips.push({ cls:'bad', text:'Push +1 Overload' });
        if (card.fx === 'flipDir') chips.push({ cls:'warn', text:'Pool‚ÜíCamp erst ab Live 3' });
        if (card.fx === 'afterparty') chips.push({ cls:'warn', text:'Countdown sofort, Tick +2' });
        if (card.fx === 'stageDive') chips.push({ cls:'bad', text:'Stage Dive' });
      } else if (t === 'encore'){
        chips.push({ cls:'blue', text:'Endkarte: Alle Aktiven +1 Live' });
        chips.push({ cls:'warn', text:'Finale Camp-Entscheidung' });
      }

      if (state.countdownActive) chips.push({ cls:'warn', text:'Countdown +' + countdownTickValue() });

      if (!chips.length) chips.push({ cls:'blue', text:'Event' });

      var html = '';
      for (var i=0;i<chips.length;i++){
        var c = chips[i];
        html += '<span class="playChip' + (c.cls ? ' ' + c.cls : '') + '">' + esc(c.text) + '</span>';
      }
      wrap.innerHTML = html;
    }

    function showPlayCheckCard(card){
      var playCard = document.getElementById('playEventCard');
      var playName = document.getElementById('playEventName');
      var playType = document.getElementById('playEventType');
      var playText = document.getElementById('playEventText');
      if (!playCard || !playName || !playType || !playText) return;

      var prev = {
        name: playName.textContent,
        type: playType.innerHTML,
        text: playText.textContent,
        dataType: playCard.getAttribute('data-type')
      };

      var meta = labelType(card.type);
      playCard.setAttribute('data-type', card.type);
      playName.textContent = 'Check: ' + card.name;
      playType.innerHTML = '<span class="dot" style="background:'+meta.dot+'"></span> '+meta.icon+' '+meta.txt;
      playText.textContent = card.text;
      renderPlayChips(card);

      setTimeout(function(){
        playCard.setAttribute('data-type', prev.dataType || 'twist');
        playName.textContent = prev.name;
        playType.innerHTML = prev.type;
        playText.textContent = prev.text;
        renderPlayChips(state.lastEvent);
      }, 700);
    }

    function updateRevealCard(){
      var card = state.lastEvent;
      var reveal = document.getElementById('revealCard');
      if (!reveal) return;

      if (!card){
        reveal.setAttribute('data-type', 'empty');
        document.getElementById('revealName').textContent = 'Noch keine Karte';
        document.getElementById('revealType').textContent = '‚Äî';
        document.getElementById('revealText').textContent = 'Klicke auf ‚ÄûEvent aufdecken‚Äú, um den ersten Draw zu sehen.';
        document.getElementById('revealMeta').textContent = '‚Äî';
        return;
      }

      var meta = labelType(card.type);
      reveal.setAttribute('data-type', card.type);
      document.getElementById('revealName').textContent = card.name;
      document.getElementById('revealType').textContent = meta.icon + ' ' + meta.txt;
      document.getElementById('revealText').textContent = card.text;
      document.getElementById('revealMeta').textContent = 'Aufgedeckt in T' + state.turnId;
    }

    // ---------- UX helpers (Phase / Banner / Summary) ----------
    function phaseLabel(){
      if (state.gameOver) return 'Spielende';
      if (state.askOpen) return 'Auswahl';
      if (state.awaitingDecision) return 'Entscheidung';
      if (state.phase === 'event') return 'Effekt';
      if (state.phase === 'countdown') return 'Countdown';
      return 'Aufdecken';
    }

    function updatePhasePill(){
      var el = document.getElementById('phase');
      if (!el) return;
      el.textContent = phaseLabel();
    }

    function updateStepsFor(id){
      var wrap = document.getElementById(id);
      if (!wrap) return;
      var phase = (state.gameOver ? 'decision' : (state.awaitingDecision ? 'decision' : (state.phase || 'reveal')));
      var steps = wrap.querySelectorAll('.step');
      for (var i=0;i<steps.length;i++){
        var s = steps[i];
        var st = s.getAttribute('data-step');
        var active = false;
        if (phase === 'reveal') active = (st === 'reveal');
        else if (phase === 'event') active = (st === 'event');
        else if (phase === 'countdown') active = (st === 'countdown');
        else if (phase === 'decision') active = (st === 'decision');
        s.classList.toggle('active', active);
      }
    }

    function renderSteps(){
      updateStepsFor('steps');
      updateStepsFor('playSteps');
    }

    function showBanner(kind, title, sub){
      var el = document.getElementById('banner');
      if (!el) return;
      var k = kind || 'info';
      el.innerHTML = '<b>' + esc(title || '') + '</b>' + (sub ? '<br><small>' + esc(sub) + '</small>' : '');
      el.className = 'banner show ' + ((k === 'good' || k === 'warn' || k === 'bad') ? k : '');
    }

    function clearBanner(){
      var el = document.getElementById('banner');
      if (!el) return;
      el.innerHTML = '';
      el.className = 'banner';
    }

    function setSummary(title, chips, foot){
      state.lastSummary = { title:title || 'Wirkung', chips: chips || [], foot: foot || '' };
      renderSummary();
    }

    function renderSummary(){
      var el = document.getElementById('eventSummary');
      if (!el) return;
      if (!state.lastSummary){
        el.innerHTML = '‚Äî';
        return;
      }
      var s = state.lastSummary;
      var h = '<div class="sumTitle"><b>' + esc(s.title) + '</b>' + (s.foot ? '<span class="mini">' + esc(s.foot) + '</span>' : '') + '</div><div class="sumRow">';
      for (var i=0;i<s.chips.length;i++){
        var c = s.chips[i];
        var cls = c.cls ? (' ' + c.cls) : '';
        h += '<span class="dChip' + cls + '"><span class="sym">' + esc(c.sym || '‚Ä¢') + '</span><span>' + esc(c.text || '') + '</span></span>';
      }
      h += '</div>';
      el.innerHTML = h;
    }

    function setPhase(p){
      state.phase = p || 'reveal';
      updatePhasePill();
      renderSteps();
    }

    function setUiMode(mode){
      state.uiMode = (mode === 'dev') ? 'dev' : 'play';
      document.body.classList.toggle('ui-play', state.uiMode === 'play');
      document.body.classList.toggle('ui-dev', state.uiMode === 'dev');
      var btnPlay = document.getElementById('btnModePlay');
      var btnDev = document.getElementById('btnModeDev');
      if (btnPlay) btnPlay.classList.toggle('active', state.uiMode === 'play');
      if (btnDev) btnDev.classList.toggle('active', state.uiMode === 'dev');
      updateUI();
    }

    function statusHeadlineText(){
      if (state.uiHeadline) return state.uiHeadline;
      if (state.gameOver) return 'Runde endet';
      if (state.forceFinalCampWindow) return 'Finale Camp-Entscheidung';
      if (state.awaitingDecision) return 'Alle entscheiden: Bleib oder Camp';
      if (state.phase === 'countdown') return (state.overload >= 12 ? 'Katastrophen-Check!' : 'Countdown l√§uft');
      if (state.phase === 'event') return 'Event wirkt';
      return 'Event aufdecken';
    }

    function setHeadline(text, ms){
      state.uiHeadline = text || null;
      updateUI();
      if (ms){
        if (state.uiHeadlineTimer) clearTimeout(state.uiHeadlineTimer);
        state.uiHeadlineTimer = setTimeout(function(){
          state.uiHeadline = null;
          updateUI();
        }, ms);
      }
    }

    function showPlayBanner(kind, text, ms){
      var el = document.getElementById('playBanner');
      if (!el) return;
      el.textContent = text || '';
      el.className = 'playBanner show ' + (kind || '');
      if (ms){
        if (state.playBannerTimer) clearTimeout(state.playBannerTimer);
        state.playBannerTimer = setTimeout(function(){
          el.className = 'playBanner';
          el.textContent = '';
        }, ms);
      }
    }

    function stopDecisionTimer(){
      var t = state.decisionTimer;
      if (t && t.timerId){
        clearInterval(t.timerId);
        t.timerId = null;
      }
    }

    function startDecisionTimer(){
      var t = state.decisionTimer;
      if (!t || !t.enabled) return;
      stopDecisionTimer();
      t.remaining = t.seconds;
      updateDecisionTimer();
      t.timerId = setInterval(function(){
        t.remaining -= 1;
        updateDecisionTimer();
        if (t.remaining <= 0){
          stopDecisionTimer();
          if (state.awaitingDecision){
            state.humanChoice = 'stay';
            state.humanLockedIn = true;
            updateUI();
            resolveDecisions();
          }
        }
      }, 1000);
    }

    function updateDecisionTimer(){
      var el = document.getElementById('decisionTimer');
      var t = state.decisionTimer;
      if (!el || !t) return;
      if (!t.enabled || !state.awaitingDecision){
        el.textContent = '‚Äî';
        return;
      }
      el.textContent = t.remaining + 's';
    }

    // ---------- modal helpers ----------
    function askYesNo(title, htmlText, yesLabel, noLabel, cb){
      var back = document.getElementById('askBack');
      var t = document.getElementById('askTitle');
      var body = document.getElementById('askText');
      var pick = document.getElementById('askPick');
      var yes = document.getElementById('askYes');
      var no = document.getElementById('askNo');
      var x = document.getElementById('askX');
      var btns = document.getElementById('askBtns');

      function close(val){
        if (!state.askOpen) return;
        state.askOpen = false;
        back.style.display = 'none';
        back.setAttribute('aria-hidden','true');
        yes.onclick = null; no.onclick = null; x.onclick = null; back.onclick = null;
        cb(!!val);
      }

      state.askOpen = true;
      t.textContent = title || 'Aktion';
      body.innerHTML = htmlText || '';
      pick.style.display = 'none';
      pick.innerHTML = '';
      btns.style.display = 'flex';
      yes.textContent = yesLabel || 'OK';
      no.textContent = noLabel || 'Abbrechen';

      yes.onclick = function(){ close(true); };
      no.onclick = function(){ close(false); };
      x.onclick = function(){ close(false); };
      back.onclick = function(e){ if (e.target && e.target.id === 'askBack') close(false); };

      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    function askPickOne(title, htmlText, options, cb){
      // options: [{ label, value }]
      var back = document.getElementById('askBack');
      var t = document.getElementById('askTitle');
      var body = document.getElementById('askText');
      var pick = document.getElementById('askPick');
      var no = document.getElementById('askNo');
      var x = document.getElementById('askX');
      var btns = document.getElementById('askBtns');

      function close(val){
        if (!state.askOpen) return;
        state.askOpen = false;
        back.style.display = 'none';
        back.setAttribute('aria-hidden','true');
        no.onclick = null; x.onclick = null; back.onclick = null;
        cb(val);
      }

      state.askOpen = true;
      t.textContent = title || 'Auswahl';
      body.innerHTML = htmlText || '';
      pick.style.display = 'flex';
      pick.innerHTML = '';
      btns.style.display = 'none';

      for (var i=0;i<options.length;i++){
        (function(opt){
          var b = document.createElement('button');
          b.className = 'btn blue pickBtn';
          b.textContent = opt.label;
          b.onclick = function(){ close(opt.value); };
          pick.appendChild(b);
        })(options[i]);
      }

      no.onclick = function(){ close(null); };
      x.onclick = function(){ close(null); };
      back.onclick = function(e){ if (e.target && e.target.id === 'askBack') close(null); };

      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    // ---------- UI ----------
    function updateUI(){
      // prev snapshot
      var prev = state._uiPrev || null;

      if (state.players.length){
        state.botCount = clampBotCount(Math.max(0, state.players.length - 1));
      }

      // F√ºhrungsstand ermitteln (h√∂chster Camp-Wert)
      var leaderLabel = 'Leader: ‚Äî ¬∑ Camp ‚Äî ¬∑ Abstand ‚Äî';
      if (state.players.length){
        var leaderName = state.players[0].name;
        var leaderCamp = state.players[0].camp;
        for (var l=1;l<state.players.length;l++){
          if (state.players[l].camp > leaderCamp){
            leaderCamp = state.players[l].camp;
            leaderName = state.players[l].name;
          }
        }
        var leaderDistance = Math.max(0, WIN_CAMP - leaderCamp);
        leaderLabel = 'Leader: ' + leaderName + ' ¬∑ Camp ' + leaderCamp + ' ¬∑ Abstand ' + leaderDistance;
      }

      var verText = document.getElementById('verText');
      if (verText) verText.textContent = VERSION;
      var playVer = document.getElementById('playVersion');
      if (playVer) playVer.textContent = VERSION;
      var roundNo = document.getElementById('roundNo');
      if (roundNo) roundNo.textContent = String(state.round);
      var eventNo = document.getElementById('eventNo');
      if (eventNo) eventNo.textContent = String(state.turnId);
      var overloadValue = document.getElementById('overloadValue');
      if (overloadValue) overloadValue.textContent = String(state.overload);
      var poolValue = document.getElementById('poolValue');
      if (poolValue) poolValue.textContent = String(state.pool);
      var poolValueSide = document.getElementById('poolValueSide');
      if (poolValueSide) poolValueSide.textContent = String(state.pool);
      var poolPlay = document.getElementById('poolValuePlay');
      if (poolPlay) poolPlay.textContent = String(state.pool);
      var deckCount = document.getElementById('deckCount');
      if (deckCount) deckCount.textContent = String(state.deck.length);
      var discardCount = document.getElementById('discardCount');
      if (discardCount) discardCount.textContent = String(state.discard.length);
      var deckCountPlay = document.getElementById('deckCountPlay');
      if (deckCountPlay) deckCountPlay.textContent = String(state.deck.length);
      var discardCountPlay = document.getElementById('discardCountPlay');
      if (discardCountPlay) discardCountPlay.textContent = String(state.discard.length);
      var deckCountMini = document.getElementById('deckCountMini');
      if (deckCountMini) deckCountMini.textContent = cardCountLabel(state.deck.length);
      var discardCountMini = document.getElementById('discardCountMini');
      if (discardCountMini) discardCountMini.textContent = cardCountLabel(state.discard.length);

      var leaderSummary = document.getElementById('leaderSummary');
      if (leaderSummary) leaderSummary.textContent = leaderLabel;
      var leaderSummaryPlay = document.getElementById('leaderSummaryPlay');
      if (leaderSummaryPlay) leaderSummaryPlay.textContent = leaderLabel;

      var deckStack = document.getElementById('deckStack');
      var discardStack = document.getElementById('discardStack');
      if (deckStack) deckStack.classList.toggle('empty', state.deck.length === 0);
      if (discardStack) discardStack.classList.toggle('empty', state.discard.length === 0);

      var countdown = document.getElementById('countdown');
      if (countdown) countdown.textContent = state.countdownActive ? 'an' : 'aus';
      var countdownHint = document.getElementById('countdownHint');
      if (countdownHint) countdownHint.textContent = state.countdownActive ? 'aktiv' : 'inaktiv';
      var playCountdownHint = document.getElementById('playCountdownHint');
      if (playCountdownHint) playCountdownHint.textContent = state.countdownActive ? 'aktiv' : 'inaktiv';
      var playCountdownBadge = document.getElementById('playCountdownBadge');
      if (playCountdownBadge) playCountdownBadge.classList.toggle('active', state.countdownActive);
      var timerOpt = document.getElementById('optDecisionTimer');
      if (timerOpt){
        state.decisionTimer.enabled = !!timerOpt.checked;
        state.decisionTimer.seconds = 20;
      }
      var stageRule = document.getElementById('stageRule');
      if (stageRule) stageRule.textContent = stageRuleLabel();
      var poolHint = document.getElementById('poolHint');
      if (poolHint){
        var gate = maxPoolToCampThisCamp();
        var poolTake = poolTakeFor(state.pool, gate);
        poolHint.textContent = 'Camp-Bonus (max): +' + poolTake + ' (Live ‚â•' + minLiveForPool() + ', Overload-Gate ' + gate + ')';
      }

      var pill = document.getElementById('stateChip');
      if (pill){
        var label = 'Normal';
        var cls = 'stageChip';
        if (state.overload >= 10) { label = 'Gef√§hrlich'; cls += ' bad'; }
        else if (state.overload <= 4) { label = 'Sicher'; cls += ' good'; }
        pill.className = cls;
        pill.innerHTML = '<b>Status</b>: ' + label;
      }

      var countdownChip = document.getElementById('countdownChip');
      if (countdownChip){
        countdownChip.className = 'stageChip warn';
        countdownChip.innerHTML = '<b>Countdown</b>: ' + (state.countdownActive ? 'an' : 'aus');
      }

      var countdownStatus = document.getElementById('countdownStatus');
      if (countdownStatus){
        countdownStatus.classList.toggle('active', state.countdownActive);
      }

      var stageRuleChip = document.getElementById('stageRuleChip');
      if (stageRuleChip){
        if (state.stageRule){
          stageRuleChip.textContent = 'üåÄ ' + stageRuleLabel();
          stageRuleChip.classList.add('active');
        } else {
          stageRuleChip.textContent = 'üåÄ B√ºhnenregel';
          stageRuleChip.classList.remove('active');
        }
      }

      var encoreChip = document.getElementById('encoreChip');
      if (encoreChip){
        if (state.forceFinalCampWindow){
          encoreChip.textContent = 'üé§ Finale Camp-Phase';
          encoreChip.classList.add('active');
        } else {
          encoreChip.textContent = 'üé§ Endkarte';
          encoreChip.classList.remove('active');
        }
      }

      var twistPyroChip = document.getElementById('twistPyroChip');
      if (twistPyroChip){
        twistPyroChip.classList.toggle('active', isTwistActive('pyro'));
      }
      var twistRichtChip = document.getElementById('twistRichtungswechselChip');
      if (twistRichtChip){
        twistRichtChip.classList.toggle('active', isTwistActive('richtungswechsel'));
      }
      var twistAfterpartyChip = document.getElementById('twistAfterpartyChip');
      if (twistAfterpartyChip){
        twistAfterpartyChip.classList.toggle('active', isTwistActive('afterparty'));
      }

      document.getElementById('revealerName').textContent = state.players[state.revealer] ? state.players[state.revealer].name : '‚Äî';
      document.getElementById('dir').textContent = (state.direction === 1) ? '‚Üª' : '‚Ü∫';
      var playRevealerName = document.getElementById('playRevealerName');
      if (playRevealerName){
        playRevealerName.textContent = state.players[state.revealer] ? state.players[state.revealer].name : '‚Äî';
      }
      var playDirection = document.getElementById('playDirection');
      if (playDirection){
        playDirection.textContent = (state.direction === 1) ? '‚Üª' : '‚Ü∫';
      }
      var statusHeadline = document.getElementById('statusHeadline');
      if (statusHeadline) statusHeadline.textContent = statusHeadlineText();
      updateRevealCard();
      renderOverloadTrack();
      renderPlayChips(state.lastEvent);

      var botLabel = document.getElementById('botCountLabel');
      if (botLabel){
        botLabel.textContent = 'Bots: ' + state.botCount;
      }
      var addBtn = document.getElementById('btnAddBot');
      var removeBtn = document.getElementById('btnRemoveBot');
      var adjustBots = canAdjustBots();
      if (addBtn) addBtn.disabled = !adjustBots || state.botCount >= MAX_BOTS;
      if (removeBtn) removeBtn.disabled = !adjustBots || state.botCount <= MIN_BOTS;

      // Stat flashes (optisch "was ist passiert")
      if (prev){
        if (prev.round !== state.round){
          flashStat('roundBadge','good','Runde ' + state.round);
        }
        if (prev.overload !== state.overload){
          var dO = state.overload - prev.overload;
          var kindO = (dO > 0) ? (state.overload >= 10 ? 'bad' : 'warn') : 'good';
          flashStat('overloadChip', kindO, (dO>0?'+':'') + dO);
          var playTrack = document.getElementById('playOverloadTrack');
          if (playTrack){
            playTrack.classList.remove('pulse','pulseStrong','shake');
            void playTrack.offsetWidth;
            if (state.overload >= 12){
              playTrack.classList.add('shake');
              showPlayBanner('warn', '12 erreicht!', 1200);
            } else if (state.overload >= 8 && prev.overload < 8){
              playTrack.classList.add('pulseStrong');
            } else {
              playTrack.classList.add('pulse');
            }
          }
        }
        if (prev.pool !== state.pool){
          var dP = state.pool - prev.pool;
          flashStat('poolChip', (dP>0?'blue':'warn'), (dP>0?'+':'') + dP);
        }
        if (prev.deck !== state.deck.length){
          var dD = state.deck.length - prev.deck;
          flashStat('deckChip', (dD<0?'warn':'blue'), (dD>0?'+':'') + dD);
        }
        if (prev.discard !== state.discard.length){
          var dDi = state.discard.length - prev.discard;
          flashStat('discardChip', (dDi>0?'blue':'warn'), (dDi>0?'+':'') + dDi);
        }
        if (prev.countdownActive !== state.countdownActive){
          flashStat('countdownChip', state.countdownActive ? 'warn' : 'good', state.countdownActive ? 'an' : 'aus');
        }
      }

      // phase + steps + summary
      updatePhasePill();
      renderSteps();
      renderSummary();

      // context banner
      clearBanner();
      if (state.gameOver){
        showBanner('good','Spielende','Neustart starten, um erneut zu spielen.');
      } else if (state.askOpen){
        showBanner('warn','Auswahl offen','Triff eine Auswahl, um fortzufahren.');
      } else if (state.awaitingDecision){
        var hp = state.players[state.humanIndex];
        if (hp && hp.roundState === 'active'){
          var extra = (isAggCountdown() && state.countdownActive && state.pool >= 3) ? ' (Achtung: Countdown ist aggressiv, Pool ‚â•3)' : '';
          if (state.forceFinalCampWindow){
            showBanner('warn','Finale Camp-Entscheidung','Runde endet danach. Pool-Bonus: Gate ' + maxPoolToCampThisCamp() + ', Live ‚â•' + minLiveForPool() + '.' + extra);
          } else {
            showBanner('warn','Entscheidung: Bleib oder Camp','Camp ist nur mit mindestens 1 Live m√∂glich. Pool-Bonus: Gate ' + maxPoolToCampThisCamp() + ', Live ‚â•' + minLiveForPool() + '.' + extra);
          }
        } else {
          showBanner('good','Du bist gecampt','Du beobachtest diese Runde.');
        }
      } else if (state.overload >= 10){
        showBanner('bad','Gefahr hoch','Bei Overload 12 kommt sofort der Katastrophen-Check.');
      } else if (state.overload >= 8){
        showBanner('warn','Overload 8+','Hohe Spannung: Knall-Gefahr steigt.');
      }

      renderPlayers();
      renderPlayPlayers();
      updateDecisionOverlay();
      updateDecisionTimer();
      if (!state.awaitingDecision || !state.decisionTimer.enabled) stopDecisionTimer();

      // store snapshot
      state._uiPrev = {
        round: state.round,
        overload: state.overload,
        pool: state.pool,
        deck: state.deck.length,
        discard: state.discard.length,
        countdownActive: state.countdownActive
      };

      var human = state.players[state.humanIndex];
      var isHumanActive = human.roundState === 'active';
      var forcedFinalPush = (state.finalPushForceNext && state.finalPushActor === state.humanIndex);
      var forcedStay = !!human.forcedStay;
      var forced = forcedStay || forcedFinalPush;
      var campBlockedByZero = (human.live <= 0);

      var auto = isAutoAll();
      document.getElementById('btnStay').disabled = !state.awaitingDecision || !isHumanActive || state.gameOver || auto || forcedFinalPush;
      document.getElementById('btnCamp').disabled = !state.awaitingDecision || !isHumanActive || state.gameOver || forcedStay || campBlockedByZero || auto;
      document.getElementById('btnResolve').disabled = !state.awaitingDecision || state.gameOver || auto;

      // reveal
      var canReveal = !state.gameOver && !state.awaitingDecision &&
        ((state.revealer === state.humanIndex && isHumanActive) ||
        (areBotsManual() && state.players[state.revealer] && state.players[state.revealer].roundState === 'active'));
      document.getElementById('btnReveal').disabled = !canReveal || auto;
      var playReveal = document.getElementById('btnRevealPlay');
      if (playReveal){
        playReveal.disabled = !canReveal || auto;
        playReveal.textContent = canReveal ? 'Event aufdecken' : 'Warten‚Ä¶';
      }

      // hint
      var h = document.getElementById('decisionHint');
      if (!state.awaitingDecision) {
        h.textContent = '‚Äî';
      } else if (!isHumanActive) {
        h.textContent = 'Du bist in dieser Runde gecampt.';
      } else if (forcedFinalPush) {
        h.innerHTML = 'Final Push: <b>Letzte Chance</b> ‚Äì du musst jetzt campen.';
      } else if (state.forceFinalCampWindow) {
        h.innerHTML = 'Finale Camp-Entscheidung: <b>Runde endet danach</b>.';
      } else if (forced) {
        h.innerHTML = 'Du bist durch <b>Stage Dive</b> gezwungen, diese Phase <b>drin zu bleiben</b>.';
      } else if (campBlockedByZero) {
        h.innerHTML = 'Du hast <b>0 Live</b> ‚Üí du darfst nicht campen.';
      } else {
        if (auto) h.textContent = 'Autoplay ist aktiv ‚Äì Entscheidungen werden automatisch aufgel√∂st.';
        else if (areBotsManual()) h.textContent = 'W√§hle Bleib oder Camp. Danach entscheide auch die Bots.';
        else h.textContent = 'W√§hle Bleib oder Camp (Camp nur mit Live, Pool-Bonus ab Live ‚â•' + minLiveForPool() + ', Gate ' + maxPoolToCampThisCamp() + '). Dann wird simultan aufgel√∂st.';
      }

      // highlight choice
      var stay = document.getElementById('btnStay');
      var camp = document.getElementById('btnCamp');
      stay.classList.toggle('selected', state.humanChoice === 'stay');
      camp.classList.toggle('selected', state.humanChoice === 'camp');
    }

    function applyBotProfileToBots(botId){
      state.botProfileId = botId;
      for (var i=0;i<state.players.length;i++){
        if (i === state.humanIndex) continue;
        state.players[i].botId = botId;
      }
    }

    function addBot(){
      if (!canAdjustBots()){
        toast('Bots gesperrt', 'Bots lassen sich nur vor dem ersten Event anpassen.');
        return;
      }
      if (state.botCount >= MAX_BOTS){
        toast('Limit erreicht', 'Maximal ' + MAX_BOTS + ' Bots m√∂glich.');
        return;
      }
      state.botCount = clampBotCount(state.botCount + 1);
      state.players = buildPlayers(state.botCount);
      state.botChoices = {};
      applyBotProfileToBots(state.botProfileId);
      updateUI();
    }

    function removeBot(){
      if (!canAdjustBots()){
        toast('Bots gesperrt', 'Bots lassen sich nur vor dem ersten Event anpassen.');
        return;
      }
      if (state.botCount <= MIN_BOTS){
        toast('Minimum erreicht', 'Mindestens ' + MIN_BOTS + ' Bot bleibt im Spiel.');
        return;
      }
      state.botCount = clampBotCount(state.botCount - 1);
      state.players = buildPlayers(state.botCount);
      state.botChoices = {};
      applyBotProfileToBots(state.botProfileId);
      updateUI();
    }

    function renderOverloadTrack(){
      var wraps = [document.getElementById('overloadPills'), document.getElementById('overloadPillsPlay')];
      for (var w=0;w<wraps.length;w++){
        var wrap = wraps[w];
        if (!wrap) continue;
        if (!wrap.dataset.ready){
          wrap.innerHTML = '';
          for (var i=0;i<=MAX_OVERLOAD;i++){
            var pill = document.createElement('span');
            pill.className = 'overloadPill';
            pill.textContent = String(i);
            pill.dataset.val = String(i);
            wrap.appendChild(pill);
          }
          wrap.dataset.ready = 'true';
        }

        var pills = wrap.querySelectorAll('.overloadPill');
        for (var j=0;j<pills.length;j++){
          var v = Number(pills[j].dataset.val || j);
          pills[j].classList.toggle('active', v === state.overload);
          pills[j].classList.toggle('mark', v === 8);
          pills[j].classList.toggle('danger', v === 12);
        }
      }
    }

    function updateDecisionOverlay(){
      var overlay = document.getElementById('decisionOverlay');
      if (!overlay) return;
      overlay.classList.toggle('show', state.awaitingDecision);
      overlay.setAttribute('aria-hidden', state.awaitingDecision ? 'false' : 'true');

      var human = state.players[state.humanIndex] || { live:0, camp:0, roundState:'camped', forcedStay:false };
      document.getElementById('decisionOverload').textContent = String(state.overload) + '/12';
      document.getElementById('decisionPool').textContent = String(state.pool);
      document.getElementById('decisionLive').textContent = String(human.live);

      var campHint = document.getElementById('campHint');
      if (human.live <= 0) campHint.textContent = 'Camp erst ab 1 Live';
      else if (human.forcedStay) campHint.textContent = 'Zwang: Bleib';
      else if (human.live < minLiveForPool()) campHint.textContent = 'Camp ohne Pool-Bonus (Live <' + minLiveForPool() + ')';
      else if (maxPoolToCampThisCamp() <= 0) campHint.textContent = 'Pool-Bonus gesperrt (Gate 0)';
      else campHint.textContent = 'Pool-Bonus m√∂glich (Gate ' + maxPoolToCampThisCamp() + ')';

      var preview = document.getElementById('decisionPreview');
      var gainLine = document.getElementById('decisionGain');
      var totalLine = document.getElementById('decisionTotal');
      if (!state.awaitingDecision){
        preview.style.opacity = '0.6';
        gainLine.textContent = '‚Äî';
        totalLine.textContent = '‚Äî';
      } else {
        preview.style.opacity = '1';
        var poolBonus = (human.live >= minLiveForPool()) ? poolTakeFor(state.pool, maxPoolToCampThisCamp()) : 0;
        if (human.roundState !== 'active'){
          gainLine.textContent = 'Du beobachtest diese Runde.';
          totalLine.textContent = 'Camp bleibt bei ' + human.camp + '.';
        } else if (human.live <= 0){
          gainLine.textContent = 'Camp nicht m√∂glich (0 Live).';
          totalLine.textContent = 'Camp bleibt bei ' + human.camp + '.';
        } else if (human.forcedStay){
          gainLine.textContent = 'Zwang: Bleib (Stage Dive).';
          totalLine.textContent = 'Camp bleibt bei ' + human.camp + '.';
        } else {
          gainLine.textContent = 'Du sicherst: +' + human.live + ' Camp';
          totalLine.textContent = 'Pool-Bonus (max, Gate): +' + poolBonus + ' ¬∑ Gesamt danach: ' + (human.camp + human.live + poolBonus);
        }
      }

      var playersWrap = document.getElementById('decisionPlayers');
      if (playersWrap){
        playersWrap.innerHTML = '';
        for (var i=0;i<state.players.length;i++){
          var p = state.players[i];
          var done = (p.roundState !== 'active') || (i === state.humanIndex && state.humanLockedIn);
          if (areBotsManual() && i !== state.humanIndex){
            done = done || !!state.botChoices[String(i)];
          }
          var chip = document.createElement('div');
          chip.className = 'decisionPlayer' + (done ? ' done' : '');
          chip.textContent = p.name.substring(0,2).toUpperCase();
          playersWrap.appendChild(chip);
        }
      }

      renderBotDecisionControls();
    }

    function renderBotDecisionControls(){
      var wrap = document.getElementById('decisionBots');
      if (!wrap) return;

      var show = state.awaitingDecision && areBotsManual();
      wrap.classList.toggle('hidden', !show);
      if (!show){
        wrap.innerHTML = '';
        return;
      }

      wrap.innerHTML = '';
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (i === state.humanIndex) continue;
        if (p.roundState !== 'active') continue;

        var row = document.createElement('div');
        row.className = 'decisionBotRow';

        var head = document.createElement('div');
        head.className = 'decisionBotHead';
        head.innerHTML = '<span>' + esc(p.name) + '</span><span class="mini">Live ' + p.live + ' ¬∑ Camp ' + p.camp + '</span>';

        var choices = document.createElement('div');
        choices.className = 'decisionBotChoices';

        var stay = document.createElement('button');
        stay.className = 'decisionBotBtn good';
        stay.textContent = 'Bleib';
        stay.onclick = (function(idx){
          return function(){
            state.botChoices[String(idx)] = 'stay';
            updateUI();
          };
        })(i);

        var camp = document.createElement('button');
        camp.className = 'decisionBotBtn warn';
        camp.textContent = 'Camp';
        camp.disabled = p.live <= 0 || p.forcedStay;
        camp.onclick = (function(idx){
          return function(){
            state.botChoices[String(idx)] = 'camp';
            updateUI();
          };
        })(i);

        var current = state.botChoices[String(i)] || 'stay';
        stay.classList.toggle('selected', current === 'stay');
        camp.classList.toggle('selected', current === 'camp');

        choices.appendChild(stay);
        choices.appendChild(camp);

        row.appendChild(head);
        row.appendChild(choices);
        wrap.appendChild(row);
      }
    }

    function renderPlayers(){
      var el = document.getElementById('players');
      el.innerHTML = '';

      var prev = state._uiPrevPlayers || null;
      var nextPrev = {};

      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];

        var statusLabel = (p.roundState === 'camped') ? 'GECAMPT' : 'AKTIV';
        var statusClass = (p.roundState === 'camped') ? 'badgeCamp' : 'badgeActive';

        var marks = [];
        if (!state.awaitingDecision && i === state.revealer && p.roundState === 'active') marks.push('<span class="playerMark">‚¨ÖÔ∏è Aufdecker</span>');
        if (p.forcedStay && p.roundState === 'active') marks.push('<span class="playerMark warn">MUSS BLEIBEN</span>');
        if (state.awaitingDecision && i === state.humanIndex && state.humanLockedIn) marks.push('<span class="playerMark">‚úÖ gew√§hlt</span>');

        var cls = 'playerCard';
        if (p.roundState === 'camped') cls += ' campedDim';
        if (!state.awaitingDecision && i === state.revealer && p.roundState === 'active') cls += ' turnGlow';
        if (state.awaitingDecision && p.roundState === 'active') cls += ' decideGlow';

        // delta detection
        var dLive = 0, dCamp = 0;
        if (prev && prev[String(i)]){
          dLive = p.live - prev[String(i)].live;
          dCamp = p.camp - prev[String(i)].camp;
        }

        var deltaHtml = '';
        if ((dLive !== 0 || dCamp !== 0) && prev){
          var chunks = [];
          if (dCamp !== 0) chunks.push('<span class="dTag good">üèïÔ∏è Camp ' + (dCamp>0?'+':'') + dCamp + '</span>');
          if (dLive !== 0) chunks.push('<span class="dTag blue">üéüÔ∏è Live ' + (dLive>0?'+':'') + dLive + '</span>');
          deltaHtml = '<div class="deltaLine">' + chunks.join('') + '</div>';
        }

        nextPrev[String(i)] = { live:p.live, camp:p.camp, roundState:p.roundState };

        var div = document.createElement('div');
        div.className = cls;
        div.id = 'p' + i;

        div.innerHTML =
          '<div class="playerHeader">' +
            '<div class="playerName"><span class="playerAvatar">' + esc(p.name.substring(0,1)) + '</span>' + esc(p.name) + ' <span class="tag">' + (p.name === 'Du' ? 'Du' : 'Bot') + '</span></div>' +
            '<span class="playerBadge ' + statusClass + '">' + statusLabel + '</span>' +
          '</div>' +
          '<div class="playerStats">' +
            '<div class="playerStat"><span>üéüÔ∏è</span><b>Live</b> ' + p.live + '</div>' +
            '<div class="playerStat"><span>‚õ∫</span><b>Camp</b> ' + p.camp + '</div>' +
          '</div>' +
          (marks.length ? '<div class="playerActions">' + marks.join('') + '</div>' : '') +
          deltaHtml;

        el.appendChild(div);
      }

      state._uiPrevPlayers = nextPrev;
    }

    function renderPlayPlayers(){
      var el = document.getElementById('playersPlay');
      if (!el) return;
      el.innerHTML = '';

      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        var statusText = 'AKTIV';
        var statusCls = 'active';
        if (state.gameOver && p.camp < WIN_CAMP){
          statusText = 'RAUS';
          statusCls = 'out';
        } else if (p.roundState === 'camped'){
          statusText = 'GECAMPT';
          statusCls = 'camped';
        }

        var row = document.createElement('div');
        row.className = 'playPlayer';

        var main = document.createElement('div');
        main.className = 'playPlayerMain';
        main.innerHTML = '<span class="playerAvatar">' + esc(p.name.substring(0,1)) + '</span><span>' + esc(p.name) + '</span>';

        var right = document.createElement('div');
        right.className = 'playPlayerRight';

        var status = document.createElement('span');
        status.className = 'playStatus ' + statusCls;
        status.textContent = statusText;

        var stats = document.createElement('div');
        stats.className = 'playStats';
        stats.innerHTML = '<span>üéüÔ∏è ' + p.live + '</span><span>‚õ∫ ' + p.camp + '</span>';

        right.appendChild(status);
        right.appendChild(stats);

        if (i === state.revealer && p.roundState === 'active'){
          var rev = document.createElement('span');
          rev.className = 'playRevealer';
          rev.textContent = '‚¨ÖÔ∏è Aufdecker';
          right.appendChild(rev);
        }

        row.appendChild(main);
        row.appendChild(right);

        el.appendChild(row);
      }
    }

    // ---------- deck -----------------
    function mkDeck(){
      var deck = [];
      var i;

      // Push (26)
      for (i=0;i<10;i++) deck.push({ type:'push', name:'Soundcheck', delta:1, text:'Overload +1. Aufdecker +1 Live. +1 in Pool.' });
      for (i=0;i<10;i++) deck.push({ type:'push', name:'Crowd Surf', delta:2, text:'Overload +2. Aufdecker +1 Live. +1 in Pool.' });
      for (i=0;i<6;i++) deck.push({ type:'push', name:'Bassdrop', delta:3, text:'Overload +3. Aufdecker +1 Live. +1 in Pool.' });

      // Stabilisieren (14) ‚Äì nur Safety: Pool +0, Bonus-Live nur bei Overload 9+
      for (i=0;i<STABILIZE_CARDS.length;i++){
        var sc = STABILIZE_CARDS[i];
        for (var j=0;j<sc.count;j++){
          deck.push({
            type:'stabilize',
            name: sc.name,
            delta: -sc.value,
            text:'Overload ‚àí' + sc.value + '. Pool +0. Bonus: +1 Live nur wenn Overload vorher ‚â•9.'
          });
        }
      }

      // Twist (14)
      for (i=0;i<2;i++) deck.push({ type:'twist', name:'Richtungswechsel', fx:'flipDir', text:'Rundeneffekt: Pool‚ÜíCamp erst ab Live 3.' });
      for (i=0;i<4;i++) deck.push({ type:'twist', name:'Feedback', fx:'feedback', stage:true, text:'B√ºhnenregel üåÄ‚àû: Bis Rundenende gibt jede ‚ö° zus√§tzlich +1 Overload pro Feedback-Level.' });
      for (i=0;i<3;i++) deck.push({ type:'twist', name:'Pyro', fx:'pyro', text:'Rundeneffekt: Jede ‚ö° gibt zus√§tzlich +1 Overload.' });
      for (i=0;i<3;i++) deck.push({ type:'twist', name:'Stage Dive', fx:'stageDive', text:'W√§hle einen aktiven Spieler: Er zahlt 1 Live oder bleibt beim n√§chsten Camp-Entscheid automatisch drin. Ist er bereits betroffen: Overload +1 (cap 12).' });
      for (i=0;i<2;i++) deck.push({ type:'twist', name:'Setwechsel', fx:'afterparty', text:'Rundeneffekt: Countdown sofort aktiv, Tick +2.' });

      // Encore (6)
      for (i=0;i<6;i++) deck.push({ type:'encore', name:'Encore!', fx:'encore', text:'Endkarte: Alle Aktiven +1 Live. Danach finale Camp-Entscheidung, dann Rundenende.' });

      return shuffle(deck);
    }

    // ---------- rules ----------
    function checkWin(){
      for (var i=0;i<state.players.length;i++){
        if (state.players[i].camp >= WIN_CAMP){
          if (!state.gameOver){
            state.gameOver = true;
            logStep('good', {
              action: 'ROUND_END',
              actor: 'System',
              reason: 'Win',
              fields: { Winner: esc(state.players[i].name), Camp: state.players[i].camp },
              msgHtml: 'WIN',
              before: actorSnapshot(i),
              after: actorSnapshot(i),
              reasons: { extra: 'Win' }
            });
            screenFlash('good');
            toast('Spiel beendet', state.players[i].name + ' gewinnt mit ' + state.players[i].camp + ' Camp.');
          }
          return true;
        }
      }
      return false;
    }

    function endRound(reason){
      if (state.gameOver) return;
      if (!state.players.length){
        logStep('bad', {
          action: 'ROUND_END',
          actor: 'System',
          reason: 'NoPlayers',
          fields: { RoundEndReason: 'NoPlayers' },
          msgHtml: 'ROUND_END_ABORT',
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'NoPlayers' }
        });
        restart();
        return;
      }
      stopDecisionTimer();
      state.roundResetId += 1;

      // stage rule to discard
      if (state.stageRule && state.stageRule._cardRef){
        state.discard.push(state.stageRule._cardRef);
      }

      logStep('warn', {
        action: 'ROUND_END',
        actor: 'System',
        reason: (reason || 'RoundEnd'),
        fields: {
          RoundEndReason: esc(reason || 'Rundenende'),
          PoolExpired: (state.pool > 0 ? 'yes' : 'no'),
          OverloadReset: 0
        },
        msgHtml: 'ROUND_END',
        before: { overload: state.overload, pool: state.pool, live: null, camp: null },
        after: { overload: 0, pool: 0, live: null, camp: null },
        reasons: {
          pool: (state.pool > 0 ? 'PoolExpired' : ''),
          extra: 'RoundEnd'
        }
      });
      state.pool = 0;
      state.stageRule = null;
      state.feedbackLevel = 0;
      state.feedbackLevel = 0;
      state.countdownActive = false;
      resetTwistEffects();
      state.direction = 1;
      state.extraRevealSame = false;
      state.overload = 0;
      state.encoreChain = 0;
      state.forceFinalCampWindow = false;
      state.skipCountdownOnce = false;
      state.finalPushUsed = false;
      state.finalPushGraceUsed = false;
      state.finalPushForceNext = false;
      state.finalPushActor = -1;
      state.catchUpGrantedRound = {};

      for (var i=0;i<state.players.length;i++){
        state.players[i].live = 0;
        state.players[i].roundState = 'active';
        state.players[i].forcedStay = false;
      }

      state.round += 1;
      resetLogSubStep();
      state.startPlayer = (state.startPlayer + 1) % state.players.length;
      state.revealer = state.startPlayer;
      state.awaitingDecision = false;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.botChoices = {};
      state.lastEvent = null;
      state.askOpen = false;
      resetMoodDeck();
      var askBack = document.getElementById('askBack');
      if (askBack){
        askBack.style.display = 'none';
        askBack.setAttribute('aria-hidden','true');
      }

      logStep('good', {
        action: 'ROUND_START',
        actor: 'System',
        reason: 'RoundStart',
        fields: {
          round: state.round,
          startPlayer: esc(state.players[state.startPlayer].name),
          seed: state.rngSeed,
          prevReason: reason ? esc(reason) : '‚Äî'
        },
        msgHtml: 'ROUND_START',
        before: { overload: 0, pool: 0, live: null, camp: null },
        after: { overload: 0, pool: 0, live: null, camp: null },
        reasons: { extra: 'RoundStart' }
      });
      setEventCard(null);
      updateUI();
      setPhase('reveal');
      pumpBots();
    }

    function doKnall(reason){
      // all active players lose live, camped safe
      var pfl = !!document.getElementById('optPflaster').checked;
      logStep('bad', {
        action: 'KNALL',
        actor: 'System',
        msgHtml: 'KNALL_START | reason=' + esc(reason),
        before: { overload: state.overload, pool: state.pool, live: null, camp: null },
        after: { overload: state.overload, pool: state.pool, live: null, camp: null },
        reasons: { extra: 'KnallStart' }
      });

      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (p.roundState !== 'active') continue;
        var liveBefore = p.live;
        var campBefore = p.camp;
        var liveAfterHalve = Math.floor(liveBefore / 2);
        var bandageApplied = (pfl && liveBefore >= 1);
        var liveFinal = liveAfterHalve + (bandageApplied ? 1 : 0);
        p.live = liveFinal;

        var reasonLive = 'Knall halve';
        if (bandageApplied) reasonLive += ', Pflaster +1';
        logStep('bad', {
          action: 'KNALL',
          actor: p.name,
          actorIdx: i,
          msgHtml: 'KNALL_PLAYER | live_before=' + liveBefore + ' | halve=' + liveAfterHalve + ' | bandage=' + (bandageApplied ? 'true(+1)' : 'false') + ' | live_final=' + liveFinal,
          before: { overload: state.overload, pool: state.pool, live: liveBefore, camp: campBefore },
          after: { overload: state.overload, pool: state.pool, live: p.live, camp: campBefore },
          reasons: { live: reasonLive }
        });
      }

      screenFlash('bad');
      toast('KNALL!', 'Runde endet sofort.');
      setHeadline('KNALL! Runde endet', 1600);
      showPlayBanner('bad', 'KNALL! Runde endet', 1600);

      if (checkWin()) { updateUI(); return; }
      recordDebugSnapshot('afterKnall');
      endRound('Knall');
    }

    function startCountdown(reason){
      if (state.countdownActive) return false;
      var globalBefore = getGlobalSnapshot();
      state.countdownActive = true;
      logStep('warn', {
        action: 'COUNTDOWN',
        actor: 'System',
        reason: 'CountdownStart',
        fields: { Base: '+' + countdownTickValue(), Aggressiv: (isAggCountdown() ? 'aktiv' : 'aus'), Trigger: reason },
        msgHtml: 'COUNTDOWN_ACTIVE',
        before: actorSnapshot(null),
        after: actorSnapshot(null),
        globalBefore: globalBefore,
        globalAfter: getGlobalSnapshot(),
        reasons: { extra: 'CountdownStart' }
      });
      return true;
    }

    function checkCountdownThreshold(before, after, reason){
      if (state.countdownActive) return false;
      if (before < 8 && after >= 8){
        startCountdown(reason || 'Overload>=8');
        return true;
      }
      return false;
    }

    function applyOverloadDelta(delta){
      var before = state.overload;
      var after = clampOverload(state.overload + delta);
      state.overload = after;
      var reached = (before < 12 && after === 12);
      checkCountdownThreshold(before, after, 'OverloadDelta');
      return { before: before, after: after, delta: (after - before), reached12: reached };
    }

    function catastropheCheck(){
      setHeadline('Katastrophen-Check!', 1200);
      var card = draw(1)[0] || null;
      if (!card){
        logStep('warn', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'CHECK_RESULT=Safe | reason=NoCard',
          before: { overload: 12, pool: state.pool, live: null, camp: null },
          after: { overload: OVERLOAD_RESET_AFTER_CHECK, pool: state.pool, live: null, camp: null },
          reasons: { overload: 'SafeCheck=12->10' }
        });
        state.overload = OVERLOAD_RESET_AFTER_CHECK;
        showPlayBanner('good', 'Gerade noch so!', 1200);
        updateUI();
        return;
      }

      var isPush = (card.type === 'push');
      state.discard.push(card);
      showPlayCheckCard(card);

      if (isPush){
        logStep('bad', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'CHECK_RESULT=Push => KNALL_TRIGGER | Card=' + esc(card.name),
          before: { overload: 12, pool: state.pool, live: null, camp: null },
          after: { overload: 12, pool: state.pool, live: null, camp: null },
          reasons: { extra: 'CheckPush=Knall' }
        });
        showPlayBanner('bad', 'KNALL!', 1200);
        doKnall('Katastrophen-Check hat Push aufgedeckt');
        return;
      }

      logStep('good', {
        action: 'CHECK',
        actor: 'System',
        msgHtml: 'CHECK_RESULT=Safe | Card=' + esc(card.name) + ' (' + esc(labelType(card.type).txt) + ')',
        before: { overload: 12, pool: state.pool, live: null, camp: null },
        after: { overload: OVERLOAD_RESET_AFTER_CHECK, pool: state.pool, live: null, camp: null },
        reasons: { overload: 'SafeCheck=12->10' }
      });
      state.overload = OVERLOAD_RESET_AFTER_CHECK;
      showPlayBanner('good', 'Gerade noch so!', 1200);
      updateUI();
    }

    function onOverloadMayHit12(r, why){
      if (state.gameOver) return;
      if (r.reached12){
        logStep('warn', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'CHECK_TRIGGER | reason=' + esc(why),
          before: { overload: r.before, pool: state.pool, live: null, camp: null },
          after: { overload: r.after, pool: state.pool, live: null, camp: null },
          reasons: { overload: esc(why) }
        });
        catastropheCheck();
      }
    }

    function hatErzwungeneEntscheidung(){
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (p.roundState !== 'active') continue;
        if (p.forcedStay) return true;
        if (state.finalPushForceNext && i === state.finalPushActor) return true;
      }
      return false;
    }

    function sollDecisionWindowOeffnen(){
      if (state.gameOver) return false;
      if (hatErzwungeneEntscheidung()) return true;
      for (var i=0;i<state.players.length;i++){
        if (darfJetztCampen(state.players[i])) return true;
      }
      return false;
    }

    function ensureDecisionPhase(){
      if (state.gameOver) return;
      state.awaitingDecision = true;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.botChoices = {};
      state.encoreChain = 0;
      setPhase('decision');

      if (state.forceFinalCampWindow){
        setSummary('Finale Camp-Entscheidung',
          [
            { cls:'warn', sym:'üèïÔ∏è', text:'Letzter Cashout: Camp oder Bleib' },
            { cls:'blue', sym:'üéÅ', text:'Pool-Bonus: Gate ' + maxPoolToCampThisCamp() + ', Live ‚â•' + minLiveForPool() }
          ],
          'Runde endet danach'
        );
      } else {
        setSummary('Entscheidung',
          [
            { cls:'good', sym:'‚úÖ', text:'Bleib: Live bleibt im Risiko' },
            { cls:'warn', sym:'üèïÔ∏è', text:'Camp: nur mit mindestens 1 Live' },
            { cls:'blue', sym:'üéÅ', text:'Pool-Bonus: Gate ' + maxPoolToCampThisCamp() + ', Live ‚â•' + minLiveForPool() }
          ],
          'Simultan, offen'
        );
      }

      updateUI();
      startDecisionTimer();
    }

    function skipDecisionWindow(reason){
      stopDecisionTimer();
      state.awaitingDecision = false;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.botChoices = {};
      state.encoreChain = 0;
      logStep('info', {
        action: 'DECISION',
        actor: 'System',
        reason: reason || 'NoMeaningfulChoice',
        fields: { DecisionWindow: 'SKIP', Reason: (reason || 'NoMeaningfulChoice') },
        msgHtml: 'DECISION_WINDOW_SKIP',
        before: actorSnapshot(null),
        after: actorSnapshot(null),
        reasons: { extra: 'DecisionWindowSkip' }
      });
      advanceAfterDecision();
    }

    function resolveCountdownTick(){
      if (!state.countdownActive) return;
      if (state.gameOver) return;
      setPhase('countdown');

      var add = countdownTickValue();
      if (isAggCountdown() && state.pool >= 3) add += 1;

      var r = applyOverloadDelta(+add);
      var capNote = describeOverloadCap(r.before, add, r.after);
      logStep('warn', {
        action: 'COUNTDOWN',
        actor: 'System',
        reason: 'CountdownApply',
        fields: { Add: add, Base: countdownTickValue(), Cap: capNote ? 'true' : 'false' },
        msgHtml: 'COUNTDOWN_APPLY',
        before: { overload: r.before, pool: state.pool, live: null, camp: null },
        after: { overload: r.after, pool: state.pool, live: null, camp: null },
        reasons: { overload: 'Countdown=+' + add }
      });

      setSummary('Countdown',
        [
          { cls:'warn', sym:'‚è±Ô∏è', text:'Overload +' + add + ' ‚Üí ' + r.after + (capNote ? ' (cap)' : '') },
          (isAggCountdown() ? { cls:'blue', sym:'üéÅ', text:(state.pool >= 3 ? 'Pool ‚â•3: extra +1 aktiv' : 'Pool <3: kein Extra') } : { cls:'blue', sym:'‚öôÔ∏è', text:'Aggressiv: aus' })
        ],
        'Countdown ist aktiv, solange die Runde l√§uft'
      );

      updateUI();
      onOverloadMayHit12(r, 'Countdown');
    }

    // ---------- Bot-Module (Wrapper) ----------
    function botWantsToCamp(pi){
      var p = state.players[pi];
      var bot = getBotModule(p.botId || state.botProfileId);
      var res = bot.decideCamp(botCtx(pi));
      return res === 'camp';
    }

    function botEncoreStop(pi){
      var p = state.players[pi];
      var bot = getBotModule(p.botId || state.botProfileId);
      return !!bot.stopEncore(botCtx(pi));
    }

    function botStageDivePay(pi){
      var p = state.players[pi];
      var bot = getBotModule(p.botId || state.botProfileId);
      return !!bot.stageDivePay(botCtx(pi));
    }

    function botPickStageDiveTarget(revealer){
      var p = state.players[revealer];
      var bot = getBotModule(p.botId || state.botProfileId);
      return bot.pickStageDiveTarget(botCtx(revealer));
    }

    // ---------- event effects ----------
    function feedbackLevel(){
      var lvl = Number(state.feedbackLevel || 0);
      if (!isFinite(lvl)) return 0;
      return Math.max(0, Math.min(3, Math.round(lvl)));
    }

    function hasFeedbackRule(){
      return feedbackLevel() > 0;
    }

    function stageRuleLabel(){
      if (!state.stageRule) return '‚Äî';
      if (state.stageRule.fx === 'feedback') return 'Feedback L' + feedbackLevel();
      return state.stageRule.name;
    }

    function applyPush(rev, card){
      var p = state.players[rev];
      var base = (typeof card.delta === 'number') ? card.delta : 1;
      var mod = feedbackLevel();
      var baseIncrease = base + mod;
      var moodValue = drawCrowdMoodValue();
      var afterMood = Math.max(1, baseIncrease + moodValue);
      var pyroBonus = isTwistActive('pyro') ? 1 : 0;
      var total = afterMood + pyroBonus;
      var before = state.overload;
      var liveBefore = p.live;
      var campBefore = p.camp;
      var poolBefore = state.pool;
      var unclamped = before + total;
      var after = Math.min(MAX_OVERLOAD, unclamped);
      var capNote = describeOverloadCap(before, total, after);
      state.overload = after;
      var r = { before: before, after: after, delta: (after - before), reached12: (before < MAX_OVERLOAD && after === MAX_OVERLOAD) };
      checkCountdownThreshold(before, after, 'Push');
      p.live += 1;
      state.pool += 1;

      setSummary('‚ö° Push ‚Äì ' + card.name,
        [
          { cls:'bad',  sym:'‚ö°', text:'Overload +' + total + ' ‚Üí ' + r.after + (capNote ? ' (cap)' : '') },
          { cls:'blue', sym:'üéüÔ∏è', text:p.name + ' Live +1 (jetzt ' + p.live + ')' },
          { cls:'warn', sym:'üéÅ', text:'Pool +1 (jetzt ' + state.pool + ')' }
        ],
        'Danach: Entscheidung Bleib/Camp'
      );
      if (moodValue !== 0){
        state.lastSummary.chips.push({ cls:'blue', sym:'üé≠', text:'Crowd-Mood ' + (moodValue >= 0 ? '+' : '') + moodValue });
      }
      if (pyroBonus){
        state.lastSummary.chips.push({ cls:'bad', sym:'üî•', text:'Pyro +1 Overload' });
      }
      renderSummary();

      logStep('info', {
        action: 'EFFECT',
        actor: p.name,
        actorIdx: rev,
        effectId: EFFECT_IDS.PUSH,
        reason: 'CrowdMood',
        fields: {
          CrowdMood: (moodValue >= 0 ? '+' : '') + moodValue,
          PushBase: baseIncrease,
          PushAfterMood: afterMood,
          PyroBonus: pyroBonus
        },
        msgHtml: 'Crowd-Mood: ' + (moodValue >= 0 ? '+' : '') + moodValue + ' (Push +' + baseIncrease + ' ‚Üí +' + afterMood + ' Overload)',
        before: { overload: before, pool: poolBefore, live: liveBefore, camp: campBefore },
        after: { overload: before, pool: poolBefore, live: liveBefore, camp: campBefore }
      });

      logStep('info', {
        action: 'EFFECT',
        actor: p.name,
        actorIdx: rev,
        effectId: EFFECT_IDS.PUSH,
        msgHtml: 'Card=' + esc(card.name) + ' | Effekt=Push (+' + base + ' Karte +' + mod + ' Feedback + Crowd ' + (moodValue >= 0 ? '+' : '') + moodValue + (pyroBonus ? ' + Pyro +1' : '') + ')' + capNote,
        before: { overload: before, pool: poolBefore, live: liveBefore, camp: campBefore },
        after: { overload: after, pool: state.pool, live: p.live, camp: p.camp },
        reasons: {
          overload: 'CardBase=+' + base + ', FeedbackBonus=+' + mod + ', CrowdMood=' + (moodValue >= 0 ? '+' : '') + moodValue + ', PyroBonus=' + pyroBonus,
          pool: '+1 from Push',
          live: '+1 Push'
        }
      });
      clampStateAfterCard();
      updateUI();
      onOverloadMayHit12(r, 'Push');
    }

    function applyStabilize(rev, card){
      var p = state.players[rev];
      var beforeOver = state.overload;
      var liveBefore = p.live;
      var campBefore = p.camp;
      var poolBefore = state.pool;
      var valueAbs = Math.abs((typeof card.delta === 'number') ? card.delta : -2);
      var unclamped = beforeOver - valueAbs;
      var afterOver = Math.max(0, unclamped);
      var floorNote = describeOverloadFloor(beforeOver, valueAbs, afterOver);
      state.overload = afterOver;
      var bonusLive = (beforeOver >= 9) ? 1 : 0;
      if (bonusLive > 0) p.live += bonusLive;

      logStep('good', {
        action: 'EFFECT',
        actor: p.name,
        actorIdx: rev,
        effectId: EFFECT_IDS.STABILIZE,
        msgHtml: 'Stabilisiert: Overload ' + beforeOver + ' ‚Üí ' + afterOver + (floorNote ? ' ' + floorNote : '') + '; Pool +0; Live +' + bonusLive + (bonusLive ? ' (nur weil Overload vorher hoch war)' : ''),
        before: { overload: beforeOver, pool: poolBefore, live: liveBefore, camp: campBefore },
        after: { overload: afterOver, pool: state.pool, live: p.live, camp: p.camp },
        reasons: {
          overload: 'Stabilize=-' + valueAbs,
          live: (bonusLive ? '+1 from Stabilize(9+)' : '')
        }
      });

      var summaryChips = [
        { cls:'good', sym:'üõ†Ô∏è', text:'Overload ‚àí' + valueAbs + ' ‚Üí ' + afterOver }
      ];
      if (bonusLive){
        summaryChips.push({ cls:'blue', sym:'üéüÔ∏è', text:p.name + ' Live +1 (jetzt ' + p.live + ')' });
      } else {
        summaryChips.push({ cls:'blue', sym:'‚Äî', text:'Kein Bonus (nur bei Overload 9+)' });
      }

      setSummary('üõ†Ô∏è Stabilisieren ‚Äì ' + card.name, summaryChips, 'Danach: Entscheidung Bleib/Camp');

      clampStateAfterCard();
      updateUI();
    }

    function applyTwist(rev, card, doneCb){
      var p = state.players[rev];

      if (card.stage){
        if (card.fx === 'feedback'){
          var oldLevel = feedbackLevel();
          var newLevel = Math.min(3, oldLevel + 1);
          var replaceNote = '';

          if (state.stageRule && state.stageRule.fx === 'feedback'){
            state.feedbackLevel = newLevel;
            state.discard.push(card);
          } else {
            if (state.stageRule && state.stageRule._cardRef){
              state.discard.push(state.stageRule._cardRef);
              replaceNote = ' (ersetzt ' + esc(state.stageRule.name) + ')';
            }
            state.stageRule = { name: 'Feedback', text: card.text, fx: card.fx, _cardRef: card };
            state.feedbackLevel = newLevel;
          }
          logStep('warn', {
            action: 'EFFECT',
            actor: p.name,
            actorIdx: rev,
            effectId: EFFECT_IDS.FEEDBACK_LEVEL_UP,
            msgHtml: 'STAGE_RULE | Feedback Level ' + oldLevel + '->' + newLevel + ' (Push +' + newLevel + ')' + replaceNote,
            before: actorSnapshot(rev),
            after: actorSnapshot(rev),
            reasons: { extra: 'FeedbackLevel=' + oldLevel + '->' + newLevel }
          });
          updateUI();
          doneCb();
          return;
        }

        if (state.stageRule && state.stageRule._cardRef){
          state.discard.push(state.stageRule._cardRef);
          logStep('warn', {
            action: 'EFFECT',
            actor: p.name,
            actorIdx: rev,
            effectId: EFFECT_IDS.STAGE_RULE_REPLACE,
            msgHtml: 'STAGE_RULE_REPLACE | from=' + esc(state.stageRule.name) + ' | to=' + esc(card.name),
            before: actorSnapshot(rev),
            after: actorSnapshot(rev),
            reasons: { extra: 'StageRuleReplace' }
          });
        } else {
          logStep('warn', {
            action: 'EFFECT',
            actor: p.name,
            actorIdx: rev,
            effectId: EFFECT_IDS.STAGE_RULE_ADD,
            msgHtml: 'STAGE_RULE_ADD | rule=' + esc(card.name),
            before: actorSnapshot(rev),
            after: actorSnapshot(rev),
            reasons: { extra: 'StageRuleAdd' }
          });
        }
        state.stageRule = { name: card.name, text: card.text, fx: card.fx, _cardRef: card };
        state.feedbackLevel = 0;
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'flipDir'){
        state.twistEffects.richtungswechsel = true;
        var minLive = minLiveForPool();
        logStep('warn', {
          action: 'EFFECT',
          actor: p.name,
          actorIdx: rev,
          effectId: EFFECT_IDS.TWIST_RICHTUNGSWECHSEL,
          msgHtml: 'TWIST aktiv: RICHTUNGSWECHSEL (Pool‚ÜíCamp erst ab Live ' + minLive + ')',
          before: actorSnapshot(rev),
          after: actorSnapshot(rev),
          reasons: { extra: 'Richtungswechsel' }
        });
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'pyro'){
        state.twistEffects.pyro = true;
        logStep('warn', {
          action: 'EFFECT',
          actor: p.name,
          actorIdx: rev,
          effectId: EFFECT_IDS.TWIST_PYRO,
          msgHtml: 'TWIST aktiv: PYRO (+1 Overload auf alle Pushes)',
          before: actorSnapshot(rev),
          after: actorSnapshot(rev),
          reasons: { extra: 'PyroActive' }
        });
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'afterparty'){
        var globalBefore = getGlobalSnapshot();
        state.twistEffects.afterparty = true;
        startCountdown('Afterparty');
        logStep('warn', {
          action: 'EFFECT',
          actor: p.name,
          actorIdx: rev,
          effectId: EFFECT_IDS.TWIST_AFTERPARTY,
          msgHtml: 'TWIST aktiv: AFTERPARTY (Countdown sofort, Tick +2)',
          before: actorSnapshot(rev),
          after: actorSnapshot(rev),
          globalBefore: globalBefore,
          globalAfter: getGlobalSnapshot(),
          reasons: { extra: 'Afterparty' }
        });
        updateUI();
        doneCb();
        return;
      }

      if (card.fx === 'stageDive'){
        if (rev === state.humanIndex) {
          if (isAutoAll()){
            var aiTarget = botPickStageDiveTarget(rev);
            if (aiTarget === rev){
              logStep('warn', {
                action: 'EFFECT',
                actor: p.name,
                actorIdx: rev,
                effectId: EFFECT_IDS.STAGE_DIVE,
                msgHtml: 'STAGE_DIVE | Kein anderes aktives Ziel ‚Üí Effekt verpufft',
                before: actorSnapshot(rev),
                after: actorSnapshot(rev),
                reasons: { extra: 'StageDiveNoTarget' }
              });
              doneCb();
              return;
            }
            resolveStageDiveTarget(rev, aiTarget, doneCb);
            return;
          }

          var opts = [];
          for (var i=0;i<state.players.length;i++){
            if (state.players[i].roundState !== 'active') continue;
            if (i === rev) continue;
            opts.push({ label: state.players[i].name + ' (Live ' + state.players[i].live + ')', value: i });
          }
          if (!opts.length){
            logStep('warn', {
              action: 'EFFECT',
              actor: p.name,
              actorIdx: rev,
              effectId: EFFECT_IDS.STAGE_DIVE,
              msgHtml: 'STAGE_DIVE | Kein anderes aktives Ziel ‚Üí Effekt verpufft',
              before: actorSnapshot(rev),
              after: actorSnapshot(rev),
              reasons: { extra: 'StageDiveNoTarget' }
            });
            doneCb();
            return;
          }

          askPickOne(
            'Stage Dive ‚Äì Ziel w√§hlen',
            '<b>Stage Dive</b>: W√§hle einen aktiven Spieler. Er zahlt 1 Live oder bleibt beim n√§chsten Camp-Entscheid automatisch drin.',
            opts,
            function(val){
              if (val === null || typeof val !== 'number'){
                logStep('warn', {
                  action: 'EFFECT',
                  actor: p.name,
                  actorIdx: rev,
                  effectId: EFFECT_IDS.STAGE_DIVE,
                  msgHtml: 'STAGE_DIVE | Keine Auswahl ‚Üí Effekt verpufft',
                  before: actorSnapshot(rev),
                  after: actorSnapshot(rev),
                  reasons: { extra: 'StageDiveNoSelection' }
                });
                doneCb();
                return;
              }
              resolveStageDiveTarget(rev, val, doneCb);
            }
          );
          return;
        }

        if (areBotsManual()){
          var optsBot = [];
          for (var j=0;j<state.players.length;j++){
            if (state.players[j].roundState !== 'active') continue;
            if (j === rev) continue;
            optsBot.push({ label: state.players[j].name + ' (Live ' + state.players[j].live + ')', value: j });
          }
          if (!optsBot.length){
            logStep('warn', {
              action: 'EFFECT',
              actor: p.name,
              actorIdx: rev,
              effectId: EFFECT_IDS.STAGE_DIVE,
              msgHtml: 'STAGE_DIVE | Kein anderes aktives Ziel ‚Üí Effekt verpufft',
              before: actorSnapshot(rev),
              after: actorSnapshot(rev),
              reasons: { extra: 'StageDiveNoTarget' }
            });
            doneCb();
            return;
          }
          askPickOne(
            'Stage Dive ‚Äì Ziel f√ºr ' + state.players[rev].name,
            '<b>Stage Dive</b>: Du steuerst die Bots. W√§hle das Ziel.',
            optsBot,
            function(val){
              if (val === null || typeof val !== 'number'){
                logStep('warn', {
                  action: 'EFFECT',
                  actor: p.name,
                  actorIdx: rev,
                  effectId: EFFECT_IDS.STAGE_DIVE,
                  msgHtml: 'STAGE_DIVE | Keine Auswahl ‚Üí Effekt verpufft',
                  before: actorSnapshot(rev),
                  after: actorSnapshot(rev),
                  reasons: { extra: 'StageDiveNoSelection' }
                });
                doneCb();
                return;
              }
              resolveStageDiveTarget(rev, val, doneCb);
            }
          );
          return;
        }

        var targetIdx = botPickStageDiveTarget(rev);
        resolveStageDiveTarget(rev, targetIdx, doneCb);
        return;
      }

      logStep('info', {
        action: 'EFFECT',
        actor: p.name,
        actorIdx: rev,
        effectId: EFFECT_IDS.TWIST_NO_EFFECT,
        msgHtml: 'TWIST | Kein Effekt | Card=' + esc(card.name),
        before: actorSnapshot(rev),
        after: actorSnapshot(rev),
        reasons: { extra: 'TwistNoEffect' }
      });
      doneCb();
    }

    function resolveStageDiveTarget(rev, targetIdx, doneCb){
      var revP = state.players[rev];
      var tP = state.players[targetIdx];

      // Stage Dive darf nie den Aufdecker selbst treffen.
      if (targetIdx === rev){
        logStep('warn', {
          action: 'EFFECT',
          actor: revP.name,
          actorIdx: rev,
          effectId: EFFECT_IDS.STAGE_DIVE,
          msgHtml: 'STAGE_DIVE | Kein anderes aktives Ziel ‚Üí Effekt verpufft',
          before: actorSnapshot(rev),
          after: actorSnapshot(rev),
          reasons: { extra: 'StageDiveNoTarget' }
        });
        doneCb();
        return;
      }

      if (!tP || tP.roundState !== 'active'){
        logStep('warn', {
          action: 'EFFECT',
          actor: revP.name,
          actorIdx: rev,
          effectId: EFFECT_IDS.STAGE_DIVE,
          msgHtml: 'STAGE_DIVE | Ziel nicht aktiv ‚Üí Effekt verpufft',
          before: actorSnapshot(rev),
          after: actorSnapshot(rev),
          reasons: { extra: 'StageDiveTargetInactive' }
        });
        doneCb();
        return;
      }

      logStep('warn', {
        action: 'EFFECT',
        actor: revP.name,
        actorIdx: rev,
        effectId: EFFECT_IDS.STAGE_DIVE,
        msgHtml: 'STAGE_DIVE | target=' + esc(tP.name),
        before: actorSnapshot(rev),
        after: actorSnapshot(rev),
        reasons: { extra: 'StageDiveTrigger' }
      });
      updateUI();

      if (tP.forcedStay){
        if (STAGE_DIVE_REPLACEMENT === 'overload'){
          var before = state.overload;
          var r = applyOverloadDelta(1);
          var capNote = describeOverloadCap(before, 1, r.after);
          logStep('warn', {
            action: 'EFFECT',
            actor: tP.name,
            actorIdx: targetIdx,
            effectId: EFFECT_IDS.STAGE_DIVE,
            msgHtml: 'STAGE_DIVE | Ersatz=Overload +1' + capNote,
            before: { overload: before, pool: state.pool, live: tP.live, camp: tP.camp },
            after: { overload: r.after, pool: state.pool, live: tP.live, camp: tP.camp },
            reasons: { overload: 'StageDiveReplacement=+1' }
          });
          onOverloadMayHit12(r, 'Stage Dive Ersatz');
        } else {
          var poolBefore = state.pool;
          state.pool += 1;
          logStep('warn', {
            action: 'EFFECT',
            actor: tP.name,
            actorIdx: targetIdx,
            effectId: EFFECT_IDS.STAGE_DIVE,
            msgHtml: 'STAGE_DIVE | Ersatz=Pool +1',
            before: { overload: state.overload, pool: poolBefore, live: tP.live, camp: tP.camp },
            after: { overload: state.overload, pool: state.pool, live: tP.live, camp: tP.camp },
            reasons: { pool: '+1 from StageDiveReplacement' }
          });
        }
        updateUI();
        doneCb();
        return;
      }

      if (targetIdx === state.humanIndex){
        if (isAutoAll()){
          if (tP.live > 0 && botStageDivePay(targetIdx)){
            var liveBeforeAuto = tP.live;
            tP.live = Math.max(0, tP.live - 1);
            logStep('good', {
              action: 'EFFECT',
              actor: tP.name,
              actorIdx: targetIdx,
              effectId: EFFECT_IDS.STAGE_DIVE,
              msgHtml: 'STAGE_DIVE | Zahlung=1 Live | Effekt ignoriert',
              before: { overload: state.overload, pool: state.pool, live: liveBeforeAuto, camp: tP.camp },
              after: { overload: state.overload, pool: state.pool, live: tP.live, camp: tP.camp },
              reasons: { live: '-1 pay StageDive' }
            });
            doneCb();
            return;
          }
          tP.forcedStay = true;
          logStep('bad', {
            action: 'EFFECT',
            actor: tP.name,
            actorIdx: targetIdx,
            effectId: EFFECT_IDS.STAGE_DIVE,
            msgHtml: 'STAGE_DIVE | forcedStay=true',
            before: actorSnapshot(targetIdx),
            after: actorSnapshot(targetIdx),
            reasons: { extra: 'StageDiveForcedStay' }
          });
          doneCb();
          return;
        }

        if (tP.live <= 0){
          tP.forcedStay = true;
        logStep('bad', {
          action: 'EFFECT',
          actor: tP.name,
          actorIdx: targetIdx,
          effectId: EFFECT_IDS.STAGE_DIVE,
          msgHtml: 'STAGE_DIVE | forcedStay=true | reason=Live0',
          before: actorSnapshot(targetIdx),
          after: actorSnapshot(targetIdx),
          reasons: { extra: 'StageDiveForcedStay' }
        });
          toast('Stage Dive', 'Du musst drin bleiben (kein Live zum Zahlen).');
          doneCb();
          return;
        }

        askYesNo(
          'Stage Dive ‚Äì Zahlen?',
          '<b>Stage Dive</b> trifft dich.<br><br>Willst du <b>1 Live</b> zahlen, um nicht betroffen zu sein?',
          '1 Live zahlen',
          'Nicht zahlen',
          function(use){
            if (use){
              var liveBeforeHuman = tP.live;
              tP.live = Math.max(0, tP.live - 1);
              logStep('good', {
                action: 'EFFECT',
                actor: tP.name,
                actorIdx: targetIdx,
                effectId: EFFECT_IDS.STAGE_DIVE,
                msgHtml: 'STAGE_DIVE | Zahlung=1 Live | Effekt ignoriert',
                before: { overload: state.overload, pool: state.pool, live: liveBeforeHuman, camp: tP.camp },
                after: { overload: state.overload, pool: state.pool, live: tP.live, camp: tP.camp },
                reasons: { live: '-1 pay StageDive' }
              });
              toast('Bezahlt', 'Stage Dive ignoriert.');
            } else {
              tP.forcedStay = true;
              logStep('bad', {
                action: 'EFFECT',
                actor: tP.name,
                actorIdx: targetIdx,
                effectId: EFFECT_IDS.STAGE_DIVE,
                msgHtml: 'STAGE_DIVE | forcedStay=true',
                before: actorSnapshot(targetIdx),
                after: actorSnapshot(targetIdx),
                reasons: { extra: 'StageDiveForcedStay' }
              });
              toast('Stage Dive', 'Du musst drin bleiben.');
            }
            doneCb();
          }
        );
        return;
      }

      if (areBotsManual()){
        if (tP.live <= 0){
          tP.forcedStay = true;
          logStep('bad', {
            action: 'EFFECT',
            actor: tP.name,
            actorIdx: targetIdx,
            effectId: EFFECT_IDS.STAGE_DIVE,
            msgHtml: 'STAGE_DIVE | forcedStay=true | reason=Live0',
            before: actorSnapshot(targetIdx),
            after: actorSnapshot(targetIdx),
            reasons: { extra: 'StageDiveForcedStay' }
          });
          doneCb();
          return;
        }
        askYesNo(
          'Stage Dive ‚Äì ' + tP.name + ' zahlen?',
          '<b>' + esc(tP.name) + '</b> ist Ziel. Soll 1 Live gezahlt werden?',
          '1 Live zahlen',
          'Nicht zahlen',
          function(use){
            if (use){
              var liveBeforeBot = tP.live;
              tP.live = Math.max(0, tP.live - 1);
              logStep('good', {
                action: 'EFFECT',
                actor: tP.name,
                actorIdx: targetIdx,
                effectId: EFFECT_IDS.STAGE_DIVE,
                msgHtml: 'STAGE_DIVE | Zahlung=1 Live | Effekt ignoriert',
                before: { overload: state.overload, pool: state.pool, live: liveBeforeBot, camp: tP.camp },
                after: { overload: state.overload, pool: state.pool, live: tP.live, camp: tP.camp },
                reasons: { live: '-1 pay StageDive' }
              });
            } else {
              tP.forcedStay = true;
              logStep('bad', {
                action: 'EFFECT',
                actor: tP.name,
                actorIdx: targetIdx,
                effectId: EFFECT_IDS.STAGE_DIVE,
                msgHtml: 'STAGE_DIVE | forcedStay=true',
                before: actorSnapshot(targetIdx),
                after: actorSnapshot(targetIdx),
                reasons: { extra: 'StageDiveForcedStay' }
              });
            }
            doneCb();
          }
        );
        return;
      }

      if (tP.live > 0 && botStageDivePay(targetIdx)){
        var liveBeforeAutoBot = tP.live;
        tP.live = Math.max(0, tP.live - 1);
        logStep('good', {
          action: 'EFFECT',
          actor: tP.name,
          actorIdx: targetIdx,
          effectId: EFFECT_IDS.STAGE_DIVE,
          msgHtml: 'STAGE_DIVE | Zahlung=1 Live | Effekt ignoriert',
          before: { overload: state.overload, pool: state.pool, live: liveBeforeAutoBot, camp: tP.camp },
          after: { overload: state.overload, pool: state.pool, live: tP.live, camp: tP.camp },
          reasons: { live: '-1 pay StageDive' }
        });
        doneCb();
        return;
      }

      tP.forcedStay = true;
      logStep('bad', {
        action: 'EFFECT',
        actor: tP.name,
        actorIdx: targetIdx,
        effectId: EFFECT_IDS.STAGE_DIVE,
        msgHtml: 'STAGE_DIVE | forcedStay=true',
        before: actorSnapshot(targetIdx),
        after: actorSnapshot(targetIdx),
        reasons: { extra: 'StageDiveForcedStay' }
      });
      doneCb();
    }

    function applyEncore(rev, card){
      var p = state.players[rev];

      var activeBefore = getActivePlayerNames();
      for (var i=0;i<state.players.length;i++){
        var pl = state.players[i];
        if (pl.roundState !== 'active') continue;
        var liveBefore = pl.live;
        pl.live += 1;
        logStep('info', {
          action: 'EFFECT',
          actor: pl.name,
          actorIdx: i,
          effectId: EFFECT_IDS.END_ENCORE,
          reason: 'EncoreBoost',
          fields: { EndCard: 'Encore', LiveBonus: 1 },
          msgHtml: 'ENDKARTE: ENCORE! ‚Üí +1 Live',
          before: { overload: state.overload, pool: state.pool, live: liveBefore, camp: pl.camp },
          after: { overload: state.overload, pool: state.pool, live: pl.live, camp: pl.camp },
          reasons: { live: '+1 from Encore' }
        });
      }

      state.forceFinalCampWindow = true;
      state.skipCountdownOnce = true;
      state.encoreChain = 0;

      logStep('warn', {
        action: 'EFFECT',
        actor: 'System',
        effectId: EFFECT_IDS.END_ENCORE,
        reason: 'EndCard',
        fields: { EndCard: 'Encore', ActivePlayers: esc(activeBefore.join(', ')) },
        msgHtml: 'ENDKARTE: ENCORE! ‚Üí Alle Aktiven +1 Live ‚Üí Finale Camp-Entscheidung ‚Üí Runde endet',
        before: actorSnapshot(null),
        after: actorSnapshot(null),
        reasons: { extra: 'EncoreFinalCamp' }
      });

      setSummary('üé§ Endkarte ‚Äì ' + card.name,
        [
          { cls:'blue', sym:'üéüÔ∏è', text:'Alle Aktiven +1 Live' },
          { cls:'warn', sym:'üèïÔ∏è', text:'Finale Camp-Entscheidung' }
        ],
        'Danach endet die Runde'
      );

      clampStateAfterCard();
      updateUI();
    }

    // ---------- main loop ----------
    function revealEvent(){
      if (state.gameOver) return;
      if (state.awaitingDecision) return;
      if (!state.players.length){
        logStep('bad', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'CHECK_FAIL | reason=NoPlayers',
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'NoPlayers' }
        });
        restart();
        return;
      }
      if (!anyActive()) { endRound('Alle gecampt'); return; }

      var rev = normalizeRevealerIndex();
      state.revealer = rev;
      var revP = state.players[rev];
      if (!revP || revP.roundState !== 'active'){
        var nxt0 = nextActiveFrom(state.revealer, state.direction);
        if (nxt0 === -1) { endRound('Alle gecampt'); return; }
        state.revealer = nxt0;
        rev = nxt0;
        revP = state.players[rev];
      }

      state.turnId += 1;
      resetLogSubStep();
      setPhase('event');

      var card = draw(1)[0] || null;
      if (!card){
        logStep('bad', {
          action: 'DRAW',
          actor: 'System',
          reason: 'DeckEmpty',
          fields: { Card: '‚Äî', DeckPos: '‚Äî', DeckRemaining: 0 },
          msgHtml: 'DRAW_FAIL',
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'DeckEmpty' }
        });
        endRound('Deck leer');
        return;
      }

      state.lastEvent = card;
      setEventCard(card);
      updateUI();

      logStep('info', {
        action: 'DRAW',
        actor: revP.name,
        actorIdx: rev,
        reason: 'EventDraw',
        fields: {
          Card: esc(card.name),
          DeckPos: card._drawMeta ? card._drawMeta.deckPos : '‚Äî',
          DeckRemaining: card._drawMeta ? card._drawMeta.deckRemaining : '‚Äî'
        },
        msgHtml: 'DRAW',
        before: actorSnapshot(rev),
        after: actorSnapshot(rev),
        reasons: { extra: 'EventDraw' }
      });

      var roundResetId = state.roundResetId;
      resolveEventCard(rev, card, function(){
        if (state.gameOver || state.roundResetId !== roundResetId) { updateUI(); return; }

        if (state.forceFinalCampWindow){
          if (!state.awaitingDecision){
            ensureDecisionPhase();
          }
          pumpBots();
          return;
        }

        if (state.skipCountdownOnce){
          state.skipCountdownOnce = false;
        } else {
          resolveCountdownTick();
          if (state.gameOver || state.roundResetId !== roundResetId) { updateUI(); return; }
        }

        if (sollDecisionWindowOeffnen()){
          ensureDecisionPhase();
          pumpBots();
        } else {
          skipDecisionWindow('NoMeaningfulChoice');
        }
      });
    }

    function resolveEventCard(rev, card, done){
      var type = card.type;

      if (type === 'push'){
        applyPush(rev, card);
        state.discard.push(card);
        clampStateAfterCard();
        done();
        return;
      }

      if (type === 'stabilize'){
        applyStabilize(rev, card);
        state.discard.push(card);
        clampStateAfterCard();
        done();
        return;
      }

      if (type === 'twist'){
        applyTwist(rev, card, function(){
          if (!card.stage) state.discard.push(card);
          clampStateAfterCard();
          done();
        });
        return;
      }

      if (type === 'encore'){
        state.discard.push(card);
        applyEncore(rev, card);
        clampStateAfterCard();
        done();
        return;
      }

      state.discard.push(card);
      done();
    }

    function applyCampTransfer(p, extraCamp, poolTakeOverride){
      var liveBefore = p.live;
      var campBefore = p.camp;
      var poolBefore = state.pool;
      var poolTake = (typeof poolTakeOverride === 'number') ? poolTakeOverride : poolTakeFor(state.pool, maxPoolToCampThisCamp());
      if (!darfPoolZuCamp(liveBefore)) poolTake = 0;
      p.camp += liveBefore + poolTake + extraCamp;
      p.live = 0;
      state.pool = Math.max(0, state.pool - poolTake);
      p.roundState = 'camped';
      return {
        liveBefore: liveBefore,
        campBefore: campBefore,
        poolBefore: poolBefore,
        poolTake: poolTake,
        extraCamp: extraCamp || 0
      };
    }

    function getCampStats(){
      var leader = -Infinity;
      var min = Infinity;
      for (var i=0;i<state.players.length;i++){
        leader = Math.max(leader, state.players[i].camp);
        min = Math.min(min, state.players[i].camp);
      }
      return {
        leaderCamp: leader,
        minCamp: min,
        allEqual: (leader === min)
      };
    }

    function triggerFinalPush(reason){
      var idx = getLastActiveIndex();
      if (idx === -1) return false;
      var p = state.players[idx];
      state.finalPushUsed = true;
      state.finalPushGraceUsed = false;
      state.finalPushForceNext = false;
      state.finalPushActor = idx;
      logStep('warn', {
        action: 'CHECK',
        actor: 'System',
        msgHtml: 'FINAL_PUSH_TRIGGER | lastActive=' + esc(p.name) + (reason ? ' | reason=' + esc(reason) : ''),
        fields: { FinalPushActive: 'true', GraceUsed: 'false', LastCallForced: 'false' },
        before: actorSnapshot(idx),
        after: actorSnapshot(idx),
        reasons: { extra: 'FinalPush' }
      });
      setHeadline('Final Push: letzter Spieler bleibt f√ºr 1 Event', 1600);
      showPlayBanner('warn', 'Final Push: 1 Extra-Event', 1600);
      toast('Final Push', p.name + ' erh√§lt 1 Extra-Event.');
      updateUI();
      revealEvent();
      return true;
    }

    function advanceAfterDecision(){
      if (checkWin()) { updateUI(); return; }

      if (activeCount() === 1){
        updateUI();
        if (!state.finalPushUsed){
          recordDebugSnapshot('beforeFinalPush');
          if (triggerFinalPush('Anti-Solo nach Camp-Phase')) return;
        }
      }

      if (activeCount() === 0){
        logStep('good', {
          action: 'ROUND_END_SUMMARY',
          actor: 'System',
          reason: 'AllCamped',
          fields: { RoundEndReason: 'Alle gecampt', PoolExpired: (state.pool > 0 ? 'yes' : 'no'), OverloadReset: 0 },
          msgHtml: 'ROUND_END_SUMMARY',
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'AllCamped' }
        });
        recordDebugSnapshot('allCamped');
        endRound('Alle gecampt');
        return;
      }

      if (state.extraRevealSame){
        state.extraRevealSame = false;
        logStep('info', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'SETWECHSEL | nextRevealer=' + esc(state.players[state.revealer].name),
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'Setwechsel' }
        });
      } else {
        var nxt = nextActiveFrom(state.revealer, state.direction);
        if (nxt === -1){
          endRound('Alle gecampt');
          return;
        }
        state.revealer = nxt;
      }

      updateUI();
      recordDebugSnapshot('afterDecision');
      pumpBots();
    }

    function resolveDecisions(){
      setPhase('event');
      if (state.gameOver) return;
      if (!state.awaitingDecision) return;
      if (!state.players.length){
        logStep('bad', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'CHECK_FAIL | reason=NoPlayers',
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'NoPlayers' }
        });
        restart();
        return;
      }
      // Aufdecker-Index absichern, bevor die Reihenfolge bestimmt wird.
      state.revealer = normalizeRevealerIndex();
      stopDecisionTimer();

      var choices = [];
      for (var i=0;i<state.players.length;i++){
        var p = state.players[i];
        if (p.roundState !== 'active') continue;

        var choice = 'stay';
        var forced = false;
        var forcedReason = '';
        var isFinalPushActor = (state.finalPushUsed && i === state.finalPushActor);
        var isFinalPushLastCall = (state.finalPushForceNext && isFinalPushActor);
        if (isFinalPushLastCall){
          choice = 'camp';
          forced = true;
          forcedReason = 'FinalPushLastCall';
        }
        if (i === state.humanIndex){
          if (!isFinalPushLastCall){
            if (isAutoAll()){
              choice = botWantsToCamp(i) ? 'camp' : 'stay';
            } else if (p.forcedStay) {
              choice = 'stay';
            } else {
              if (state.humanChoice === 'camp' && p.live <= 0) choice = 'stay';
              else choice = state.humanChoice;
            }
          }
        } else {
          if (!isFinalPushLastCall){
            if (areBotsManual()){
              choice = state.botChoices[String(i)] || 'stay';
            } else {
              choice = botWantsToCamp(i) ? 'camp' : 'stay';
            }
            if (p.forcedStay) choice = 'stay';
          }
        }

        if (p.forcedStay && !isFinalPushLastCall){
          forced = true;
          forcedReason = 'StageDive';
        }

        if (choice === 'camp' && p.live <= 0 && !isFinalPushLastCall) choice = 'stay';
        choices.push({ idx:i, choice:choice, forced:forced, forcedReason:forcedReason });
      }

      var eligibleNames = [];
      for (var j=0;j<choices.length;j++){
        eligibleNames.push(state.players[choices[j].idx].name);
      }
      var windowId = ++state.decisionWindowId;
      logStep('info', {
        action: 'DECISION',
        actor: 'System',
        reason: 'DecisionWindowOpen',
        fields: {
          DecisionWindow: 'OPEN',
          eligible: esc(eligibleNames.join(', ')),
          windowId: windowId,
          FinalPushActive: (state.finalPushUsed ? 'true' : 'false'),
          FinalPushGraceUsed: (state.finalPushGraceUsed ? 'true' : 'false')
        },
        msgHtml: 'DECISION_WINDOW_OPEN',
        before: actorSnapshot(null),
        after: actorSnapshot(null),
        reasons: { extra: 'DecisionWindowOpen' }
      });

      for (var j2=0;j2<choices.length;j2++){
        var c = choices[j2];
        var label = (c.choice === 'camp') ? 'Camp' : 'Bleib';
        var forcedText = c.forced ? 'true' : 'false';
        var forcedReason = c.forced ? (c.forcedReason || 'Forced') : '';
        var decisionFields = { Decision: label, forced: forcedText };
        if (forcedReason) decisionFields.forcedReason = forcedReason;
        logStep('info', {
          action: 'DECISION',
          actor: state.players[c.idx].name,
          actorIdx: c.idx,
          reason: 'Choice',
          fields: decisionFields,
          msgHtml: 'DECISION_CHOICE',
          before: actorSnapshot(c.idx),
          after: actorSnapshot(c.idx),
          reasons: { extra: (c.forced ? 'ForcedStay' : 'Choice') }
        });
      }

      logStep('info', {
        action: 'DECISION',
        actor: 'System',
        reason: 'DecisionWindowClose',
        fields: { DecisionWindow: 'CLOSE', windowId: windowId },
        msgHtml: 'DECISION_WINDOW_CLOSE',
        before: actorSnapshot(null),
        after: actorSnapshot(null),
        reasons: { extra: 'DecisionWindowClose' }
      });

      if (state.finalPushUsed && !state.finalPushGraceUsed){
        for (var g=0;g<choices.length;g++){
          var gc = choices[g];
          if (gc.idx !== state.finalPushActor) continue;
          if (gc.choice === 'stay'){
            state.finalPushGraceUsed = true;
            state.finalPushForceNext = true;
            logStep('warn', {
              action: 'DECISION',
              actor: state.players[gc.idx].name,
              actorIdx: gc.idx,
              reason: 'FinalPushGraceStay',
              fields: { FinalPushActive: 'true', GraceUsed: 'true', LastCallForced: 'true' },
              msgHtml: 'FINAL_PUSH_GRACE_USED',
              before: actorSnapshot(gc.idx),
              after: actorSnapshot(gc.idx),
              reasons: { extra: 'FinalPushGraceUsed' }
            });
          }
          break;
        }
      }

      for (var x=0;x<choices.length;x++){
        var pl = state.players[choices[x].idx];
        if (pl.forcedStay) pl.forcedStay = false;
      }

      var order = orderFrom(state.revealer, state.direction);
      var campersSet = {};
      for (var k=0;k<choices.length;k++) if (choices[k].choice === 'camp') campersSet[String(choices[k].idx)] = true;

      var anySuccessfulCamp = false;
      var poolGate = maxPoolToCampThisCamp();
      var eligibleCampers = [];
      var poolEligibleCampers = [];
      for (var o=0;o<order.length;o++){
        var idx = order[o];
        if (!campersSet[String(idx)]) continue;
        var p2 = state.players[idx];
        if (p2.roundState !== 'active') continue;

        if (p2.live <= 0){
          logStep('warn', {
            action: 'RESOLVE_CAMP',
            actor: p2.name,
            actorIdx: idx,
            msgHtml: 'CAMP_DENIED | reason=Live0',
            before: actorSnapshot(idx),
            after: actorSnapshot(idx),
            reasons: { extra: 'CampDeniedLive0' }
          });
          continue;
        }

        eligibleCampers.push(idx);
        if (poolGate > 0 && darfPoolZuCamp(p2.live)) poolEligibleCampers.push(idx);
      }

      var poolPlan = null;
      if (poolEligibleCampers.length){
        poolPlan = planCampPoolDistribution(poolEligibleCampers, state.pool, poolGate);
        var camperNames = [];
        for (var n=0;n<poolEligibleCampers.length;n++) camperNames.push(esc(state.players[poolEligibleCampers[n]].name));
        logStep('info', {
          action: 'RESOLVE_CAMP',
          actor: 'System',
          reason: 'CampOrder',
          fields: { Order: camperNames.join(', '), PoolCap: poolGate, PoolGate: poolGate },
          msgHtml: 'RESOLVE_CAMP_ORDER',
          before: actorSnapshot(null),
          after: actorSnapshot(null)
        });
        if (poolPlan.rounds.length){
          var roundParts = [];
          for (var r=0;r<poolPlan.rounds.length;r++){
            var round = poolPlan.rounds[r];
            var entries = [];
            for (var q=0;q<round.length;q++){
              entries.push(esc(state.players[round[q]].name) + ' +1');
            }
            roundParts.push('Runde ' + (r + 1) + ': ' + entries.join(', '));
          }
          logStep('info', {
            action: 'RESOLVE_CAMP',
            actor: 'System',
            reason: 'CampPlan',
            fields: { PoolPlan: roundParts.join(' ¬∑ '), PoolGate: poolGate },
            msgHtml: 'POOL_DISTRIBUTION',
            before: actorSnapshot(null),
            after: actorSnapshot(null)
          });
        } else if (state.pool <= 0){
          logStep('info', {
            action: 'RESOLVE_CAMP',
            actor: 'System',
            reason: 'CampPlan',
            fields: { PoolPlan: 'Pool leer', PoolGate: poolGate },
            msgHtml: 'POOL_DISTRIBUTION',
            before: actorSnapshot(null),
            after: actorSnapshot(null)
          });
        }
      } else if (poolGate <= 0){
        logStep('info', {
          action: 'RESOLVE_CAMP',
          actor: 'System',
          reason: 'CampPlan',
          fields: { PoolPlan: 'Overload-Gate=0', PoolGate: poolGate },
          msgHtml: 'POOL_DISTRIBUTION',
          before: actorSnapshot(null),
          after: actorSnapshot(null)
        });
      }

      for (var o2=0;o2<order.length;o2++){
        var idx2 = order[o2];
        if (!campersSet[String(idx2)]) continue;
        var p3 = state.players[idx2];
        if (p3.roundState !== 'active') continue;
        if (p3.live <= 0) continue;

        var poolBeforeCamper = state.pool;
        var poolAllowed = (poolGate > 0 && darfPoolZuCamp(p3.live));
        var poolRequested = poolAllowed ? Math.min(poolBeforeCamper, poolGate) : 0;
        var poolGranted = (poolAllowed && poolPlan) ? (poolPlan.takes[String(idx2)] || 0) : 0;
        poolGranted = Math.min(poolGate, poolGranted);
        var transfer = applyCampTransfer(p3, 0, poolGranted);
        var campBeforeCatchUp = p3.camp;
        var stats = getCampStats();
        var leaderCamp = stats.leaderCamp;
        var gapToLeader = leaderCamp - campBeforeCatchUp;
        var reasonFlags = [];
        if (state.overload >= 8) reasonFlags.push('Overload>=8');
        else reasonFlags.push('Overload<8');
        if (stats.allEqual) reasonFlags.push('AllEqual');
        else reasonFlags.push('NotAllEqual');
        if (campBeforeCatchUp < leaderCamp) reasonFlags.push('BehindLeader');
        else reasonFlags.push('NotBehindLeader');
        if (gapToLeader >= 2) reasonFlags.push('Gap>=2');
        else reasonFlags.push('Gap<2');
        if (state.catchUpGrantedRound[String(idx2)]) reasonFlags.push('AlreadyGranted');
        else reasonFlags.push('NotGrantedYet');

        var shouldCatchUp = (state.overload >= 8)
          && !stats.allEqual
          && (campBeforeCatchUp < leaderCamp)
          && (gapToLeader >= 2)
          && !state.catchUpGrantedRound[String(idx2)];
        anySuccessfulCamp = true;
        if (idx2 === state.finalPushActor) state.finalPushForceNext = false;
        logStep('warn', {
          action: 'RESOLVE_CAMP',
          actor: p3.name,
          actorIdx: idx2,
          reason: 'CampResolve',
          fields: {
            LiveToCamp: transfer.liveBefore,
            PoolToCampRequested: poolRequested,
            PoolToCampGranted: poolGranted,
            PoolCap: poolGate,
            PoolGate: poolGate,
            PoolToCampPossible: poolGate,
            PoolToCampBlocked: (poolAllowed ? null : (poolGate > 0 ? 'LiveTooLow' : 'OverloadGate'))
          },
          msgHtml: 'Pool‚ÜíCamp m√∂glich: ' + poolGate + ' (Overload-Gate), gew√ºnscht: ' + poolRequested + ', gew√§hrt: ' + poolGranted,
          before: { overload: state.overload, pool: transfer.poolBefore, live: transfer.liveBefore, camp: transfer.campBefore },
          after: { overload: state.overload, pool: state.pool, live: 0, camp: campBeforeCatchUp },
          reasons: {
            camp: 'LiveToCamp=' + transfer.liveBefore + ', PoolToCamp=' + poolGranted,
            pool: '-'+poolGranted+' PoolToCamp(cap' + poolGate + ')'
          }
        });
        if (shouldCatchUp){
          p3.camp += 1;
          state.catchUpGrantedRound[String(idx2)] = true;
          logStep('info', {
            action: 'RESOLVE_CAMP',
            actor: p3.name,
            actorIdx: idx2,
            reason: 'CatchUp',
            fields: {
              CatchUp: '+1',
              Overload: state.overload,
              LeaderCamp: leaderCamp,
              PlayerCampBefore: campBeforeCatchUp,
              PlayerCampAfter: p3.camp,
              Delta: 1,
              ReasonFlags: reasonFlags.join(', ')
            },
            msgHtml: 'Catch-up: +1 Camp (strict hinten, Abstand ‚â•2, Overload>=8)',
            before: { overload: state.overload, pool: state.pool, live: 0, camp: campBeforeCatchUp },
            after: { overload: state.overload, pool: state.pool, live: 0, camp: p3.camp },
            reasons: { camp: '+1 CatchUp' }
          });
        }
      }
      if (anySuccessfulCamp){
        showPlayBanner('good', 'Camp-Aufl√∂sung abgeschlossen', 1200);
      }

      if (!state.countdownActive && anySuccessfulCamp){
        startCountdown('FirstCamp');
      }

      state.awaitingDecision = false;
      state.humanChoice = 'stay';

      if (state.forceFinalCampWindow){
        state.forceFinalCampWindow = false;
        endRound('Finale Camp-Phase');
        return;
      }

      advanceAfterDecision();
    }

    // ---------- bots automation ----------
    function pumpBots(){
      if (state.gameOver) return;
      if (!state.players.length) return;
      state.revealer = normalizeRevealerIndex();

      if (isAutoAll()){
        if (state.askOpen) return;

        if (state.awaitingDecision){
          scheduleAuto(function(){
            if (state.gameOver) return;
            if (!state.awaitingDecision) return;
            if (state.askOpen) return;

            var h = state.players[state.humanIndex];
            if (h && h.roundState === 'active' && !h.forcedStay && h.live > 0){
              state.humanChoice = botWantsToCamp(state.humanIndex) ? 'camp' : 'stay';
            } else {
              state.humanChoice = 'stay';
            }

            resolveDecisions();
          });
          return;
        }

        scheduleAuto(function(){
          if (state.gameOver) return;
          if (state.awaitingDecision) return;
          if (state.askOpen) return;
          revealEvent();
        });
        return;
      }

      stopAutoTimer();

      // Manuell: Bot-Z√ºge laufen automatisch, au√üer Bots werden manuell gesteuert.
      if (!state.awaitingDecision && state.revealer !== state.humanIndex && areBotsAuto()){
        var r = state.revealer;
        if (state.players[r].roundState !== 'active'){
          var nxt = nextActiveFrom(r, state.direction);
          if (nxt === -1){ endRound('Alle gecampt'); return; }
          state.revealer = nxt;
          updateUI();
          r = nxt;
        }

        setTimeout(function(){
          if (state.gameOver || state.awaitingDecision) return;
          if (state.revealer === state.humanIndex) return;
          revealEvent();
        }, 650);
        return;
      }
    }

    // ---------- log copy ----------
    function copyLog(){
      var el = document.getElementById('log');
      var text = (el.innerText || '').trim();
      if (!text){ toast('Log leer', 'Nichts zu kopieren.'); return; }

      if (navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(text)
          .then(function(){ toast('Kopiert','Log wurde in die Zwischenablage kopiert.'); })
          .catch(function(){ fallbackCopy(text); });
        return;
      }
      fallbackCopy(text);
    }

    function fallbackCopy(text){
      var ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand('copy'); toast('Kopiert','Log wurde in die Zwischenablage kopiert.'); }
      catch(e){ toast('Copy fehlgeschlagen','Browser erlaubt keinen Zugriff auf Zwischenablage.'); }
      document.body.removeChild(ta);
    }

    // ---------- patch notes modal ----------
    function openPatchNotes(){
      var back = document.getElementById('pnBack');
      var body = document.getElementById('pnBody');

      var html = '';
      for (var i=0;i<PATCH_NOTES.length;i++){
        var p = PATCH_NOTES[i];
        var items = '';
        for (var k=0;k<p.items.length;k++) items += '<li>' + esc(p.items[k]) + '</li>';

        html +=
          '<div style="margin-bottom:12px">' +
            '<div style="display:flex;justify-content:space-between;gap:12px;align-items:baseline">' +
              '<b style="font-weight:950">' + esc(p.ver) + '</b>' +
              '<small style="color:var(--muted)">' + esc(p.date) + '</small>' +
            '</div>' +
            '<ul style="margin:6px 0 0 18px;color:#d6dbea">' + items + '</ul>' +
          '</div>';
      }

      body.innerHTML = html;
      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    function closePatchNotes(){
      var back = document.getElementById('pnBack');
      back.style.display = 'none';
      back.setAttribute('aria-hidden','true');
    }

    function openRules(){
      var back = document.getElementById('rulesBack');
      if (!back) return;
      back.style.display = 'flex';
      back.setAttribute('aria-hidden','false');
    }

    function closeRules(){
      var back = document.getElementById('rulesBack');
      if (!back) return;
      back.style.display = 'none';
      back.setAttribute('aria-hidden','true');
    }

    function togglePlayLog(forceOpen){
      var drawer = document.getElementById('playLogDrawer');
      if (!drawer) return;
      var shouldOpen = (typeof forceOpen === 'boolean') ? forceOpen : !drawer.classList.contains('open');
      drawer.classList.toggle('open', shouldOpen);
      drawer.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
    }

    // ---------- self tests ----------
    function shouldRunSelfTests(){
      // Selbsttests nur explizit per URL aktivieren, damit Logs/UI nicht im Normalbetrieb beeinflusst werden.
      return window.location.search.indexOf('selftest=1') !== -1;
    }

    function runSelfTests(){
      var results = [];
      function ok(name, cond){ results.push({ name:name, pass:!!cond }); }

      ok('DOM: #players existiert', !!document.getElementById('players'));
      ok('Deck: mkDeck() hat 60 Karten', mkDeck().length === 60);

      // Katastrophen-Check non-push -> overload 10
      (function(){
        var oldDeck = state.deck.slice();
        var oldDiscard = state.discard.slice();
        var oldOver = state.overload;
        var oldPlayers = state.players.slice();
        var oldGO = state.gameOver;

        // minimal players, damit doKnall/Logs nicht crashen
        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'active', forcedStay:false }
        ];

        state.deck = [{ type:'stabilize', name:'X', delta:-2 }];
        state.discard = [];
        state.overload = 12;
        state.gameOver = false;
        catastropheCheck();
        ok('Katastrophen-Check non-push -> overload 10', state.overload === OVERLOAD_RESET_AFTER_CHECK);

        // Katastrophen-Check discard pushed
        state.deck = [{ type:'push', name:'Y', delta:1 }];
        state.discard = [];
        state.overload = 12;
        state.gameOver = true; // verhindert endRound-Kaskade
        catastropheCheck();
        ok('Katastrophen-Check discard pushed', state.discard.length === 1);

        state.deck = oldDeck;
        state.discard = oldDiscard;
        state.overload = oldOver;
        state.players = oldPlayers;
        state.gameOver = oldGO;
      })();

      // Pool->Camp-Gate (Overload >=10 => +2 Pool m√∂glich)
      (function(){
        var oldPlayers = state.players.slice();
        var oldPool = state.pool;
        var oldOver = state.overload;

        state.players = [
          { name:'Du', camp:0, live:2, roundState:'active', forcedStay:false }
        ];
        state.pool = 5;
        state.overload = 10;
        var transfer = applyCampTransfer(state.players[0], 0);
        ok('PoolToCamp Gate: Camp +4 (Live 2 + Pool 2)', state.players[0].camp === 4);
        ok('PoolToCamp Gate: Pool -2', state.pool === 3);

        state.players = oldPlayers;
        state.pool = oldPool;
        state.overload = oldOver;
      })();

      // Knall: Halbierung + Pflaster
      (function(){
        var oldPlayers = state.players.slice();
        var oldPool = state.pool;
        var oldOver = state.overload;
        var oldGO = state.gameOver;
        var oldEndRound = endRound;
        var optPfl = document.getElementById('optPflaster');
        var oldPfl = optPfl ? optPfl.checked : false;

        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot B', camp:0, live:3, roundState:'active', forcedStay:false }
        ];
        state.pool = 0;
        state.overload = 12;
        state.gameOver = false;
        if (optPfl) optPfl.checked = true;
        endRound = function(){};
        doKnall('Selftest');
        ok('Knall: live 0 bleibt 0', state.players[0].live === 0);
        ok('Knall: live 1 -> 1 (Halve 0 + Pflaster)', state.players[1].live === 1);
        ok('Knall: live 3 -> 2 (Halve 1 + Pflaster)', state.players[2].live === 2);

        endRound = oldEndRound;
        if (optPfl) optPfl.checked = oldPfl;
        state.players = oldPlayers;
        state.pool = oldPool;
        state.overload = oldOver;
        state.gameOver = oldGO;
      })();

      // Stabilisieren-Ertrag nur bei Overload 9+
      (function(){
        var oldOver = state.overload;
        var oldPlayers = state.players.slice();
        var oldPool = state.pool;
        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'active', forcedStay:false }
        ];

        state.pool = 0;
        state.overload = 0;
        applyStabilize(0, { type:'stabilize', name:'Test', delta:-2, text:'' });
        ok('Stabilisieren: Overload 0 -> kein Pool', state.pool === 0);

        state.pool = 0;
        state.overload = 5;
        applyStabilize(0, { type:'stabilize', name:'Test', delta:-2, text:'' });
        ok('Stabilisieren: Overload 5 -> kein Pool', state.pool === 0);

        state.pool = 0;
        state.overload = 9;
        applyStabilize(0, { type:'stabilize', name:'Test', delta:-2, text:'' });
        ok('Stabilisieren: Overload 9 -> +1 Live', state.players[0].live === 1);

        state.overload = oldOver;
        state.players = oldPlayers;
        state.pool = oldPool;
      })();

      // Camp mit Live=1 bekommt keinen Pool-Bonus (Gate egal)
      (function(){
        var oldPlayers = state.players.slice();
        var oldPool = state.pool;
        var oldAwait = state.awaitingDecision;
        var oldAdvance = advanceAfterDecision;
        var oldOver = state.overload;

        state.players = [
          { name:'Du', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:2, roundState:'active', forcedStay:false }
        ];
        state.pool = 3;
        state.overload = 8;
        state.awaitingDecision = true;
        state.humanIndex = 0;
        state.humanChoice = 'camp';
        state.humanLockedIn = true;
        state.botChoices = { '1':'stay' };
        state.revealer = 0;
        state.direction = 1;
        advanceAfterDecision = function(){};

        resolveDecisions();
        ok('Camp Live=1: Pool bleibt gleich', state.pool === 3);
        ok('Camp Live=1: Camp +1', state.players[0].camp === 1);

        advanceAfterDecision = oldAdvance;
        state.players = oldPlayers;
        state.pool = oldPool;
        state.awaitingDecision = oldAwait;
        state.overload = oldOver;
      })();

      // Anti-Solo: Final Push triggert Extra-Event
      (function(){
        var oldPlayers = state.players.slice();
        var oldAwait = state.awaitingDecision;
        var oldReveal = revealEvent;
        var oldFinalPush = state.finalPushUsed;
        var triggered = false;

        state.players = [
          { name:'Du', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'camped', forcedStay:false }
        ];
        state.awaitingDecision = true;
        state.humanIndex = 0;
        state.humanChoice = 'stay';
        state.humanLockedIn = true;
        state.botChoices = {};
        state.revealer = 0;
        state.direction = 1;
        state.finalPushUsed = false;
        revealEvent = function(){ triggered = true; };
        resolveDecisions();
        ok('Final Push: Extra-Event wird ausgel√∂st', triggered);
        ok('Final Push: Flag gesetzt', state.finalPushUsed === true);

        revealEvent = oldReveal;
        state.players = oldPlayers;
        state.awaitingDecision = oldAwait;
        state.finalPushUsed = oldFinalPush;
      })();

      // DecisionWindow-Skip ohne sinnvolle Wahl
      (function(){
        var oldPlayers = state.players.slice();
        var oldFinalForce = state.finalPushForceNext;
        var oldFinalActor = state.finalPushActor;
        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'active', forcedStay:false }
        ];
        state.finalPushForceNext = false;
        state.finalPushActor = -1;
        ok('DecisionWindow: Skip bei Live=0 ohne Zwang', sollDecisionWindowOeffnen() === false);

        state.players = oldPlayers;
        state.finalPushForceNext = oldFinalForce;
        state.finalPushActor = oldFinalActor;
      })();

      // Final Push: 1 Gnaden-Bleib, danach Last Call
      (function(){
        var oldPlayers = state.players.slice();
        var oldAwait = state.awaitingDecision;
        var oldAdvance = advanceAfterDecision;
        var oldFinalUsed = state.finalPushUsed;
        var oldFinalGrace = state.finalPushGraceUsed;
        var oldFinalForce = state.finalPushForceNext;
        var oldFinalActor = state.finalPushActor;

        state.players = [
          { name:'Du', camp:0, live:1, roundState:'active', forcedStay:false }
        ];
        state.awaitingDecision = true;
        state.humanIndex = 0;
        state.humanChoice = 'stay';
        state.humanLockedIn = true;
        state.botChoices = {};
        state.revealer = 0;
        state.direction = 1;
        state.finalPushUsed = true;
        state.finalPushGraceUsed = false;
        state.finalPushForceNext = false;
        state.finalPushActor = 0;
        advanceAfterDecision = function(){};

        resolveDecisions();
        ok('Final Push: Gnaden-Bleib setzt Last Call', state.finalPushGraceUsed === true && state.finalPushForceNext === true);

        advanceAfterDecision = oldAdvance;
        state.players = oldPlayers;
        state.awaitingDecision = oldAwait;
        state.finalPushUsed = oldFinalUsed;
        state.finalPushGraceUsed = oldFinalGrace;
        state.finalPushForceNext = oldFinalForce;
        state.finalPushActor = oldFinalActor;
      })();

      // Mini-Testlauf (Seeded RNG): Nach RoundReset keine Entscheidung ohne Event.
      (function(){
        var oldRng = { seed: state.rngSeed, rngState: state.rngState, rngStep: state.rngStep };
        seedRng(1337);

        var oldState = {
          deck: state.deck.slice(),
          discard: state.discard.slice(),
          players: state.players.slice(),
          overload: state.overload,
          pool: state.pool,
          round: state.round,
          awaitingDecision: state.awaitingDecision,
          humanChoice: state.humanChoice,
          humanLockedIn: state.humanLockedIn,
          lastEvent: state.lastEvent,
          phase: state.phase,
          roundResetId: state.roundResetId,
          gameOver: state.gameOver,
          turnId: state.turnId,
          startPlayer: state.startPlayer,
          revealer: state.revealer,
          direction: state.direction,
          extraRevealSame: state.extraRevealSame,
          stageRule: state.stageRule,
          feedbackLevel: state.feedbackLevel,
          countdownActive: state.countdownActive,
          encoreChain: state.encoreChain,
          botChoices: state.botChoices,
          finalPushUsed: state.finalPushUsed,
          finalPushGraceUsed: state.finalPushGraceUsed,
          finalPushForceNext: state.finalPushForceNext,
          finalPushActor: state.finalPushActor
        };

        state.players = [
          { name:'Du', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:1, roundState:'active', forcedStay:false }
        ];
        state.overload = 11;
        state.pool = 0;
        state.round = 1;
        state.awaitingDecision = false;
        state.humanChoice = 'stay';
        state.humanLockedIn = false;
        state.lastEvent = null;
        state.phase = 'reveal';
        state.roundResetId = 0;
        state.gameOver = false;
        state.turnId = 0;
        state.startPlayer = 0;
        state.revealer = 0;
        state.direction = 1;
        state.extraRevealSame = false;
        state.stageRule = null;
        state.feedbackLevel = 0;
        state.countdownActive = false;
        state.encoreChain = 0;
        state.botChoices = {};
        state.deck = [
          { type:'push', name:'Check', delta:1, text:'' },
          { type:'push', name:'Test-Push', delta:1, text:'' }
        ];
        state.discard = [];

        revealEvent();

        ok('Mini-Test: RoundReset blockt Entscheidung ohne Event',
          !state.awaitingDecision && state.phase === 'reveal' && state.lastEvent === null);

        state.deck = oldState.deck;
        state.discard = oldState.discard;
        state.players = oldState.players;
        state.overload = oldState.overload;
        state.pool = oldState.pool;
        state.round = oldState.round;
        state.awaitingDecision = oldState.awaitingDecision;
        state.humanChoice = oldState.humanChoice;
        state.humanLockedIn = oldState.humanLockedIn;
        state.lastEvent = oldState.lastEvent;
        state.phase = oldState.phase;
        state.roundResetId = oldState.roundResetId;
        state.gameOver = oldState.gameOver;
        state.turnId = oldState.turnId;
        state.startPlayer = oldState.startPlayer;
        state.revealer = oldState.revealer;
        state.direction = oldState.direction;
        state.extraRevealSame = oldState.extraRevealSame;
        state.stageRule = oldState.stageRule;
        state.feedbackLevel = oldState.feedbackLevel;
        state.countdownActive = oldState.countdownActive;
        state.encoreChain = oldState.encoreChain;
        state.botChoices = oldState.botChoices;
        state.finalPushUsed = oldState.finalPushUsed;
        state.finalPushGraceUsed = oldState.finalPushGraceUsed;
        state.finalPushForceNext = oldState.finalPushForceNext;
        state.finalPushActor = oldState.finalPushActor;
        state.rngSeed = oldRng.seed;
        state.rngState = oldRng.rngState;
        state.rngStep = oldRng.rngStep;
      })();

      // Engine-Fix-Checks (deterministisch, optionaler Debug-Helper).
      (function(){
        if (!window.FestivalOverloadDebug || typeof window.FestivalOverloadDebug.runEngineFixChecks !== 'function') return;
        var fixResults = window.FestivalOverloadDebug.runEngineFixChecks(20240202);
        if (!fixResults || !fixResults.length) return;
        for (var i=0;i<fixResults.length;i++){
          ok('EngineFix: ' + fixResults[i].name, fixResults[i].pass);
        }
      })();

      window.FestivalOverloadTests = results;
      try {
        var failed = 0;
        for (var i=0;i<results.length;i++) if (!results[i].pass) failed++;
        if (failed) console.warn('FestivalOverloadTests: FAIL', results);
        else console.log('FestivalOverloadTests: OK', results);
      } catch(e){}
    }

    window.FestivalOverloadDebug = {
      runCampPoolDemo: function(seed){
        var oldRng = { seed: state.rngSeed, rngState: state.rngState, rngStep: state.rngStep };
        var s = (typeof seed === 'number') ? seed : 4242;
        seedRng(s);

        var logEl = document.getElementById('log');
        if (logEl) logEl.innerHTML = '';
        var playLog = document.getElementById('logPlay');
        if (playLog) playLog.innerHTML = '';
        state.debugLogEntries = [];
        state.debugSnapshots = [];

        state.turnId = 1;
        state.overload = 8;
        state.pool = 4;
        state.revealer = 1;
        state.direction = 1;
        state.awaitingDecision = true;
        state.humanIndex = 0;
        state.humanChoice = 'camp';
        state.humanLockedIn = true;
        state.botChoices = { '1': 'camp', '2': 'camp' };
        state.players = [
          { name:'Du', camp:0, live:2, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot B', camp:0, live:1, roundState:'active', forcedStay:false }
        ];

        logStep('info', {
          action: 'CHECK',
          actor: 'System',
          msgHtml: 'DebugSeed=' + s,
          before: actorSnapshot(null),
          after: actorSnapshot(null),
          reasons: { extra: 'DebugSeed' }
        });
        resolveDecisions();
        updateUI();
        state.rngSeed = oldRng.seed;
        state.rngState = oldRng.rngState;
        state.rngStep = oldRng.rngStep;
      },
      runEngineFixChecks: function(seed){
        var results = [];
        function ok(name, cond){ results.push({ name:name, pass:!!cond }); }
        var oldState = {
          players: state.players.slice(),
          deck: state.deck.slice(),
          discard: state.discard.slice(),
          overload: state.overload,
          pool: state.pool,
          round: state.round,
          awaitingDecision: state.awaitingDecision,
          humanChoice: state.humanChoice,
          humanLockedIn: state.humanLockedIn,
          botChoices: state.botChoices,
          revealer: state.revealer,
          direction: state.direction,
          lastEvent: state.lastEvent,
          phase: state.phase,
          roundResetId: state.roundResetId,
          gameOver: state.gameOver,
          turnId: state.turnId,
          startPlayer: state.startPlayer,
          stageRule: state.stageRule,
          feedbackLevel: state.feedbackLevel,
          countdownActive: state.countdownActive,
          encoreChain: state.encoreChain,
          finalPushUsed: state.finalPushUsed,
          finalPushGraceUsed: state.finalPushGraceUsed,
          finalPushForceNext: state.finalPushForceNext,
          finalPushActor: state.finalPushActor,
          skipCountdownOnce: state.skipCountdownOnce,
          logSubStep: state.logSubStep,
          debugLogEntries: state.debugLogEntries.slice(),
          debugSnapshots: state.debugSnapshots.slice(),
          rngSeed: state.rngSeed,
          rngState: state.rngState,
          rngStep: state.rngStep,
          catchUpGrantedRound: Object.assign({}, state.catchUpGrantedRound)
        };

        var fixedSeed = (typeof seed === 'number') ? seed : 20240202;
        seedRng(fixedSeed);

        state.debugLogEntries = [];
        state.debugSnapshots = [];

        // Catch-up darf bei 0/0/0/0 nicht greifen.
        state.players = [
          { name:'Du', camp:0, live:1, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:1, roundState:'active', forcedStay:false }
        ];
        state.overload = 8;
        state.pool = 0;
        state.awaitingDecision = true;
        state.humanIndex = 0;
        state.humanChoice = 'camp';
        state.humanLockedIn = true;
        state.botChoices = { '1': 'camp' };
        state.revealer = 0;
        state.direction = 1;
        state.countdownActive = false;
        state.catchUpGrantedRound = {};
        resolveDecisions();
        ok('CatchUp: kein Bonus bei Gleichstand 0/0', state.players[0].camp === 1 && state.players[1].camp === 1);

        // Overload >=8 im Zug: Countdown-Tick + Check vor Entscheidung.
        state.players = [
          { name:'Du', camp:0, live:0, roundState:'active', forcedStay:false },
          { name:'Bot A', camp:0, live:0, roundState:'active', forcedStay:false }
        ];
        state.overload = 7;
        state.pool = 0;
        state.awaitingDecision = false;
        state.humanChoice = 'stay';
        state.humanLockedIn = false;
        state.botChoices = {};
        state.revealer = 0;
        state.direction = 1;
        state.countdownActive = false;
        state.catchUpGrantedRound = {};
        state.turnId = 0;
        state.phase = 'reveal';
        state.lastEvent = null;
        state.deck = [
          { type:'push', name:'Test-Push', delta:1, text:'' }
        ];
        state.discard = [];
        revealEvent();
        ok('Countdown: Tick im selben Zug (Overload >=9)', state.countdownActive && state.overload >= 9);
        var countdownIdx = -1;
        var decisionIdx = -1;
        for (var i=0;i<state.debugLogEntries.length;i++){
          var entry = state.debugLogEntries[i];
          if (countdownIdx === -1 && entry.data.ActionType === 'COUNTDOWN') countdownIdx = i;
          if (decisionIdx === -1 && entry.data.ActionType === 'DECISION' && entry.data.Fields.indexOf('DecisionWindow=OPEN') !== -1) decisionIdx = i;
        }
        ok('Countdown: Log vor DecisionWindow', countdownIdx !== -1 && decisionIdx !== -1 && countdownIdx < decisionIdx);

        var unknownEffect = false;
        for (var j=0;j<state.debugLogEntries.length;j++){
          if (String(state.debugLogEntries[j].line).indexOf('EffectId=UNKNOWN_EFFECT') !== -1){
            unknownEffect = true;
            break;
          }
        }
        ok('Log: kein UNKNOWN_EFFECT', !unknownEffect);

        state.players = oldState.players;
        state.deck = oldState.deck;
        state.discard = oldState.discard;
        state.overload = oldState.overload;
        state.pool = oldState.pool;
        state.round = oldState.round;
        state.awaitingDecision = oldState.awaitingDecision;
        state.humanChoice = oldState.humanChoice;
        state.humanLockedIn = oldState.humanLockedIn;
        state.botChoices = oldState.botChoices;
        state.revealer = oldState.revealer;
        state.direction = oldState.direction;
        state.lastEvent = oldState.lastEvent;
        state.phase = oldState.phase;
        state.roundResetId = oldState.roundResetId;
        state.gameOver = oldState.gameOver;
        state.turnId = oldState.turnId;
        state.startPlayer = oldState.startPlayer;
        state.stageRule = oldState.stageRule;
        state.feedbackLevel = oldState.feedbackLevel;
        state.countdownActive = oldState.countdownActive;
        state.encoreChain = oldState.encoreChain;
        state.finalPushUsed = oldState.finalPushUsed;
        state.finalPushGraceUsed = oldState.finalPushGraceUsed;
        state.finalPushForceNext = oldState.finalPushForceNext;
        state.finalPushActor = oldState.finalPushActor;
        state.skipCountdownOnce = oldState.skipCountdownOnce;
        state.logSubStep = oldState.logSubStep;
        state.debugLogEntries = oldState.debugLogEntries;
        state.debugSnapshots = oldState.debugSnapshots;
        state.rngSeed = oldState.rngSeed;
        state.rngState = oldState.rngState;
        state.rngStep = oldState.rngStep;
        state.catchUpGrantedRound = oldState.catchUpGrantedRound;

        window.FestivalOverloadEngineFixResults = results;
        var failed = 0;
        for (var r=0;r<results.length;r++) if (!results[r].pass) failed++;
        if (failed) console.warn('FestivalOverloadEngineFix: FAIL', results);
        else console.log('FestivalOverloadEngineFix: OK', results);
        return results;
      }
    };

    // ---------- init / restart ----------
    function restart(){
      stopDecisionTimer();
      if (state.uiHeadlineTimer) clearTimeout(state.uiHeadlineTimer);
      if (state.playBannerTimer) clearTimeout(state.playBannerTimer);
      state.uiHeadlineTimer = null;
      state.playBannerTimer = null;
      state.round = 1;
      state.overload = 0;
      state.pool = 0;
      state.uiHeadline = null;
      state.stageRule = null;
      state.feedbackLevel = 0;
      state.countdownActive = false;
      resetTwistEffects();
      state.direction = 1;
      state.startPlayer = 0;
      state.revealer = 0;
      state.extraRevealSame = false;
      state.botProfileId = botProfilePick();
      state.botCount = clampBotCount(state.botCount || 3);

      state.deck = mkDeck();
      state.discard = [];

      state.players = buildPlayers(state.botCount);

      state.awaitingDecision = false;
      state.humanChoice = 'stay';
      state.humanLockedIn = false;
      state.lastEvent = null;
      state.gameOver = false;
      state.turnId = 0;
      state.encoreChain = 0;
      state.botChoices = {};
      state.askOpen = false;
      state.roundResetId = 0;
      state.forceFinalCampWindow = false;
      state.skipCountdownOnce = false;
      state.finalPushUsed = false;
      state.finalPushGraceUsed = false;
      state.finalPushForceNext = false;
      state.finalPushActor = -1;
      state.logSubStep = 0;
      state.debugSnapshots = [];
      state.debugLogEntries = [];
      seedRng(Date.now());
      state.lastGlobalSnapshot = null;
      state.decisionWindowId = 0;
      state.debugAssertTriggered = false;
      state.catchUpGrantedRound = {};
      var askBack = document.getElementById('askBack');
      if (askBack){
        askBack.style.display = 'none';
        askBack.setAttribute('aria-hidden','true');
      }

      state.phase = 'reveal';
      state.lastSummary = null;
      resetMoodDeck();

      document.getElementById('log').innerHTML = '';
      var playLog = document.getElementById('logPlay');
      if (playLog) playLog.innerHTML = '';
      togglePlayLog(false);
      setEventCard(null);
      setSummary('Bereit',
        [
          { cls:'blue', sym:'‚ñ∂', text:'Klicke auf ‚ÄûEvent aufdecken‚Äú, um zu starten' },
          { cls:'warn', sym:'üèÅ', text:'Ziel: ' + WIN_CAMP + ' Camp' },
          { cls:'good', sym:'üõ†Ô∏è', text:'Stabilisieren: Pool +0, Live +1 nur bei Overload 9+' }
        ],
        'Runde 1 beginnt'
      );
      logStep('info', {
        action: 'ROUND_START',
        actor: 'System',
        reason: 'Init',
        fields: {
          round: state.round,
          startPlayer: esc(state.players[state.startPlayer].name),
          seed: state.rngSeed,
          targetCamp: WIN_CAMP
        },
        msgHtml: 'ROUND_START_INIT',
        before: { overload: state.overload, pool: state.pool, live: null, camp: null },
        after: { overload: state.overload, pool: state.pool, live: null, camp: null },
        reasons: { extra: 'Init' }
      });
      setPhase('reveal');
      updateUI();
      pumpBots();
    }

    // ---------- wiring ----------
    document.getElementById('verText').textContent = VERSION;
    document.getElementById('verBtn').onclick = openPatchNotes;
    document.getElementById('pnClose').onclick = closePatchNotes;
    document.getElementById('pnBack').addEventListener('click', function(e){ if (e.target.id === 'pnBack') closePatchNotes(); });

    document.addEventListener('keydown', function(e){
      if (e.key === 'Escape'){
        closePatchNotes();
        closeRules();
        togglePlayLog(false);
        if (state.askOpen){
          var back = document.getElementById('askBack');
          back.style.display = 'none';
          back.setAttribute('aria-hidden','true');
          state.askOpen = false;
        }
      }
    });

    var btnModePlay = document.getElementById('btnModePlay');
    if (btnModePlay) btnModePlay.onclick = function(){ setUiMode('play'); };
    var btnModeDev = document.getElementById('btnModeDev');
    if (btnModeDev) btnModeDev.onclick = function(){ setUiMode('dev'); };
    var btnPlayPreview = document.getElementById('btnPlayPreview');
    if (btnPlayPreview) btnPlayPreview.onclick = function(){ setUiMode('play'); };

    var btnReveal = document.getElementById('btnReveal');
    if (btnReveal) btnReveal.onclick = function(){ revealEvent(); };
    var btnRevealPlay = document.getElementById('btnRevealPlay');
    if (btnRevealPlay) btnRevealPlay.onclick = function(){ revealEvent(); };
    var btnRestart = document.getElementById('btnRestart');
    if (btnRestart) btnRestart.onclick = function(){ restart(); };
    var btnLog = document.getElementById('btnLog');
    if (btnLog){
      btnLog.onclick = function(){
        if (window.matchMedia('(max-width:1150px)').matches){
          document.body.classList.toggle('logOpen');
        } else {
          document.body.classList.toggle('logHidden');
        }
      };
    }
    var btnCopyLog = document.getElementById('btnCopyLog');
    if (btnCopyLog) btnCopyLog.onclick = copyLog;
    var btnExportDebug = document.getElementById('btnExportDebug');
    if (btnExportDebug) btnExportDebug.onclick = exportDebug;
    var btnPlayLog = document.getElementById('btnPlayLog');
    if (btnPlayLog) btnPlayLog.onclick = function(){ togglePlayLog(); };
    var btnPlayLogClose = document.getElementById('btnPlayLogClose');
    if (btnPlayLogClose) btnPlayLogClose.onclick = function(){ togglePlayLog(false); };
    var btnPlayRules = document.getElementById('btnPlayRules');
    if (btnPlayRules) btnPlayRules.onclick = openRules;
    var rulesClose = document.getElementById('rulesClose');
    if (rulesClose) rulesClose.onclick = closeRules;
    var rulesBack = document.getElementById('rulesBack');
    if (rulesBack) rulesBack.addEventListener('click', function(e){ if (e.target.id === 'rulesBack') closeRules(); });

    var botProfileSelect = document.getElementById('optBotProfile');
    if (botProfileSelect){
      botProfileSelect.innerHTML = '';
      for (var i=0;i<BOT_MODULES.length;i++){
        var opt = document.createElement('option');
        opt.value = BOT_MODULES[i].id;
        opt.textContent = BOT_MODULES[i].name;
        botProfileSelect.appendChild(opt);
      }
      botProfileSelect.value = state.botProfileId;
      botProfileSelect.onchange = function(){
        applyBotProfileToBots(botProfilePick());
        updateUI();
      };
    }

    var optControlMode = document.getElementById('optControlMode');
    if (optControlMode) optControlMode.onchange = function(){ updateUI(); pumpBots(); };
    var optSpeed = document.getElementById('optSpeed');
    if (optSpeed) optSpeed.onchange = function(){ pumpBots(); };
    var optAggCountdown = document.getElementById('optAggCountdown');
    if (optAggCountdown) optAggCountdown.onchange = function(){ updateUI(); };
    var optDecisionTimer = document.getElementById('optDecisionTimer');
    if (optDecisionTimer){
      optDecisionTimer.onchange = function(){
        updateUI();
        if (state.awaitingDecision) startDecisionTimer();
      };
    }
    var optDebugAssertFail = document.getElementById('optDebugAssertFail');
    if (optDebugAssertFail){
      optDebugAssertFail.onchange = function(){
        state.debugAssertFail = !!optDebugAssertFail.checked;
        state.debugAssertTriggered = false;
      };
    }
    var btnAddBot = document.getElementById('btnAddBot');
    if (btnAddBot) btnAddBot.onclick = addBot;
    var btnRemoveBot = document.getElementById('btnRemoveBot');
    if (btnRemoveBot) btnRemoveBot.onclick = removeBot;

    var btnStay = document.getElementById('btnStay');
    if (btnStay) btnStay.onclick = function(){ state.humanChoice = 'stay'; state.humanLockedIn = true; updateUI(); };
    var btnCamp = document.getElementById('btnCamp');
    if (btnCamp) btnCamp.onclick = function(){ state.humanChoice = 'camp'; state.humanLockedIn = true; updateUI(); };
    var btnResolve = document.getElementById('btnResolve');
    if (btnResolve) btnResolve.onclick = function(){ resolveDecisions(); };

    // init
    if (shouldRunSelfTests()){
      runSelfTests();
    }
    window.exportDebug = exportDebug;
    restart();
    setUiMode('play');
  })();
  </script>
</body>
</html>
